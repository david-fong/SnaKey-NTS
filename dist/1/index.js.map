{"version":3,"sources":["webpack://snakey3/./src/base/game/Game.ts","webpack://snakey3/./src/base/floor/Coord.ts","webpack://snakey3/./src/base/floor/Tile.ts","webpack://snakey3/./src/base/floor/VisibleGrid.ts","webpack://snakey3/./src/base/lang/LangSeqTreeNode.ts","webpack://snakey3/./src/base/game/events/EventRecordEntry.ts","webpack://snakey3/./src/base/game/events/PlayerActionEvent.ts","webpack://snakey3/./src/base/floor/VisibleTile.ts","webpack://snakey3/./src/base/lang/Lang.ts","webpack://snakey3/./src/base/floor/TileGetter.ts","webpack://snakey3/./src/base/game/player/PlayerSkeleton.ts","webpack://snakey3/./src/base/game/player/Team.ts","webpack://snakey3/./src/base/game/player/PlayerStatus.ts","webpack://snakey3/./src/base/game/player/Player.ts","webpack://snakey3/./src/base/game/player/OperatorPlayer.ts","webpack://snakey3/./src/base/game/player/ArtificialPlayer.ts","webpack://snakey3/./src/base/lang/impl/English.ts","webpack://snakey3/./src/base/game/player/VisiblePlayerStatus.ts","webpack://snakey3/./src/base/game/__gameparts/Base.ts","webpack://snakey3/./src/base/game/__gameparts/Events.ts","webpack://snakey3/./src/base/floor/Grid.ts","webpack://snakey3/./src/base/floor/impl/Euclid2.ts","webpack://snakey3/./src/base/floor/impl/Beehive.ts","webpack://snakey3/./src/base/game/IndexTasks.ts","webpack://snakey3/./src/base/game/__gameparts/Manager.ts","webpack://snakey3/./src/client/OfflineGame.ts","webpack://snakey3/./src/base/game/player/artificials/Chaser.ts","webpack://snakey3/./src/client/ScratchMakeGame.ts"],"names":["Game","Type","CtorArgs","Serialization","Status","EVENT_NAME","Object","freeze","Coord","System","Abstract","desc","Mathy","prototype","coord","this","Id","NULL","evictOccupant","lastKnownUpdateId","freeHealth","setLangCharSeqPair","CharSeqPair","playerId","immigrantInfo","occupantId","newFreeHealth","charSeqPair","char","seq","VisibleGrid","LangSeqTreeNode","EventRecordEntry","coordDesc","super","baseElem","document","createElement","classList","add","OmHooks","Tile","Class","BASE","pthbElem","POINTER_HB","appendChild","charElem","LANG_CHAR","langCharElem","seqElem","LANG_SEQ","langSeqElem","parent","__setOccupant","playerElem","innerText","username","langSeq","dataset","Dataset","HEALTH","toString","langChar","getImplementation","coordSys","__Constructors","sequence","characters","children","forwardDict","reverseDict","Map","weightedChar","WeightedLangChar","weight","charArray","get","push","set","rootNode","Root","Array","from","sort","mappingA","mappingB","length","forEach","mapping","addCharMapping","finalize","validateConstruction","child","startsWith","Error","reset","inheritingHitCount","inheritingWeightedHitCount","i","Math","random","incrementNumHits","chars","Seq","REGEXP","test","RangeError","source","node","childNode","find","balancingScheme","slice","CMP","shift","pair","hitWeightedChar","__recursiveIncrementNumHits","weightInv","reduce","prev","curr","hitCount","upstreamNodes","leafNodes","__recursiveGetLeafNodes","map","simpleView","assign","create","hits","personalHitCount","kids","__proto__","undefined","LEAF_CMP","BalancingScheme","SEQ","a","b","CHAR","WEIGHT","PATH_CMP","averageCharHitCount","personalWeightedHitCount","TypeError","weightedHitCount","classIf","static","treeMap","CREATE_TREE_MAP","getLeafNodes","avoid","nodeToHit","leaf","andNonRootParents","conflictSeq","avoidSeq","splice","chooseOnePair","name","getName","getBlurb","root","EVENT_ID_REJECT","PlayerActionEvent","INITIAL_REQUEST_ID","Bubble","Movement","lastAcceptedRequestId","eventId","affectedNeighbours","playerLastAcceptedRequestId","destTile","newPlayerHealth","tilesWithHealthUpdates","dest","newCharSeqPair","TileGetter","args","__getTileAt","Query","__getTileDestsFrom","__getTileSourcesTo","contents","filter","tile","isOccupied","game","trunc","status","noCheckGameOver","TileGetterSource","spawnTile","hostTile","gameType","ONLINE","PlayerSkeleton","player","grid","at","destsFrom","sourcesTo","Team","teamId","members","id","every","member","ElimOrder","IMMORTAL","STANDING","elimOrder","teamElimOrder","score","health","newValue","newHealth","oldIsDowned","isDowned","team","teams","numNonStandingTeams","statusBecomeOver","Username","familyId","requestInFlight","PLAYING","processMoveRequest","other","includes","Player","playerDescs","langName","teamIdCleaner","Set","originalId","squashedId","pda","pdb","playerDesc","index","socketId","langRemappingFunc","RemappingFunctions","prevCoord","event","keyCode","equals","makeMovementRequest","getUntAwayFrom","key","seqBufferAcceptKey","unts","unoccupied","newSeqBuffer","seqBuffer","substring","possibleTarget","visualBell","moveTo","ArtificialPlayer","dOverlayElem","DOWNED_OVERLAY","operator","FACE_SWATCH","spotlightElem","SPOTLIGHT","__immigrantInfoCache","dataDowned","DOWNED","movementContinueWithInitialDelay","cancelTimeout","scheduledMovementCallbackId","getUntToward","computeDesiredDestination","setTimeout","movementContinue","computeNextMovementTimer","of","English","Lowercase","entries","LETTER_FREQUENCY","accumulator","current","Names","ENGLISH__LOWERCASE","SINGLETON","seal","MixedCase","initializer","addMappings","charSeqTransform","cs","toLowerCase","toUpperCase","ENGLISH__MIXEDCASE","c","d","e","f","g","h","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","impl","gridClass","__getGridImplementation","tileClass","dimensions","gridDimensions","domParentHtmlIdHook","gridHtmlIdHook","__playerStatusCtor","playerStatusCtor","players","createPlayers","operatorIndex","teammateArray","PAUSED","gameDesc","languageName","playerIndex","Family","HUMAN","__createOperatorPlayer","__createArtifPlayer","csps","playerCoords","healthCoords","forEachTile","ser","__abstractNotifyThatGameStatusBecamePlaying","__abstractStatusBecomePlaying","focus","__abstractNotifyThatGameStatusBecamePaused","__abstractStatusBecomePaused","__abstractNotifyThatGameStatusBecameOver","__abstractStatusBecomeOver","OVER","eventRecord","doCheckOperatorSeqBuffer","clientEventLag","recordEvent","executeTileModEvent","Grid","averageFreeHealth","averageFreeHealthPerTile","area","lang","getInstance","minLangLeaves","getAmbiguityThreshold","numLeaves","langBalancingScheme","dryRunShuffleLangCharSeqAt","spawnPoints","getSpawnCoords","dryRunSpawnFreeHealth","tileModDesc","targetTile","flatMap","sourceToTarget","getNonConflictingChar","healthToSpawn","currentFreeHealth","retval","getRandomCoord","tileHealthToAdd","managerCheckGamePlayingRequest","processMoveExecute","getNextUnusedEventId","bubbler","processBubbleExecute","OFFLINE","__afterAllPlayersConstruction","addEventListener","ev","processKeyboardInput","preventDefault","callback","millis","handle","clearTimeout","getArea","gridImplElem","OHG","tabIndex","IMPL_BODY","parentElem","getElementById","COORD_SYS","GRID","General","TEXT_SELECT_DISABLED","querySelectorAll","remove","kbdDcIcon","querySelector","KBD_DC_ICON","Euclid2","round","sub","originOneNorm","abs","originInfNorm","max","originAxialAlignment","scalar","row","height","newRow","col","width","newTile","SIZE_LIMITS","consumer","thisArg","sourceCoord","intendedDest","options","tileA","TileB","oneNorm","infNorm","axialAlignment","floor","avoidCoord","radius","min","gridRow","playerCounts","dim","Visible","gridElem","style","setProperty","__addToDom","__VisibleGrid_super","Beehive","dash","bash","floorDash","floorBash","shorterSide","fslash","bslash","longerSide","IndexTasks","INIT_CLASS_REGISTRIES","VGr","AP","CHASER","statusBecomePlaying"],"mappings":"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","file":"1/index.js","sourcesContent":["import type { Lang } from \"lang/Lang\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Grid } from \"floor/Grid\";\r\nimport type { Player, PlayerStatus } from \"./player/Player\";\r\n\r\n\r\n/**\r\n *\r\n *\r\n * These classes perform the majority of management over {@link Tile}\r\n * and {@link Player} objects. As a design choice, players can only join\r\n * a game before it starts, and actions such as changing the language or\r\n * difficulty require a restart. These actions that require a restart will\r\n * all be exposed to operators through a pre-game page. Other such actions\r\n * include: changing teams.\r\n *\r\n * There are overlaps between what each implementation needs to do:\r\n * - Offline and Server games maintain and control the master-game-state.\r\n * - Offline and Client games display the game-state to an operator via browser and HTML.\r\n * - Client  and Server games use network operations to communicate.\r\n */\r\nexport namespace Game {\r\n\r\n    export const enum Type {\r\n        SERVER  = \"SERVER\",\r\n        ONLINE  = \"ONLINE\",\r\n        OFFLINE = \"OFFLINE\",\r\n    }\r\n    export namespace Type {\r\n        export type Manager = Type.OFFLINE | Type.SERVER;\r\n    }\r\n\r\n    /**\r\n     * Unlike CtorArgs, these are not passed as no-prototype objects\r\n     * (possibly over the network) from the game manager to clients.\r\n     * These are abstract handles to game-implementation-dependant\r\n     * components.\r\n     */\r\n    export type ImplArgs<S extends Coord.System> = {\r\n        tileClass: Tile.ClassIf<S>,\r\n        playerStatusCtor: typeof PlayerStatus,\r\n    };\r\n\r\n    /**\r\n     * # Game Constructor Arguments\r\n     *\r\n     * @template S\r\n     * The coordinate system to use. The literal value must also be\r\n     * passed as the field `coordSys`.\r\n     */\r\n    export type CtorArgs<\r\n        G extends Game.Type,\r\n        S extends Coord.System,\r\n    > = Readonly<{\r\n        coordSys: S;\r\n        gridDimensions: Grid.Dimensions<S>;\r\n        gridHtmlIdHook: G extends Game.Type.SERVER ? undefined : string;\r\n\r\n        languageName: Lang.Names.Value[\"id\"];\r\n        langBalancingScheme: Lang.BalancingScheme;\r\n\r\n        /**\r\n         * The index in `playerDescs` of the operator's ctor args.\r\n         */\r\n        operatorIndex: G extends Game.Type.SERVER\r\n            ? undefined\r\n            : Player.Id;\r\n        playerDescs: TU.RoArr<(\r\n            G extends Game.Type.Manager\r\n            ? Player.CtorArgs.PreIdAssignment\r\n            : Player.CtorArgs\r\n        )>;\r\n\r\n        averageFreeHealthPerTile: Player.Health;\r\n    }>;\r\n\r\n    export namespace CtorArgs {\r\n\r\n        export const EVENT_NAME = \"game-create\";\r\n\r\n        /**\r\n         * Not used here, but used in {@link GroupSession#createGameInstance}.\r\n         */\r\n        export type FailureReasons = {\r\n            undefinedUsername: TU.RoArr<Player.SocketId>; // socket ID's\r\n            undefinedTeamId:   TU.RoArr<Player.SocketId>;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Serialization of the Game State after a reset.\r\n     *\r\n     * Only contains state information that would not be known by a\r\n     * non-Game Manager.\r\n     */\r\n    export type ResetSer<S extends Coord.System> = Readonly<{\r\n        csps: TU.RoArr<Lang.CharSeqPair>;\r\n        playerCoords: TU.RoArr<Coord.Bare<S>>;\r\n        healthCoords: TU.RoArr<{\r\n            coord: Coord.Bare<S>;\r\n            health: Player.Health;\r\n        }>;\r\n    }>;\r\n    export namespace Serialization {\r\n        export const EVENT_NAME = <const>\"game-reset\";\r\n    }\r\n\r\n    /**\r\n     * - **`PLAYING`** can go to:\r\n     *   - `PAUSED`: when a pause request initiated by a player is accepted.\r\n     *   - `OVER`:  when certain conditions of players being downed are met.\r\n     * - **`PAUSED`** can go to:\r\n     *   - `PLAYING`: similar to PLAYING->PAUSED.\r\n     * - **`OVER`** can go to:\r\n     *   - `PLAYING`: via resetting the game.\r\n     */\r\n    export const enum Status {\r\n        PLAYING = \"PLAYING\",\r\n        PAUSED  = \"PAUSED\",\r\n        OVER    = \"OVER\",\r\n    }\r\n}\r\nObject.freeze(Game);\r\n","import type { Euclid2 } from \"./impl/Euclid2\";\r\nimport type { Beehive } from \"./impl/Beehive\";\r\n\r\n\r\n/**\r\n * Done manually so that grid implementations can use their coordinate\r\n * implementation's non-standard methods safely on coordinates retrieved\r\n * from Grid tiles.\r\n */\r\nexport type Coord<S extends Coord.System> = (Coord.Bare<S>) &\r\n    ( S extends Coord.System.EUCLID2 ? Euclid2.Coord\r\n    : S extends Coord.System.BEEHIVE ? Beehive.Coord\r\n    : never\r\n    );\r\n\r\n/**\r\n *\r\n */\r\nexport namespace Coord {\r\n\r\n    export const enum System {\r\n        EUCLID2 = \"EUCLID2\",\r\n        BEEHIVE = \"BEEHIVE\",\r\n    }\r\n\r\n    export type Bare<S extends System> =\r\n    ( S extends System.EUCLID2 ? Euclid2.Coord.Bare\r\n    : S extends System.BEEHIVE ? Beehive.Coord.Bare\r\n    : never\r\n    );\r\n\r\n    // ==============================================================\r\n    // Note: The below exports do not require any modifications with\r\n    // the additions of new coordinate systems.\r\n    // ==============================================================\r\n\r\n    /**\r\n     * Immutable. All `Coord` objects returned by operations are new objects.\r\n     *\r\n     * @template S - An enum identifying the unique implementation class.\r\n     */\r\n    export abstract class Abstract<S extends Coord.System> {\r\n\r\n        /**\r\n         * This does nothing. Subclass constructors should copy in the\r\n         * fields specified by `desc` and end with a self-freezing call.\r\n         *\r\n         * @param desc - Untouched. Here as a reminder of what is needed.\r\n         */\r\n        protected constructor(desc: Coord.Bare<S>) {\r\n            desc; // Prevents warning about unused parameter.\r\n        }\r\n\r\n        public abstract equals(other: Coord.Bare<S>): boolean;\r\n    }\r\n\r\n    export namespace Abstract {\r\n        /**\r\n         * As opposed, for example, to grid systems operating on the\r\n         * basis of graph connections that cannot be represented by\r\n         * lattices.\r\n         */\r\n        export abstract class Mathy<S extends Coord.System> extends Coord.Abstract<S> {\r\n            /**\r\n             * For discrete-coordinate-based systems, this is used to round\r\n             * non-discrete coordinates to discrete ones.\r\n             */\r\n            public abstract round(): Coord<S>;\r\n\r\n            public abstract add(other: Coord.Bare<S>): Coord<S>;\r\n            public abstract sub(other: Coord.Bare<S>): Coord<S>;\r\n            public abstract mul(scalar: number): Coord<S>;\r\n        }\r\n    }\r\n    Object.freeze(Abstract);\r\n    Object.freeze(Abstract.prototype);\r\n\r\n}\r\nObject.freeze(Coord);\r\n// No prototype to freeze.\r\n","import { Lang, Player } from \"utils/TypeDefs\";\r\nimport { Coord } from \"./Coord\";\r\nexport { Coord };\r\n\r\n\r\n/**\r\n * # The Tile Class\r\n *\r\n * As an implementation choice, tiles are dumb. That is, they have\r\n * no knowledge of their context. Their internals are all managed by\r\n * their host {@link Game} through method calls.\r\n *\r\n * From a caller's point of view, extending classes should have am\r\n * identical constructor signature as that of this base class. This\r\n * can be done by a type assertion statement: `<extension class> as\r\n * Tile.ConstructorType<any>`.\r\n *\r\n * @template S\r\n * The coordinate system enum for this tile's coordinate.\r\n */\r\nexport class Tile<S extends Coord.System> {\r\n\r\n    public readonly coord: Coord<S>;\r\n    #occupantId: Player.Id.Nullable;\r\n    #freeHealth: Player.Health;\r\n    #langChar:  Lang.Char;\r\n    #langSeq:   Lang.Seq;\r\n\r\n    /**\r\n     * The number of times this `Tile` was occupied since the last\r\n     * reset. This is used to ensure that in online sessions, each\r\n     * client has a synchronized copy of the game. The Game Manager\r\n     * will drop requests for movements made by players who made the\r\n     * request at a time when they had not yet received information\r\n     * related to the game-state in affected-zones of their request.\r\n     */\r\n    public lastKnownUpdateId: number;\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param coord -\r\n     */\r\n    public constructor(coord: Coord<S>) {\r\n        this.coord = coord;\r\n        this.#occupantId = Player.Id.NULL;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.evictOccupant();\r\n        this.lastKnownUpdateId = 0;\r\n        this.freeHealth = 0;\r\n\r\n        // This is also done when shuffling individual tiles throughout\r\n        // the game, but it is done here since initially, nothing needs\r\n        // to be avoided because no CSP's have been set yet.\r\n        this.setLangCharSeqPair(Lang.CharSeqPair.NULL);\r\n    }\r\n\r\n    /**\r\n     * Called, for example, when a {@link Player} on this `Tile` provides\r\n     * input that did not work to complete their {@link Player#seqBuffer}\r\n     * against any neighbouring `Tile`s.\r\n     */\r\n    public visualBell(): void {\r\n        // does nothing by default.\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Any overrides must make a supercall to this implementation.\r\n     *\r\n     * Must be followed by a call to `PlayerStatus.__onAfterOccupy()`.\r\n     *\r\n     * @param playerId -\r\n     */\r\n    public __setOccupant(\r\n        playerId: Player.Id,\r\n        immigrantInfo: Tile.VisibleImmigrantInfo | undefined,\r\n    ): void {\r\n        this.#occupantId = playerId;\r\n    }\r\n\r\n    public get isOccupied(): boolean {\r\n        return this.occupantId !== Player.Id.NULL;\r\n    }\r\n\r\n    public evictOccupant(): void {\r\n        this.#occupantId = Player.Id.NULL;\r\n    }\r\n\r\n    public get occupantId(): Player.Id.Nullable {\r\n        return this.#occupantId;\r\n    }\r\n\r\n\r\n\r\n    public get freeHealth(): Player.Health {\r\n        return this.#freeHealth;\r\n    }\r\n\r\n    public set freeHealth(newFreeHealth: Player.Health) {\r\n        this.#freeHealth = newFreeHealth;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public setLangCharSeqPair(charSeqPair: Lang.CharSeqPair): void {\r\n        this.#langChar = charSeqPair.char;\r\n        this.#langSeq  = charSeqPair.seq;\r\n    }\r\n\r\n    public get langChar(): Lang.Char {\r\n        return this.#langChar;\r\n    }\r\n\r\n    public get langSeq(): Lang.Seq {\r\n        return this.#langSeq;\r\n    }\r\n\r\n}\r\n// If this errs when changing the constructor signature, then\r\n// the type definition being asserted should be updated to match.\r\nTile as Tile.ClassIf<any>;\r\n\r\n\r\n\r\nexport namespace Tile {\r\n\r\n    // NOTE: We need this for type-safety because just using typeof\r\n    // will not capture information about type arguments.\r\n    export type ClassIf<S extends Coord.System> = {\r\n        new(coord: Tile<S>[\"coord\"]): Tile<S>;\r\n    };\r\n\r\n    export type VisibleImmigrantInfo = Readonly<{\r\n        playerElem: HTMLElement;\r\n        username:   string;\r\n    }>;\r\n}\r\nObject.freeze(Tile);\r\nObject.freeze(Tile.prototype);\r\n","import type { Coord, Tile } from \"floor/Tile\";\r\nimport { Grid } from \"floor/Grid\";\r\n\r\n\r\n/**\r\n * All implementations must call `Grid.__VisibleGrid_super` at the end\r\n * of their constructors.\r\n *\r\n * NOTE: As a design choice, this is put in a separate file from the\r\n * base `Grid` class with a _separate_ dictionary of implementation\r\n * literals so that the build tooling can infer that this code can\r\n * be excluded (tree shaking). The implementations may still go in\r\n * the same file as their non-visible implementation since they are\r\n * separate exports (this can be tree-shaken). Specifically, the\r\n * _server_ related code will benefit from this choice since it will\r\n * not use\r\n */\r\nexport interface VisibleGrid<S extends Coord.System> extends Grid<S> {\r\n\r\n    /**\r\n     * Contains the implementation-dependant HTML representation of\r\n     * the grid.\r\n     */\r\n    readonly baseElem: HTMLElement;\r\n\r\n    // This is just a reminder to the developer that such a function\r\n    // exists and is an important part of the architecture. Since\r\n    // VisibleGrid can't be a class (no multiple inheritance), this\r\n    // part of a VisibleGrid's constructor sequence is implemented\r\n    // in Grid.\r\n    __VisibleGrid_super(desc: Grid.CtorArgs<S>, domGrid: HTMLElement): void;\r\n}\r\n\r\n\r\nexport namespace VisibleGrid {\r\n\r\n    export interface ClassIf<S extends Coord.System> extends Grid.ClassIf<S> {\r\n        /**\r\n         * @override\r\n         */\r\n        new(desc: Grid.CtorArgs<S>): VisibleGrid<S>;\r\n    };\r\n\r\n    // Each implementation must register itself into this dictionary.\r\n    export declare const __Constructors: {\r\n        readonly [ S in Coord.System ]: Grid.ClassIf<S>\r\n    };\r\n\r\n    export const getImplementation = <S extends Coord.System>(coordSys: S): ClassIf<S> => {\r\n        const ctor = __Constructors[coordSys];\r\n        return ctor as unknown as ClassIf<S>;\r\n    };\r\n}\r\n","import { Lang as __Lang } from \"utils/TypeDefs\";\r\nimport type { Lang } from \"./Lang\";\r\n\r\n\r\ntype SorterMap<T> = Readonly<Record<Lang.BalancingScheme, (a: T, b: T) => number>>;\r\n\r\n/**\r\n * No `LangSeqTreeNode`s mapped in the `children` field have an empty\r\n * `characters` collection (with the exception of the root node). The\r\n * root node should have a falsy parent, and the `empty string` as its\r\n * `sequence` field, with a correspondingly empty `characters` collection.\r\n *\r\n * All non-root nodes have a `sequence` that is prefixed by their parent's\r\n * `sequence`, and a non-empty `characters` collection.\r\n *\r\n * The enclosing {@link Lang} object has no concept of `LangChar` weights.\r\n * All it has is the interfaces provided by the hit-count getter methods.\r\n */\r\nexport class LangSeqTreeNode<ROOT extends boolean = false> {\r\n\r\n    public readonly sequence:   ROOT extends true ? \"\" : Lang.Seq;\r\n    public readonly characters: TU.RoArr<WeightedLangChar>; // Frozen.\r\n    public readonly parent:     ROOT extends true ? undefined : LangSeqTreeNode;\r\n    public readonly children:   Array<LangSeqTreeNode>; // Frozen.\r\n\r\n    // These fields use weak privacy to leave room for testing and\r\n    // debugging by inspection. They have no getters.\r\n    /**\r\n     * Equals this node's own hit count plus all its ancestors' hit\r\n     * counts.\r\n     */\r\n    private inheritingHitCount: number;\r\n    /**\r\n     * Equals this node's own weighted hit count plus all its ancestors'\r\n     * weighted hit counts.\r\n     */\r\n    private inheritingWeightedHitCount: number;\r\n\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param forwardDict -\r\n     * @returns The root node of a new tree map.\r\n     */\r\n    public static CREATE_TREE_MAP(forwardDict: Lang.CharSeqPair.WeightedForwardMap): LangSeqTreeNode<true> {\r\n        // Reverse the map:\r\n        const reverseDict: Map<Lang.Seq, Array<WeightedLangChar>> = new Map();\r\n        for (const char in forwardDict) {\r\n            const seq = forwardDict[char].seq;\r\n            const weightedChar = new WeightedLangChar(\r\n                char, forwardDict[char].weight,\r\n            );\r\n            const charArray = reverseDict.get(seq);\r\n            if (charArray) {\r\n                // The entry was already made:\r\n                charArray.push(weightedChar);\r\n            } else {\r\n                reverseDict.set(seq, [weightedChar,]);\r\n            }\r\n        }\r\n        // Add mappings in ascending order of sequence length:\r\n        // (this is so that no merging of branches needs to be done)\r\n        const rootNode = new LangSeqTreeNode.Root();\r\n        Array.from(reverseDict)\r\n          //.sort((mappingA, mappingB) => mappingA[0].localeCompare(mappingB[0]))\r\n            .sort((mappingA, mappingB) => mappingA[0].length - mappingB[0].length)\r\n            .forEach((mapping) => {\r\n                rootNode.addCharMapping(...mapping);\r\n            });\r\n        rootNode.finalize();\r\n        return rootNode;\r\n    }\r\n\r\n    protected constructor(\r\n        parent:     LangSeqTreeNode<ROOT>[\"parent\"],\r\n        sequence:   LangSeqTreeNode<ROOT>[\"sequence\"],\r\n        characters: ROOT extends true ? readonly [] : TU.RoArr<WeightedLangChar>,\r\n    ) {\r\n        this.sequence   = sequence;\r\n        this.characters = characters;\r\n        this.parent     = parent;\r\n        this.children   = [];\r\n    }\r\n\r\n    private finalize(): void {\r\n        this.validateConstruction();\r\n        Object.freeze(this.characters);\r\n        Object.freeze(this.children);\r\n        this.children.forEach((child) => child.finalize());\r\n    }\r\n\r\n    // TODO.test move this to only be run in tests?\r\n    protected validateConstruction(): void | never {\r\n        if (!(this.sequence.startsWith(this.parent!.sequence))) {\r\n            throw new Error(\"Child node's sequence must start with that of its parent.\");\r\n        }\r\n    }\r\n\r\n    public reset(): void {\r\n        // Recursively reset (from leaves first to root last):\r\n        // We must go in such an order so that our random hit\r\n        // seeds will be properly inherited (and not wrongly\r\n        // cleared).\r\n        this.children.forEach((child) => child.reset());\r\n\r\n        this.inheritingHitCount = 0;\r\n        this.inheritingWeightedHitCount = 0.000;\r\n        this.characters.forEach((char) => {\r\n            char.reset();\r\n            // Seed with properly-weight-distributed hit counts\r\n            // for a uniformly distributed random number of times.\r\n            // The choice of the upper bound on the number of times\r\n            // is rather arbitrary, but it should not be too small.\r\n            for (let i = 0; i < Math.random() * 10; i++) {\r\n                this.incrementNumHits(char);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param seq The typeable sequence corresponding to entries of `chars`.\r\n     * @param chars A collection of unique characters in a written language.\r\n     */\r\n    protected addCharMapping(seq: Lang.Seq, chars: TU.RoArr<WeightedLangChar>): void {\r\n        if (!(__Lang.Seq.REGEXP.test(seq))) {\r\n            throw new RangeError(`Mapping-sequence \\\"${seq}\\\" did not match the`\r\n            + ` required regular expression \\\"${__Lang.Seq.REGEXP.source}\\\".`\r\n            );\r\n        } else if (chars.length === 0) {\r\n            throw new Error(\"Must not make mapping without written characters.\");\r\n        }\r\n        let node: LangSeqTreeNode<any> = this; {\r\n            let childNode: LangSeqTreeNode<any> | undefined = this;\r\n            while (childNode) {\r\n                node = childNode;\r\n                childNode = childNode.children.find((child) => seq.startsWith(child.sequence));\r\n            }\r\n        }\r\n        if (node.sequence === seq) {\r\n            // This should never happen.\r\n            throw new Error(`Mappings for all written-characters with a common`\r\n            + `corresponding typeable-sequence should be registered together,`\r\n            + `but an existing mapping for the sequence \\\"${seq}\\\" was found.`\r\n            );\r\n        }\r\n        node.children.push(new LangSeqTreeNode(node, seq, chars));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Incrementing the hit-count makes this node less likely to be\r\n     * used for a shuffle-in. Shuffle-in option searching is easy to\r\n     * taking the viewpoint of leaf-nodes, so this implementation is\r\n     * geared toward indicating hit-count through leaf-nodes, hence\r\n     * the bubble-down of hit-count incrementation.\r\n     *\r\n     * @param balancingScheme -\r\n     * @returns A character / sequence pair from this node that has\r\n     *      been selected the least according to the specified scheme.\r\n     */\r\n    public chooseOnePair(balancingScheme: Lang.BalancingScheme): Lang.CharSeqPair {\r\n        const weightedChar = this.characters.slice(0)\r\n            .sort(WeightedLangChar.CMP[balancingScheme])\r\n            .shift()!;\r\n        const pair: Lang.CharSeqPair = {\r\n            char: weightedChar.char,\r\n            seq:  this.sequence,\r\n        };\r\n        this.incrementNumHits(weightedChar);\r\n        return pair;\r\n    }\r\n    private incrementNumHits(hitWeightedChar: WeightedLangChar): void {\r\n        hitWeightedChar.incrementNumHits();\r\n        this.__recursiveIncrementNumHits(hitWeightedChar.weightInv);\r\n    }\r\n    private __recursiveIncrementNumHits(weightInv: number): void {\r\n        this.inheritingHitCount += 1;\r\n        this.inheritingWeightedHitCount += weightInv;\r\n        this.children.forEach((child) => child.__recursiveIncrementNumHits(weightInv));\r\n    }\r\n\r\n    /**\r\n     * Do not call this on a root node.\r\n     *\r\n     * @returns How many hits were made on this node since the last reset.\r\n     */\r\n    protected get personalHitCount(): number {\r\n        return this.inheritingHitCount - (this.parent!).inheritingHitCount;\r\n    }\r\n\r\n    protected get averageCharHitCount(): number {\r\n        return (\r\n            this.characters.reduce<number>((prev, curr) => prev + curr.hitCount, 0)\r\n            / this.characters.length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Do not call this on a root node.\r\n     *\r\n     * @returns How many hits were made on this node since the last reset.\r\n     */\r\n    protected get personalWeightedHitCount(): number {\r\n        return this.inheritingWeightedHitCount - (this.parent!).inheritingWeightedHitCount;\r\n    }\r\n\r\n    public andNonRootParents(): Array<LangSeqTreeNode> {\r\n        const upstreamNodes: Array<LangSeqTreeNode> = [];\r\n\r\n        let node = this as LangSeqTreeNode;\r\n        while (node.parent) {\r\n            upstreamNodes.push(node);\r\n            node = node.parent;\r\n        }\r\n        return upstreamNodes;\r\n    }\r\n\r\n    public getLeafNodes(): Array<LangSeqTreeNode> {\r\n        const leafNodes: Array<LangSeqTreeNode> = [];\r\n        this.__recursiveGetLeafNodes(leafNodes);\r\n        return leafNodes;\r\n    }\r\n    private __recursiveGetLeafNodes(leafNodes: Array<LangSeqTreeNode>): void {\r\n        if (this.children.length) {\r\n            this.children.forEach((child) => {\r\n                child.__recursiveGetLeafNodes(leafNodes);\r\n            });\r\n        } else {\r\n            leafNodes.push(this as LangSeqTreeNode);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public simpleView(): object {\r\n        let chars = this.characters.map((char) => char.simpleView());\r\n        return Object.assign(Object.create(null), {\r\n            seq: this.sequence,\r\n            chars: (chars.length === 1) ? chars[0] : chars,\r\n            hits: this.personalHitCount,\r\n            kids: this.children.map((child) => child.simpleView()),\r\n            __proto__: undefined,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param a -\r\n     * @param b -\r\n     * @returns -\r\n     */\r\n    public static readonly LEAF_CMP: SorterMap<LangSeqTreeNode> = Object.freeze({\r\n        [ __Lang.BalancingScheme.SEQ ]:    ((a, b) => a.inheritingHitCount - b.inheritingHitCount),\r\n        [ __Lang.BalancingScheme.CHAR ]:   ((a, b) => a.inheritingHitCount - b.inheritingHitCount),\r\n        [ __Lang.BalancingScheme.WEIGHT ]: ((a, b) => a.inheritingWeightedHitCount - b.inheritingWeightedHitCount),\r\n    });\r\n\r\n    /**\r\n     * @param a -\r\n     * @param b -\r\n     * @returns -\r\n     */\r\n    public static readonly PATH_CMP: SorterMap<LangSeqTreeNode> = Object.freeze({\r\n        [ __Lang.BalancingScheme.SEQ ]:    ((a, b) => a.personalHitCount - b.personalHitCount),\r\n        [ __Lang.BalancingScheme.CHAR ]:   ((a, b) => a.averageCharHitCount - b.averageCharHitCount),\r\n        [ __Lang.BalancingScheme.WEIGHT ]: ((a, b) => a.personalWeightedHitCount - b.personalWeightedHitCount),\r\n    });\r\n\r\n}\r\n\r\n\r\nexport namespace LangSeqTreeNode {\r\n    export class Root extends LangSeqTreeNode<true> {\r\n        public constructor() {\r\n            super(undefined, \"\", []);\r\n        }\r\n        public validateConstruction(): void {\r\n            // nothing.\r\n        }\r\n        public chooseOnePair(balancingScheme: Lang.BalancingScheme): never {\r\n            throw new TypeError(\"Must never hit on the root.\");\r\n        }\r\n        protected get personalHitCount(): number {\r\n            throw new TypeError(\"Must never hit on the root.\");\r\n        }\r\n        protected get personalWeightedHitCount(): never {\r\n            throw new TypeError(\"Must never hit on the root.\");\r\n        }\r\n        public andNonRootParents(): never {\r\n            throw new TypeError();\r\n        }\r\n        public simpleView(): object {\r\n            return this.children.map((child) => child.simpleView());\r\n        }\r\n    }\r\n}\r\nObject.freeze(LangSeqTreeNode);\r\nObject.freeze(LangSeqTreeNode.prototype);\r\n\r\n\r\n\r\n/**\r\n * Has no concept of an associated typeable sequence. Used to associate\r\n * a written character to a relative frequency of occurrence in samples\r\n * of writing, and to keep a counter for how many times this character\r\n * has been shuffled-in in the current game session.\r\n *\r\n * Not exported.\r\n */\r\nclass WeightedLangChar {\r\n\r\n    public readonly char: Lang.Char;\r\n\r\n    /**\r\n     * A weight is relative to weights of other unique characters in\r\n     * the contextual language. A character with a higher weight, when\r\n     * using the {@link BalancingScheme#WEIGHT} scheme, will have a\r\n     * higher shuffle-in priority than characters with a lower weight.\r\n     *\r\n     * Specifically, using the {@link BalancingScheme#WEIGHT} scheme,\r\n     * a character `cA` with a weight `N` times that of another `cB`\r\n     * will, on average, be returned `N` times more often by the\r\n     * {@link LangSeqTreeNode#chooseOnePair} method than `cB`.\r\n     *\r\n     * This is implemented using counters that last for the lifetime\r\n     * of one game, and increment for a chosen character by the inverse\r\n     * of its weight every time it is chosen. Choosing the character\r\n     * with the lowest such counter at a given time will produce the\r\n     * desired effect:\r\n     *\r\n     * If there are three characters mapped with weights `cA: 1`, `cB:\r\n     * 2`, `cC: 3`, and share no prefixing substrings and we pretend\r\n     * that there are never any sequences to avoid when shuffling in\r\n     * characters, then the results of consecutive calls should produce\r\n     * something like: `A(0), B(0), C(0), A(1/3), B(1/2), A(2/3),\r\n     * (repeat forever)`, where the bracketed values are their weighted\r\n     * hit-counts before they were returned, since the last reset.\r\n     */\r\n    public readonly weightInv: number;\r\n    public hitCount: number;\r\n    public weightedHitCount: number;\r\n\r\n    public constructor(\r\n        char: Lang.Char,\r\n        weight: number,\r\n    ) {\r\n        if (weight <= 0) {\r\n            throw new RangeError(`All weights must be positive, but we`\r\n            + ` were passed the value \\\"${weight}\\\" for the character`\r\n            + ` \\\"${char}\\\".`);\r\n        }\r\n        this.char = char;\r\n        this.weightInv = 1.000 / weight;\r\n        // The above choice of a numerator is not behaviourally significant.\r\n        // All that is required is that all single-mappings in a `Lang` use\r\n        // a consistent value.\r\n    }\r\n\r\n    public reset(): void {\r\n        this.hitCount = 0;\r\n        this.weightedHitCount = 0.000;\r\n    }\r\n\r\n    public incrementNumHits(): void {\r\n        this.hitCount += 1;\r\n        this.weightedHitCount += this.weightInv;\r\n    }\r\n\r\n    public simpleView(): object {\r\n        return Object.assign(Object.create(null), {\r\n            char: this.char,\r\n            hits: this.hitCount,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param a -\r\n     * @param b -\r\n     * @returns -\r\n     */\r\n    public static readonly CMP: SorterMap<WeightedLangChar> = Object.freeze({\r\n        [ __Lang.BalancingScheme.SEQ ]:    (a, b) => a.hitCount - b.hitCount, // design choice.\r\n        [ __Lang.BalancingScheme.CHAR ]:   (a, b) => a.hitCount - b.hitCount,\r\n        [ __Lang.BalancingScheme.WEIGHT ]: (a, b) => a.weightedHitCount - b.weightedHitCount,\r\n    });\r\n};\r\nObject.freeze(WeightedLangChar);\r\nObject.freeze(WeightedLangChar.prototype);\r\n","import type { Player } from \"game/player/Player\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport interface EventRecordEntry {\r\n    /**\r\n     * A positive, integer-valued identifier for an event.\r\n     *\r\n     * Must be unique in its context.\r\n     *\r\n     * The request-maker should make the request with this set to.\r\n     * {@link EVENT_ID_REJECT}.\r\n     */\r\n    eventId: number;\r\n}\r\nexport namespace EventRecordEntry {\r\n    /**\r\n     * The Game Manager should assign this value to the `eventId` field\r\n     * of a request-type event to signal if a request has been rejected.\r\n     * It is convenient to use as a default value.\r\n     */\r\n    export const EVENT_ID_REJECT = -1;\r\n}\r\nObject.freeze(EventRecordEntry);\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport interface PlayerGeneratedRequest extends EventRecordEntry {\r\n\r\n    readonly playerId: Player.Id;\r\n\r\n    /**\r\n     * ### Client Request\r\n     *\r\n     * Requester sends this desc to the Game Manager with a value of\r\n     * the ID of the last request it that the server _accepted_. This\r\n     * naturally implies that a requester cannot send a new request to\r\n     * the Game Manager until it has received the Game Manager's\r\n     * response to the last request it made.\r\n     *\r\n     * ### Server Response\r\n     *\r\n     * If the server accepts the request, it must broadcast a response\r\n     * with this field set to the incremented value.\r\n     *\r\n     * If it rejects this request, it must directly acknowledge its\r\n     * receipt of the request (no need to broadcast to all clients)\r\n     * with this field unchanged, which indicates a rejection of the\r\n     * request.\r\n     *\r\n     * ### Handling Unexpected Values\r\n     *\r\n     * If the server / Game Manager receives a request with a value in\r\n     * this field lower than the one it set in its last response to the\r\n     * requester, this would mean that the requester didn't wait for a\r\n     * response to its previous request, which it is not supposed to do.\r\n     *\r\n     * **Important:** If the above requirement is ever changed, (in\r\n     * addition to other mechanisms I haven't reasoned through,) this\r\n     * field's spec should change to require _all_ server responses to\r\n     * have this field set to an incremented value, including rejects.\r\n     *\r\n     * The server should never receive a request with a value higher\r\n     * than the one it provided in its last response to this requester\r\n     * because it in charge of incrementing it- the client should only\r\n     * change the value it sees to match the one from the server's\r\n     * response.\r\n     *\r\n     * In both these cases, the server may throw an assertion error for\r\n     * debugging purposes.\r\n     */\r\n    playerLastAcceptedRequestId: number;\r\n};\r\n","import type { Lang } from \"lang/Lang\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"game/player/Player\";\r\nimport { EventRecordEntry, PlayerGeneratedRequest } from \"./EventRecordEntry\";\r\n\r\n\r\nexport type TileModEvent<S extends Coord.System> = {\r\n    readonly coord: Coord.Bare<S>;\r\n\r\n    /**\r\n     * The requester should set this field to the highest value they\r\n     * received from any previous responses from the server. In normal\r\n     * cases (no message reordering), this should be equal to the last\r\n     * value seen in the response from the server.\r\n     *\r\n     * The server should respond with the increment of this value. A\r\n     * movement event causes a shuffle-in at the destination position,\r\n     * which can affect whether another player intending to move to\r\n     * the same position can do so. For this reason, the server should\r\n     * reject requests where the requester has not received changes\r\n     * involving a shuffle-in at their desired destination. This is\r\n     * not mandatory, but preferred behaviour.\r\n     */\r\n    lastKnownUpdateId: number;\r\n\r\n    newFreeHealth?: Player.Health;\r\n\r\n    /**\r\n     * Any value assigned by the requester to this field should be\r\n     * ignored by the server.\r\n     *\r\n     * The server must set this to describe the new values to be\r\n     * shuffled-in to the destination tile. It may set the field\r\n     * to `undefined` if it wants to leave the CSP unchanged.\r\n     */\r\n    newCharSeqPair?: Lang.CharSeqPair;\r\n};\r\n\r\n\r\n\r\nexport namespace PlayerActionEvent {\r\n\r\n    /**\r\n     * This is the agreed upon value that both the server and client\r\n     * copies of a game should set as the initial value for request id\r\n     * counters. Remember that a request ID is a property of a player,\r\n     * whereas an event ID is a property tied to a game.\r\n     */\r\n    export const INITIAL_REQUEST_ID = -1;\r\n\r\n    export const EVENT_NAME = Object.freeze(<const>{\r\n        Bubble:   \"player-bubble\"  ,\r\n        Movement: \"player-movement\",\r\n    });\r\n\r\n\r\n    /**\r\n     *\r\n     */\r\n    export class Bubble implements PlayerGeneratedRequest {\r\n\r\n        public eventId: number = EventRecordEntry.EVENT_ID_REJECT;\r\n\r\n        public readonly playerId: Player.Id;\r\n\r\n        /**\r\n         * @see Player#lastAcceptedRequestId\r\n         */\r\n        public playerLastAcceptedRequestId: number;\r\n\r\n        public affectedNeighbours?: TU.RoArr<{\r\n            readonly playerId:  Player.Id;\r\n            readonly newHealth: Player.Health;\r\n        }> = undefined;\r\n\r\n        public constructor(\r\n            playerId: Player.Id,\r\n            lastAcceptedRequestId: number,\r\n        ) {\r\n            this.playerId = playerId;\r\n            this.playerLastAcceptedRequestId = lastAcceptedRequestId;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * ## Player Movement Event\r\n     *\r\n     * This single method-less class carries the bare-minimum information\r\n     * needed to describe a client's request for movement to the server,\r\n     * and to broadcast an acceptance of the request describing all changes\r\n     * to the game state that must be made (or to otherwise direct-reply\r\n     * the requester in case of request-rejection).\r\n     *\r\n     * It must do so in a way that allows the server and clients to infer\r\n     * whether any message reordering occurred.\r\n     *\r\n     * ### The Problem in Summary\r\n     *\r\n     * - Client copies of the game should lag behind the master copy of\r\n     *   the game state as little as possible with as small of a choking\r\n     *   effect on a client's ability to send requests as possible. This\r\n     *   rules out doing periodic game-state-dump broadcasts (because of\r\n     *   the transmission delay), and \"big-locks\" requiring a client to\r\n     *   have a completely up-to-date copy of the game state to have its\r\n     *   requests processed.\r\n     * - Nothing should ever happen in the client copies of the game that\r\n     *   doesn't happen in the master copy at the server. Ie. Since game-\r\n     *   state-dumps are out of the question, any corruption / de-sync of\r\n     *   the client's copy of the game is considered fatal and completely\r\n     *   unrecoverable.\r\n     * - As a bonus, it would be nice to bake in a mechanism to prevent\r\n     *   malicious or unintended spam from a trigger-happy client without\r\n     *   excessively / unnecessarily throttling the request-making ability\r\n     *   or throughput of any clients.\r\n     */\r\n    export class Movement<S extends Coord.System> extends Bubble {\r\n\r\n        /**\r\n         * Any value assigned by the requester to this field should be\r\n         * ignored by the server. The server should respond with the new\r\n         * values taken on by the player for these fields.\r\n         */\r\n        public newPlayerHealth?: {\r\n            score:  Player.Health;\r\n            health: Player.Health;\r\n        } = undefined;\r\n\r\n        public readonly dest: TileModEvent<S>;\r\n\r\n        public tilesWithHealthUpdates?: TU.RoArr<TileModEvent<S>> = undefined;\r\n\r\n        public constructor(\r\n            playerId: Player.Id,\r\n            lastAcceptedRequestId: number,\r\n            destTile: Tile<S>,\r\n        ) {\r\n            super(playerId, lastAcceptedRequestId);\r\n            this.dest = {\r\n                coord:              destTile.coord,\r\n                lastKnownUpdateId:  destTile.lastKnownUpdateId,\r\n                newCharSeqPair:     undefined,\r\n                newFreeHealth:      undefined,\r\n            };\r\n        }\r\n    }\r\n\r\n}\r\nObject.freeze(PlayerActionEvent);\r\n","import { OmHooks } from \"browser/OmHooks\";\r\nimport type { Lang, Player } from \"utils/TypeDefs\";\r\n\r\nimport { Coord, Tile } from \"./Tile\";\r\n\r\nexport { Coord } from \"./Tile\";\r\n\r\n\r\n/**\r\n * Implicitly handles visuals with help from CSS.\r\n *\r\n * Layers:\r\n * 0. Invisible cell layer (opaque on visual bell)\r\n * 1. Empty layer for spotlight mask\r\n * 2. Player face layer\r\n * 3. Language Written Character\r\n * 4. Language Type-able Sequence\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/z-index\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\r\n *\r\n * Dataset:\r\n * Top-level layer has property \"scoreValue\"\r\n *\r\n * @extends Tile\r\n */\r\nexport class VisibleTile<S extends Coord.System> extends Tile<S> {\r\n\r\n    readonly #baseElem:     HTMLElement;\r\n    private readonly langCharElem:  HTMLDivElement;\r\n    private readonly langSeqElem:   HTMLDivElement;\r\n\r\n    public constructor(coordDesc: Tile<S>[\"coord\"]) {\r\n        super(coordDesc);\r\n        {\r\n            const baseElem = document.createElement(\"div\");\r\n            baseElem.classList.add(OmHooks.Tile.Class.BASE);\r\n            this.#baseElem = baseElem;\r\n        } {\r\n            // Must be the first child. See note in CSS class hook.\r\n            const pthbElem = document.createElement(\"div\");\r\n            pthbElem.classList.add(OmHooks.Tile.Class.POINTER_HB);\r\n            this.#baseElem.appendChild(pthbElem);\r\n        } {\r\n            const charElem = document.createElement(\"div\");\r\n            charElem.classList.add(\r\n                OmHooks.Tile.Class.LANG_CHAR,\r\n            );\r\n            this.#baseElem.appendChild(charElem);\r\n            this.langCharElem = charElem;\r\n        } {\r\n            const seqElem = document.createElement(\"div\");\r\n            seqElem.classList.add(OmHooks.Tile.Class.LANG_SEQ);\r\n            this.#baseElem.appendChild(seqElem);\r\n            this.langSeqElem = seqElem;\r\n        }\r\n    }\r\n\r\n    public __addToDom(parent: HTMLElement): void {\r\n        parent.appendChild(this.#baseElem);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public __setOccupant(\r\n        playerId: Player.Id,\r\n        immigrantInfo: Tile.VisibleImmigrantInfo,\r\n    ): void {\r\n        super.__setOccupant(playerId, immigrantInfo);\r\n        this.#baseElem.appendChild(immigrantInfo.playerElem);\r\n        this.langSeqElem.innerText = immigrantInfo.username;\r\n    }\r\n\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public visualBell(): void {\r\n        this.#baseElem; // TODO.impl Use an animation to flash tile element?\r\n    }\r\n\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public evictOccupant(): void {\r\n        super.evictOccupant();\r\n        // Undo setting mouseover text to occupant username:\r\n        this.langSeqElem.innerText = this.langSeq;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public set freeHealth(newFreeHealth: Player.Health) {\r\n        super.freeHealth = newFreeHealth;\r\n        if (this.freeHealth > 0) {\r\n            this.#baseElem.dataset[OmHooks.Tile.Dataset.HEALTH] = this.freeHealth.toString();\r\n        } else {\r\n            delete this.#baseElem.dataset[OmHooks.Tile.Dataset.HEALTH];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    // NOTE: For some reason, if we override the setter, the transpiled\r\n    // code does not link to the super implementation... Or maybe this\r\n    // is just a property of plain ECMA javascript??\r\n    public get freeHealth(): Player.Health {\r\n        return super.freeHealth;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public setLangCharSeqPair(charSeqPair: Lang.CharSeqPair): void {\r\n        super.setLangCharSeqPair(charSeqPair);\r\n        this.langCharElem.innerText = this.langChar;\r\n        this.langSeqElem.innerText  = this.langSeq;\r\n    }\r\n\r\n}\r\n// Assert that this extension's constructor has a compatible signature:\r\nVisibleTile as Tile.ClassIf<any>;\r\nObject.freeze(VisibleTile);\r\nObject.freeze(VisibleTile.prototype);\r\n","import { Lang as __Lang } from \"utils/TypeDefs\";\r\n\r\nimport { LangSeqTreeNode } from \"lang/LangSeqTreeNode\";\r\n\r\n\r\n/**\r\n * A language is a map from a collection of unique characters to\r\n * corresponding key-sequences. the key-sequences may be non-unique.\r\n * (try searching up \"Chinese riddle where each syllable is pronounced\r\n * 'shi'\"). A character may have more than one corresponding sequence,\r\n * representing alternate \"spellings\" (ways of typing it).\r\n *\r\n * In the use-case of this game, it is more helpful to think in the\r\n * reverse direction: As a map from typeable-key-sequences to sets of\r\n * corresponding unique characters (no character is mapped by multiple\r\n * key-sequences). This game does not require support for retrieving\r\n * the `Lang.Seq` corresponding to a `LangChar`.\r\n *\r\n * See the readme in [the implementations folder](./impl/readme.md)\r\n * for a guide on writing implementations of this class.\r\n */\r\nexport abstract class Lang extends __Lang {\r\n\r\n    /**\r\n     * The abstract, static object for this language.\r\n     */\r\n    public readonly static: Lang.ClassIf;\r\n\r\n    /**\r\n     * A \"reverse\" map from `LangSeq`s to `LangChar`s.\r\n     */\r\n    private readonly treeMap: LangSeqTreeNode<true>;\r\n\r\n    /**\r\n     * A list of leaf nodes in `treeMap` sorted in ascending order by\r\n     * hit-count. Entries should never be removed or added. They will\r\n     * always be sorted in ascending order of `tricklingHitCount`.\r\n     */\r\n    private readonly leafNodes: Array<LangSeqTreeNode>;\r\n\r\n    public get numLeaves(): number { return this.leafNodes.length; }\r\n\r\n\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param classIf -\r\n     * @param forwardDict - Weights are _relative_ values handled by\r\n     *      {@link LangSeqTreeNode}, which requires the provided values\r\n     *      to all be strictly positive values. They do not all need\r\n     *      to sum to a specific value such as 100.\r\n     */\r\n    protected constructor(classIf: Lang.ClassIf, forwardDict: Lang.CharSeqPair.WeightedForwardMap) {\r\n        super();\r\n        this.static = classIf;\r\n        this.treeMap = LangSeqTreeNode.CREATE_TREE_MAP(forwardDict);\r\n        this.leafNodes = this.treeMap.getLeafNodes();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.treeMap.reset();\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns\r\n     * A random `Lang.Char` in this `Lang` whose corresponding\r\n     * `Lang.Seq` is not a prefix of any `Lang.Seq` in `avoid`, and vice\r\n     * versa. They may share a common prefix as long as they are both\r\n     * longer in length than the shared prefix, and they are not equal\r\n     * to one another.\r\n     *\r\n     * This method is called to shuffle the `Lang.Char` / `Lang.Seq`\r\n     * pair at some Tile `A`. `avoid` should contain the `LangSeq`s\r\n     * from all Tiles reachable by a human Player occupying a Tile\r\n     * `B` from which they can also reach `A`\r\n     *\r\n     * In order for this `Lang` to satisfy these constraints, it must\r\n     * be true that the number of leaf nodes in this tree-structure must\r\n     * `avoid` argument.\r\n     *\r\n     * In this implementation, a human Player can only reach a\r\n     * Tile whose coord has an `infNorm` of `1` from\r\n     * that of the Tile they are currently occupying. That is,\r\n     * `avoid` contains `LangSeq`s from all Tiles with an `infNorm`\r\n     * <= `2` from the Tile to shuffle (not including itself).\r\n     * This means that here, the size of `avoid` is always bounded by\r\n     * `(2*2 + 1)^2 - 1 == 24`. Using the English alphabet (26 typeable-\r\n     * letters), this requirement is met by a hair.\r\n     *\r\n     * @param avoid\r\n     * A collection of `Lang.Seq`s to avoid conflicts with when choosing\r\n     * a `Lang.Char` to return.\r\n     *\r\n     * @param balancingScheme -\r\n     */\r\n    public getNonConflictingChar(\r\n        avoid: TU.RoArr<Lang.Seq>,\r\n        balancingScheme: Lang.BalancingScheme,\r\n    ): Lang.CharSeqPair {\r\n        // Wording the spec closer to this implementation: We must find\r\n        // characters from nodes that are not descendants or ancestors\r\n        // of nodes for sequences to avoid. We can be sure that none of\r\n        // the ancestors or descendants of avoid-nodes are avoid-nodes.\r\n\r\n        // Start by sorting according to the desired balancing scheme:\r\n        this.leafNodes.sort(LangSeqTreeNode.LEAF_CMP[balancingScheme]);\r\n\r\n        let nodeToHit: LangSeqTreeNode | undefined = undefined;\r\n        for (const leaf of this.leafNodes) {\r\n            // Take the next leaf node (don't remove it!), and if none of\r\n            // its parents are avoid-nodes, then, from the set of nodes\r\n            // including the leaf node and all its parents (minus the root),\r\n            // choose the node with the least actual/personal hit-count.\r\n            const upstreamNodes: Array<LangSeqTreeNode> = leaf.andNonRootParents();\r\n            for (let i = 0; i < upstreamNodes.length; i++) {\r\n                const conflictSeq: Lang.Seq | undefined = avoid.find(avoidSeq => {\r\n                    return avoidSeq.startsWith(upstreamNodes[i].sequence);\r\n                });\r\n                if (conflictSeq) {\r\n                    if (conflictSeq === upstreamNodes[i].sequence) {\r\n                        // Cannot use anything on this upstream path because\r\n                        // an avoid-node is directly inside it.\r\n                        upstreamNodes.splice(0);\r\n                    } else {\r\n                        // Found a node on an upstream path of an avoid-node.\r\n                        // Doesn't stop us from using what we've found so far.\r\n                        upstreamNodes.splice(i);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (upstreamNodes.length) {\r\n                // Found a non-conflicting upstream node.\r\n                // Find the node with the lowest personal hit-count:\r\n                upstreamNodes.sort(LangSeqTreeNode.PATH_CMP[balancingScheme]);\r\n                nodeToHit = upstreamNodes[0];\r\n                break;\r\n            }\r\n        }\r\n        if (!nodeToHit) {\r\n            // Should never reach here because there is a check in the\r\n            // constructor checking for this invariant.\r\n            throw new Error(`Invariants guaranteeing that a LangSeq can`\r\n            + `always be shuffled-in were not met.`\r\n            );\r\n        }\r\n        return nodeToHit.chooseOnePair(balancingScheme);\r\n    }\r\n\r\n    public simpleView(): object {\r\n        return Object.assign(Object.create(null), {\r\n            name: this.static.getName(),\r\n            desc: this.static.getBlurb(),\r\n            root: this.treeMap.simpleView(),\r\n        });\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport namespace Lang {\r\n\r\n    /**\r\n     * Every constructor function (class literal) implementing the\r\n     * `Lang` class must implement this interface. Ie. These will be\r\n     * implemented as static methods.\r\n     */\r\n    export interface ClassIf {\r\n        getName(): Lang.Names.Value;\r\n        getBlurb(): string;\r\n        getInstance(): Lang;\r\n    };\r\n\r\n    /**\r\n     * An atomic unit in a written language that constitutes a single\r\n     * character. It is completely unique in its language, and has a\r\n     * single corresponding sequence (string) typeable on a keyboard.\r\n     */\r\n    export type Char = __Lang.Char;\r\n\r\n    /**\r\n     * A sequence of characters each matching {@link SEQ_REGEXP}\r\n     * that represent the intermediate interface between an Operator\r\n     * and a `LangChar`. The immediate interface is through the `Lang`\r\n     * implementation's {@link Lang#remapKey} method.\r\n     */\r\n    export type Seq = __Lang.Seq;\r\n\r\n    /**\r\n     * A key-value pair containing a `LangChar` and its corresponding\r\n     * `LangSeq`.\r\n     */\r\n    export type CharSeqPair = __Lang.CharSeqPair;\r\n    export namespace CharSeqPair {\r\n        /**\r\n         * A map from written characters to their corresponding typeable\r\n         * keyboard sequence and relative spawn weight.\r\n         *\r\n         * Shape that must be passed in to the static tree producer. The\r\n         * `Record` type enforces the invariant that {@link Lang.Char}s are\r\n         * unique in a {@link Lang}. \"CSP\" is short for {@link Lang.CharSeqPair}.\r\n         */\r\n        export type WeightedForwardMap = Record<Lang.Char, Readonly<{seq: Lang.Seq, weight: number,}>>;\r\n    }\r\n\r\n    export type BalancingScheme = __Lang.BalancingScheme;\r\n\r\n    export namespace Names {\r\n        export type Key   = __Lang.Names.Key;\r\n        export type Value = __Lang.Names.Value;\r\n    }\r\n\r\n}\r\nObject.freeze(Lang);\r\nObject.freeze(Lang.prototype);\r\n","import type { Coord, Tile } from \"./Tile\";\r\n\r\n\r\ntype CoordSys = Coord.System;\r\n\r\ntype Arguments<S extends CoordSys> = [ Coord.Bare<S>, ] | [];\r\n\r\n/**\r\n * A utility class to get destinations-to or sources-from a tile at\r\n * a specified coordinate. It is recommended to name the calling\r\n * variable \"tile\". A query starts with calling one of the methods\r\n * `at`, `destsFrom`, or `sourcesTo`. Optional filtering mutators\r\n * can be applied intermediately such as `unoccupied`. The query\r\n * ends with one of the getters `occupants` or `get`.\r\n *\r\n * @template S\r\n *\r\n * @template A\r\n * This allows `Source` implementations to accept a coordinate\r\n * specifier as an argument, such as is appropriate with a grid,\r\n * or to provide that information implicitly inside itself as\r\n * part of its spec, as is appropriate with a player.\r\n *\r\n */\r\nexport class TileGetter<S extends CoordSys, A extends Arguments<S>> {\r\n\r\n    public constructor(protected readonly source: TileGetter.Source<S,A>) { }\r\n\r\n    public at(...args: A): Tile<S> {\r\n        return this.source.__getTileAt(...args);\r\n    }\r\n    public destsFrom(...args: A): Query<S> {\r\n        return new Query(this.source.__getTileDestsFrom(...args));\r\n    }\r\n    public sourcesTo(...args: A): Query<S> {\r\n        return new Query(this.source.__getTileSourcesTo(...args));\r\n    }\r\n}\r\n\r\nexport namespace TileGetter {\r\n    /**\r\n     * A Tile should always be a source-to and destination-from itself.\r\n     */\r\n    export interface Source<S extends CoordSys, A extends Arguments<S> = [Coord.Bare<S>]> {\r\n        __getTileAt(...args: A): Tile<S>;\r\n        // NOTE: do we need to add an optional argument for range?\r\n        // If so, document that it must default to `1` if unspecified.\r\n        __getTileDestsFrom(...args: A): Array<Tile<S>>;\r\n        __getTileSourcesTo(...args: A): Array<Tile<S>>;\r\n    }\r\n}\r\nObject.freeze(TileGetter);\r\nObject.freeze(TileGetter.prototype);\r\n\r\n/**\r\n *\r\n */\r\nclass Query<S extends CoordSys> {\r\n\r\n    public constructor(protected contents: Array<Tile<S>>) { }\r\n\r\n    public get occupied(): Omit<Query<S>, \"unoccupied\"> {\r\n        this.contents = this.contents.filter((tile) => tile.isOccupied);\r\n        return this;\r\n    }\r\n\r\n    public get unoccupied(): Omit<Query<S>, \"occupied\"> {\r\n        this.contents = this.contents.filter((tile) => !tile.isOccupied);\r\n        return this;\r\n    }\r\n\r\n    public get get(): Array<Tile<S>> {\r\n        const retval = this.contents;\r\n        return retval;\r\n    }\r\n}\r\nObject.freeze(Query);\r\nObject.freeze(Query.prototype);\r\n","import { Player as __Player } from \"utils/TypeDefs\";\r\nimport { Game } from \"game/Game\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\nimport type { GameBase } from \"game/__gameparts/Base\";\r\n\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\nimport { TileGetter } from \"floor/TileGetter\";\r\n\r\n\r\n/**\r\n * Made to abstract all operations that change the {@link Player#hostTile}\r\n * field. Enforces / exposes the {@link PlayerSkeleton#moveTo} method as\r\n * the interface to any such operations.\r\n *\r\n * @extends __Player to intake its namespace exports.\r\n */\r\nexport abstract class PlayerSkeleton<S extends Coord.System> extends __Player<S> {\r\n\r\n    public readonly playerId: Player.Id;\r\n\r\n    /**\r\n     * The game object that this player belongs to.\r\n     */\r\n    public readonly game: GameBase<any,S>;\r\n\r\n    public readonly status: PlayerStatus<S>;\r\n\r\n    #hostTile: Tile<S>;\r\n\r\n    public readonly tile: TileGetter<S,[]>;\r\n\r\n\r\n\r\n    protected constructor(game: GameBase<any,S>, desc: Player.CtorArgs) {\r\n        super();\r\n        if (Math.trunc(desc.playerId) !== desc.playerId) {\r\n            throw new RangeError(\"Player ID's must be integer values.\");\r\n        }\r\n        this.playerId = desc.playerId;\r\n        this.game = game;\r\n        this.status = new (this.game.__playerStatusCtor)(\r\n            this as PlayerSkeleton<S> as Player<S>,\r\n            desc.noCheckGameOver,\r\n        );\r\n        this.tile = new TileGetter(new PlayerSkeleton.TileGetterSource(this));\r\n    }\r\n\r\n    /**\r\n     * Must be called _after_ the {@link Grid} has been reset.\r\n     * Does not evict itself from its current host tile (if it\r\n     * has one).\r\n     *\r\n     * @param spawnTile -\r\n     */\r\n    protected reset(spawnTile: Tile<S>): void {\r\n        this.#hostTile = spawnTile;\r\n        this.hostTile.__setOccupant(\r\n            this.playerId,\r\n            this.status.immigrantInfo,\r\n        );\r\n    }\r\n\r\n\r\n\r\n    public get coord(): Coord<S> {\r\n        return this.hostTile.coord;\r\n    }\r\n\r\n    public get hostTile(): Tile<S> {\r\n        return this.#hostTile;\r\n    }\r\n\r\n    // TODO.design Abstract hook called when go near other player.\r\n    // what qualifies \"near\"? Need to call this in moveTo.\r\n    protected onGoBesideOtherPlayer(): void {\r\n        // Does nothing by default.\r\n    }\r\n\r\n    /**\r\n     * Evicts this `Player` from its last known position (which may be\r\n     * lagging behind the state of the master copy of the game.\r\n     *\r\n     * This must be called after all same-event changes pertaining to\r\n     * this player's fields have been enacted.\r\n     *\r\n     * @param dest -\r\n     */\r\n    public moveTo(dest: Tile<S>): void {\r\n        // Evict self from current `Tile`.\r\n        if (this.hostTile.occupantId !== this.playerId) {\r\n            if (this.game.gameType !== Game.Type.ONLINE) {\r\n                // Should never happen.\r\n                throw new Error(\"Linkage between player and occupied tile disagrees.\");\r\n            }\r\n            /* Otherwise, this corner case is guaranteed to follow the events\r\n            described in the below comment: at this `OnlineGame`, `p2` will\r\n            move off of the `Tile` currently occupied by this `Player`. */\r\n        }\r\n        else {\r\n            // Move off of current host `Tile`:\r\n            this.hostTile.evictOccupant();\r\n        }\r\n        // Occupy the destination `Tile.\r\n        if (dest.isOccupied) {\r\n            if (this.game.gameType !== Game.Type.ONLINE) {\r\n                // Should never happen because the Game Manager\r\n                // rejects requests to move onto an occupied `Tile`.\r\n                throw new Error(\"Only one player can occupy a tile at a time.\");\r\n            }\r\n            /* Otherwise, this is actually possible in a variant of the _DAS_\r\n            where another `Player` `p2` moves to `B`, I receive that update,\r\n            then `p2` makes a request to move to `C`, which the Game Manager\r\n            accepts and begins to notify my `OnlineGame` of, but between the\r\n            time that the GM accepts the request and when I receive the update,\r\n            I make a request to move to `B`, which gets accepted by the GM,\r\n            and because I might not be using websockets as my underlying\r\n            transport, I receive the update for my own request first, which\r\n            would appear to my `OnlineGame` as if I was moving onto the `Tile`\r\n            occupied by `p2`. */\r\n        }\r\n        else {\r\n            // Move to occupy the destination `Tile`:\r\n            this.#hostTile = dest;\r\n            dest.__setOccupant(this.playerId, this.status.immigrantInfo);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport namespace PlayerSkeleton {\r\n\r\n    export class TileGetterSource<S extends Coord.System> implements TileGetter.Source<S,[]> {\r\n\r\n        public constructor(private readonly player: PlayerSkeleton<S>) { }\r\n\r\n        public __getTileAt(): Tile<S> {\r\n            return this.player.game.grid.tile.at(this.player.coord);\r\n        }\r\n\r\n        public __getTileDestsFrom(): Array<Tile<S>> {\r\n            return this.player.game.grid.tile.destsFrom(this.player.coord).get;\r\n        }\r\n\r\n        public __getTileSourcesTo(): Array<Tile<S>> {\r\n            return this.player.game.grid.tile.sourcesTo(this.player.coord).get;\r\n        }\r\n    }\r\n    Object.freeze(TileGetterSource);\r\n    Object.freeze(TileGetterSource.prototype);\r\n\r\n}\r\nObject.freeze(PlayerSkeleton);\r\nObject.freeze(PlayerSkeleton.prototype);\r\n","import type { Coord } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport class Team<S extends Coord.System> {\r\n\r\n    public readonly id: Team.Id;\r\n\r\n    public readonly members: TU.RoArr<Player<S>>;\r\n\r\n    #elimOrder: number;\r\n\r\n    public constructor(teamId: Team.Id, members: TU.RoArr<Player<S>>) {\r\n        if (members.length === 0) {\r\n            throw new Error(\"teams must have at least one member.\");\r\n        }\r\n        this.id = teamId;\r\n        this.members = members;\r\n        this.#elimOrder\r\n            = (this.members.every((member) => member.status.noCheckGameOver))\r\n            ? Team.ElimOrder.IMMORTAL\r\n            : Team.ElimOrder.STANDING;\r\n    }\r\n\r\n    public reset(): void {\r\n        if (this.elimOrder !== Team.ElimOrder.IMMORTAL) {\r\n            this.elimOrder = Team.ElimOrder.STANDING;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns\r\n     * Indicates the order (relative to other teams) in which this\r\n     * team was to have all its members downed at the same time at\r\n     * least once. Once a team is soft-eliminated, they can continue\r\n     * playing as normal, but there is no going back. The game ends\r\n     * when all teams but one have been soft-eliminated.\r\n     *\r\n     * ### Semantics\r\n     *\r\n     * A comparatively smaller value denotes having been soft-\r\n     * eliminated at an earlier point in the game. **The value zero\r\n     * denotes _not-having-been-soft-eliminated-yet_**.\r\n     */\r\n    public get elimOrder(): number {\r\n        return this.#elimOrder;\r\n    }\r\n    public set elimOrder(teamElimOrder: number) {\r\n        if (this.elimOrder === Team.ElimOrder.IMMORTAL) {\r\n            throw new Error(\"Cannot change the elimination status of an immortal team.\");\r\n        }\r\n        this.#elimOrder = teamElimOrder;\r\n    }\r\n\r\n}\r\nexport namespace Team {\r\n\r\n    export type Id = number;\r\n\r\n    export type ElimOrder = number;\r\n\r\n    // Special values:\r\n    export namespace ElimOrder {\r\n        /**\r\n         * A team starts off with such a value if all its players have\r\n         * specified that their downing should not cause a check for\r\n         * whether the game should end.\r\n         */\r\n        export const IMMORTAL = -1;\r\n\r\n        /**\r\n         * A team that is not invincible starts off with such a value.\r\n         */\r\n        export const STANDING = 0;\r\n    }\r\n\r\n}\r\nObject.freeze(Team);\r\nObject.freeze(Team.prototype);\r\n","import type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\nimport { Team } from \"game/player/Team\";\r\n\r\n\r\n/**\r\n * This abstracts acts of modification upon a player's state, allowing\r\n * extension classes to override setters to perform additional tasks\r\n * such as visually rendering updates to this state information in a\r\n * web browser, and playing sound effects.\r\n */\r\nexport class PlayerStatus<S extends Coord.System> {\r\n\r\n    protected readonly player: Readonly<Player<S>>; // Circular field reference.\r\n    public readonly noCheckGameOver: boolean;\r\n    #score:  Player.Health;\r\n    #health: Player.Health;\r\n\r\n    public constructor(player: Readonly<Player<S>>, noCheckGameOver: boolean) {\r\n        this.player = player;\r\n        this.noCheckGameOver = noCheckGameOver;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.score   = 0;\r\n        this.health  = 0;\r\n    }\r\n\r\n    public __afterAllPlayersConstruction(): void { }\r\n\r\n    public get immigrantInfo(): Tile.VisibleImmigrantInfo | undefined {\r\n        return undefined;\r\n    }\r\n\r\n\r\n    public get score(): Player.Health {\r\n        return this.#score;\r\n    }\r\n    public set score(newValue: Player.Health) {\r\n        this.#score = newValue;\r\n    }\r\n\r\n    public get health(): Player.Health {\r\n        return this.#health;\r\n    }\r\n    public set health(newHealth: Player.Health) {\r\n        const oldIsDowned = this.isDowned;\r\n        this.#health = newHealth;\r\n\r\n        if (oldIsDowned) return;\r\n        const team  = this.player.team;\r\n        const teams = this.player.game.teams;\r\n        if (this.isDowned && !(this.noCheckGameOver) && team.elimOrder === 0) {\r\n            // Right before this downing event, the team has not been\r\n            // soft-eliminated yet, but it might be now. Check it:\r\n            if (team.members.every((player) => {\r\n                return player.status.noCheckGameOver || player.status.isDowned;\r\n            })) {\r\n                // All players are downed! The team is now eliminated:\r\n                const numNonStandingTeams\r\n                    = 1 + teams.filter((team) => {\r\n                    return team.elimOrder !== Team.ElimOrder.STANDING;\r\n                }).length;\r\n                team.elimOrder\r\n                    = 1 + teams.filter((team) => {\r\n                    return team.elimOrder !== Team.ElimOrder.STANDING\r\n                        && team.elimOrder !== Team.ElimOrder.IMMORTAL;\r\n                }).length;\r\n                // Now that a team is newly-eliminated, check if the\r\n                // game should end:\r\n                if (numNonStandingTeams === teams.length) {\r\n                    this.player.game.statusBecomeOver();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // TODO.design Equation and architecture for getting/setting adjusted health.\r\n    // This should be a getter here. Easy now that I added the circular reference to the Player.\r\n\r\n    public get isDowned(): boolean {\r\n        return this.health < 0.0;\r\n    }\r\n}\r\nObject.freeze(PlayerStatus);\r\nObject.freeze(PlayerStatus.prototype);\r\n","import { Game } from \"game/Game\";\r\n\r\nimport type { Lang } from \"lang/Lang\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player as __Player } from \"utils/TypeDefs\";\r\nimport type { GameBase } from \"game/__gameparts/Base\";\r\n\r\nimport { PlayerActionEvent } from \"game/events/PlayerActionEvent\";\r\nimport { PlayerSkeleton } from \"./PlayerSkeleton\";\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\nimport { Team } from \"./Team\";\r\n\r\nexport { PlayerSkeleton };\r\nexport { PlayerStatus };\r\nexport { Team };\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport class Player<S extends Coord.System> extends PlayerSkeleton<S> {\r\n\r\n    public readonly familyId: Player.Family;\r\n\r\n    public readonly teamId: Team.Id;\r\n\r\n    public readonly username: Player.Username;\r\n\r\n    public lastAcceptedRequestId: number;\r\n\r\n    public requestInFlight: boolean;\r\n\r\n\r\n    public constructor(game: GameBase<any,S>, desc: Readonly<Player.CtorArgs>) {\r\n        super(game, desc);\r\n\r\n        if (!(Player.Username.REGEXP.test(desc.username))) {\r\n            throw new RangeError(`Username \\\"${desc.username}\\\"`\r\n            + ` does not match the required regular expression,`\r\n            + ` \\\"${Player.Username.REGEXP.source}\\\".`\r\n            );\r\n        }\r\n        this.familyId = desc.familyId;\r\n        this.teamId   = desc.teamId;\r\n        this.username = desc.username;\r\n    }\r\n\r\n    public reset(spawnTile: Tile<S>): void {\r\n        super.reset(spawnTile);\r\n        this.status.reset();\r\n        this.lastAcceptedRequestId = PlayerActionEvent.INITIAL_REQUEST_ID;\r\n        this.requestInFlight = false;\r\n    }\r\n\r\n    public __abstractNotifyThatGameStatusBecamePlaying(): void {}\r\n    public __abstractNotifyThatGameStatusBecamePaused():  void {}\r\n    public __abstractNotifyThatGameStatusBecameOver():    void {}\r\n\r\n\r\n    /**\r\n     * Called automatically by {@link OperatorPlayer#seqBufferAcceptKey}\r\n     * for {@link OperatorPlayer}s, and by a periodic callback for\r\n     * {@link ArtificialPlayer}s. Handles behaviour common between all\r\n     * implementations.\r\n     *\r\n     * @final\r\n     * @param dest -\r\n     * @throws Error if the game is over or paused.\r\n     */\r\n    protected makeMovementRequest(dest:Tile<S>): void {\r\n        if (this.game.status !== Game.Status.PLAYING) {\r\n            throw new Error(\"This is not a necessary precondition, but we're doing it anyway.\");\r\n        } else if (this.requestInFlight) {\r\n            throw new Error(\"Only one request should ever be in flight at a time.\");\r\n        }\r\n        this.requestInFlight = true;\r\n        this.game.processMoveRequest(\r\n            new PlayerActionEvent.Movement(\r\n                this.playerId,\r\n                this.lastAcceptedRequestId,\r\n                dest,\r\n            ),\r\n        );\r\n    }\r\n\r\n    public get team(): Team<S> {\r\n        return this.game.teams[this.teamId];\r\n    }\r\n\r\n    public isTeamedWith(other: Player<S>): boolean {\r\n        return this.team.members.includes(other);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport namespace Player {\r\n\r\n    export type Family = __Player.Family;\r\n\r\n    export type Id = __Player.Id;\r\n\r\n    export type SocketId = string;\r\n\r\n    /**\r\n     * Health be picked up from the floor where it is randomly spawned\r\n     * by the game manager. It can be used to attack enemy players, or\r\n     * to heal teammates.\r\n     */\r\n    export type Health = __Player.Health;\r\n\r\n    export type Username = string;\r\n\r\n    export namespace Username {\r\n        /**\r\n         * The choice of this is somewhat arbitrary. This should be enforced\r\n         * externally since player descriptors are passed to the constructor.\r\n         *\r\n         * Requirements:\r\n         * - Starts with a letter.\r\n         * - No whitespace except for non-consecutive space characters.\r\n         * - Must contain at least five non-space characters that are\r\n         *      either letters, numbers, or the dash character.\r\n         */\r\n        export const REGEXP = /[a-zA-Z](?:[ ]?[a-zA-Z0-9:-]+?){4,}/;\r\n    }\r\n\r\n    /**\r\n     * # Player Constructor Arguments\r\n     */\r\n    export type CtorArgs = CtorArgs.PreIdAssignment & Readonly<{\r\n        playerId: Player.Id;\r\n        langName: Lang.Names.Value[\"id\"],\r\n    }>;\r\n\r\n    export namespace CtorArgs {\r\n\r\n        export type PreIdAssignment = Readonly<{\r\n            /**\r\n             * This determines which constructor function to use.\r\n             */\r\n            familyId: Player.Family;\r\n            teamId:   Team.Id;\r\n            socketId: SocketId | undefined; // Must exist for operated players.\r\n            username: Username;\r\n            noCheckGameOver: boolean;\r\n        }>;\r\n\r\n        /**\r\n         * @returns\r\n         * Squashes teamId fields to be suitable for array indices.\r\n         *\r\n         * @param playerDescs -\r\n         * @param langName -\r\n         */\r\n        export const finalize = (\r\n            playerDescs: TU.RoArr<CtorArgs.PreIdAssignment>,\r\n            langName: Lang.Names.Value[\"id\"],\r\n        ): TU.RoArr<CtorArgs> => {\r\n            // Map team ID's to consecutive numbers\r\n            // (to play nice with array representations):\r\n            const teamIdCleaner: TU.RoArr<Team.Id>\r\n                = Array.from(new Set(playerDescs.map((player) => player.teamId)))\r\n                .sort((a, b) => a - b)\r\n                .reduce((prev, originalId, squashedId) => {\r\n                    prev[originalId] = squashedId;\r\n                    return prev;\r\n                }, [] as Array<Team.Id>);\r\n            return (playerDescs as Array<CtorArgs.PreIdAssignment>)\r\n            .sort((pda, pdb) => teamIdCleaner[pda.teamId] - teamIdCleaner[pdb.teamId])\r\n            .map<CtorArgs>((playerDesc, index) => { return {\r\n                playerId:   index,\r\n                familyId:   playerDesc.familyId,\r\n                teamId:     teamIdCleaner[playerDesc.teamId],\r\n                socketId:   playerDesc.socketId,\r\n                username:   playerDesc.username,\r\n                langName:   langName,\r\n                noCheckGameOver: playerDesc.noCheckGameOver,\r\n            }; });\r\n        };\r\n\r\n    }\r\n    Object.freeze(CtorArgs);\r\n\r\n}\r\nObject.freeze(Player);\r\nObject.freeze(Player.prototype);\r\n","import { Lang } from \"lang/Lang\";\r\nimport { Game } from \"game/Game\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { VisibleTile } from \"floor/VisibleTile\";\r\nimport type { VisiblePlayerStatus } from \"./VisiblePlayerStatus\";\r\nimport type { GameBase } from \"game/__gameparts/Base\";\r\n\r\nimport { Player } from \"./Player\";\r\n\r\n\r\n/**\r\n *\r\n * @extends Player\r\n */\r\nexport class OperatorPlayer<S extends Coord.System> extends Player<S> {\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    declare public readonly game: GameBase<(Game.Type.OFFLINE|Game.Type.ONLINE),S>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    declare public readonly hostTile: VisibleTile<S>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    declare public readonly status: VisiblePlayerStatus<S>;\r\n\r\n    /**\r\n     * Invariant: always matches the prefix of the {@link LangSeq} of\r\n     * an unoccupied neighbouring {@link Tile}.\r\n     */\r\n    #seqBuffer: Lang.Seq;\r\n\r\n    private readonly langRemappingFunc: {(input: string): string};\r\n\r\n    private prevCoord: Coord<S>;\r\n\r\n\r\n    public constructor(game: GameBase<any,S>, desc: Readonly<Player.CtorArgs>) {\r\n        super(game, desc);\r\n        this.langRemappingFunc = Lang.RemappingFunctions[desc.langName];\r\n    }\r\n\r\n    /**\r\n     * @override {@link Player#reset}\r\n     */\r\n    public reset(spawnTile: Tile<S>): void {\r\n        super.reset(spawnTile);\r\n        this.prevCoord = spawnTile.coord;\r\n        this.#seqBuffer = \"\";\r\n    }\r\n\r\n\r\n    /**\r\n     * Callback function invoked when the Operator presses a key while\r\n     * the game's html element has focus. Because of how JavaScript\r\n     * and also Node.js run in a single thread, this is an atomic\r\n     * operation (implementation must not intermediately schedule any\r\n     * other task-relevant callbacks until all critical operations are\r\n     * complete).\r\n     *\r\n     * @param event - The object describing the `KeyboardEvent`.\r\n     */\r\n    public processKeyboardInput(event: KeyboardEvent): void {\r\n        if (false) {\r\n            return;\r\n        // @ Above: Conditional handlers for actions that are valid\r\n        // even when the game is over or paused.\r\n        // ==========================================================\r\n        } else if (this.game.status !== Game.Status.PLAYING) return;\r\n        if (!this.requestInFlight) {\r\n            // Only process movement-type input if the last request got\r\n            // acknowledged by the Game Manager and the game is playing.\r\n            if (event.keyCode === 32) {\r\n                // TODO.design: this should cost health... add an argument to\r\n                // makeMovementRequest? An enum saying how the movement should\r\n                // be \"charged\" / its \"cost-type\" in health? The cost should\r\n                // be proportional to `GameManager.averageFreeHealthPerTile`.\r\n                // TODO.learn why isn't TypeScript able to figure the below line out?\r\n                if (!this.coord.equals(this.prevCoord as any)) {\r\n                    this.makeMovementRequest(this.game.grid.getUntAwayFrom(\r\n                        this.coord, this.prevCoord,\r\n                    ));\r\n                }\r\n            } else if (event.key.length === 1) {\r\n                // TODO.design is the above condition okay? will any\r\n                // languages require different behaviour?\r\n                this.seqBufferAcceptKey(event.key);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Automatically makes a call to make a movement request if the\r\n     * provided `key` completes the `LangSeq` of a UNT. Does not do\r\n     * any checking regarding {@link OperatorPlayer#requestInFlight}.\r\n     *\r\n     * @param key\r\n     * The pressed typeable key as a string. Pass an empty string to\r\n     * trigger a refresh of the {@link OperatorPlayer#_seqBuffer} to\r\n     * maintain its invariant.\r\n     */\r\n    public seqBufferAcceptKey(key: string | undefined): void {\r\n        const unts = this.tile.destsFrom().unoccupied.get;\r\n        if (unts.length === 0) {\r\n            // Every neighbouring `Tile` is occupied!\r\n            // In this case, no movement is possible.\r\n            return;\r\n        }\r\n        if (key) {\r\n            key = this.langRemappingFunc(key);\r\n            if (!(Lang.Seq.REGEXP.test(key))) {\r\n                // throw new RangeError(`The implementation of input transformation`\r\n                // + ` in the currently selected language did not follow the rule`\r\n                // + ` of producing output matching the regular expression`\r\n                // + ` \\\"${Lang.Seq.REGEXP.source}\\\".`\r\n                // );\r\n                return;\r\n            }\r\n        } else {\r\n            const possibleTarget = unts.find((tile) => tile.langSeq.startsWith(this.seqBuffer));\r\n            if (!possibleTarget) {\r\n                // If the thing I was trying to get to is gone, clear the buffer.\r\n                this.#seqBuffer = \"\";\r\n            }\r\n            return;\r\n        }\r\n\r\n        for ( // loop through substring start offset of newSeqBuffer:\r\n            let newSeqBuffer: Lang.Seq = this.seqBuffer + key;\r\n            newSeqBuffer.length;\r\n            newSeqBuffer = newSeqBuffer.substring(1)\r\n        ) {\r\n            // look for the longest suffixing substring of `newSeqBuffer`\r\n            // that is a prefixing substring of any UNT's.\r\n            const possibleTarget = unts.find((tile) => tile.langSeq.startsWith(newSeqBuffer));\r\n            if (possibleTarget) {\r\n                this.#seqBuffer = newSeqBuffer;\r\n                if (possibleTarget.langSeq === newSeqBuffer) {\r\n                    this.makeMovementRequest(possibleTarget);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        // Operator's new `seqBuffer` didn't match anything.\r\n        this.#seqBuffer = \"\";\r\n        this.hostTile.visualBell();\r\n    }\r\n\r\n    /**\r\n     * Automatically clears the {@link OperatorPlayer#seqBuffer}.\r\n     *\r\n     * @override\r\n     */\r\n    public moveTo(dest: Tile<S>): void {\r\n        // Clear my `seqBuffer` first:\r\n        this.#seqBuffer = \"\";\r\n        this.prevCoord = this.coord;\r\n        super.moveTo(dest);\r\n    }\r\n\r\n\r\n    public get seqBuffer(): Lang.Seq {\r\n        return this.#seqBuffer;\r\n    }\r\n\r\n}\r\nObject.freeze(OperatorPlayer);\r\nObject.freeze(OperatorPlayer.prototype);\r\n","import { Game } from \"game/Game\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { GameManager } from \"game/__gameparts/Manager\";\r\n\r\nimport { Player } from \"./Player\";\r\n\r\n\r\n/**\r\n * Unlike {@link HumanPlayer}s, these are not guided by human input.\r\n * Instead, they are essentially defined by how often they move, and\r\n * where they decide to move toward each time they move.\r\n *\r\n * Can be paused and un-paused by the Game Manager.\r\n *\r\n * @extends Player\r\n */\r\nexport abstract class ArtificialPlayer<S extends Coord.System> extends Player<S> {\r\n\r\n    declare public readonly game: GameManager<any,S>;\r\n\r\n    private scheduledMovementCallbackId: number | NodeJS.Timeout;\r\n\r\n    /**\r\n     * See {@link ArtificialPlayer.of} for the public constructor\r\n     * interface.\r\n     *\r\n     * @param game -\r\n     * @param desc -\r\n     */\r\n    protected constructor(game: GameManager<any,S>, desc: Player.CtorArgs) {\r\n        super(game, desc);\r\n        if (game.gameType === Game.Type.ONLINE) {\r\n            throw new TypeError(\"OnlineGames should be using regular Players instead.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a {@link Pos} representing an absolute coordinate (ie.\r\n     * one that is relative to the {@link Game}'s origin position')\r\n     * that this `ArtificialPlayer` intends to move toward in its next\r\n     * movement request. Pos may contain non-integer coordinate values,\r\n     * and it does not have to be inside the bounds of the {@link Grid}.\r\n     */\r\n    protected abstract computeDesiredDestination(): Coord<S>;\r\n\r\n    /**\r\n     * Units are in milliseconds.\r\n     */\r\n    protected abstract computeNextMovementTimer(): number;\r\n\r\n    public __abstractNotifyThatGameStatusBecamePlaying(): void {\r\n        this.movementContinueWithInitialDelay();\r\n    }\r\n    public __abstractNotifyThatGameStatusBecamePaused(): void {\r\n        this.game.cancelTimeout(this.scheduledMovementCallbackId);\r\n        this.scheduledMovementCallbackId = undefined!;\r\n    }\r\n    public __abstractNotifyThatGameStatusBecameOver(): void {\r\n        this.game.cancelTimeout(this.scheduledMovementCallbackId);\r\n        this.scheduledMovementCallbackId = undefined!;\r\n    }\r\n\r\n    private movementContinue(): void {\r\n        this.makeMovementRequest(this.game.grid.getUntToward(\r\n            this.coord, this.computeDesiredDestination()\r\n        ));\r\n        this.movementContinueWithInitialDelay();\r\n    }\r\n\r\n    private movementContinueWithInitialDelay(): void {\r\n        // Schedule the next movement.\r\n        this.scheduledMovementCallbackId = this.game.setTimeout(\r\n            this.movementContinue,\r\n            this.computeNextMovementTimer(),\r\n            // * Callback function arguments go here.\r\n        );\r\n        return;\r\n    }\r\n}\r\n\r\n\r\nexport namespace ArtificialPlayer {\r\n\r\n    export declare const __Constructors: Readonly<Record<\r\n        Exclude<Player.Family, typeof Player.Family.HUMAN>,\r\n        typeof ArtificialPlayer\r\n    >>;\r\n\r\n    export const of = <S extends Coord.System>(\r\n        game: Readonly<GameManager<any,S>>,\r\n        playerDesc: Readonly<Player.CtorArgs>,\r\n    ): ArtificialPlayer<S> => {\r\n        return new (__Constructors[playerDesc.familyId])(game, playerDesc);\r\n    };\r\n}\r\n// ArtificialPlayer gets frozen in PostInit after __Constructors get initialized.\r\n","import { Lang } from \"lang/Lang\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport namespace English {\r\n\r\n    /**\r\n     * # Lowercase (QWERTY)\r\n     *\r\n     * https://wikipedia.org/wiki/Keyboard_layout#QWERTY\r\n     */\r\n    export class Lowercase extends Lang {\r\n\r\n        private static SINGLETON?: Lowercase = undefined;\r\n\r\n        public static getName(): Lang.Names.Value {\r\n            return Lang.Names.ENGLISH__LOWERCASE;\r\n        }\r\n\r\n        public static getBlurb(): string {\r\n            return \"\"; // TODO.doc\r\n        }\r\n\r\n        public static getInstance(): Lowercase {\r\n            if (!this.SINGLETON) {\r\n                this.SINGLETON  = new Lowercase();\r\n            }\r\n            return this.SINGLETON;\r\n        }\r\n\r\n        // TODO.learn see https://wikipedia.org/wiki/Keyboard_layout#Dvorak\r\n        // and https://wikipedia.org/wiki/Keyboard_layout#Colemak\r\n\r\n        private constructor() { super(\r\n            Lowercase,\r\n            Object.entries(LETTER_FREQUENCY).reduce<Lang.CharSeqPair.WeightedForwardMap>(\r\n                (accumulator, current) => {\r\n                    const char: Lang.Char = current[0];\r\n                    const seq:  Lang.Seq  = current[0];\r\n                    const weight: number  = current[1];\r\n                    accumulator[char] = { seq, weight, };\r\n                    return accumulator;\r\n                },\r\n                {},\r\n            ),\r\n        ); }\r\n    }\r\n    Lowercase as Lang.ClassIf;\r\n    Object.seal(Lowercase);\r\n    Object.freeze(Lowercase.prototype);\r\n\r\n\r\n    /**\r\n     * # Mixed-Case (QWERTY)\r\n     *\r\n     * https://wikipedia.org/wiki/Keyboard_layout#QWERTY\r\n     */\r\n    export class MixedCase extends Lang {\r\n\r\n        private static SINGLETON?: MixedCase = undefined;\r\n\r\n        public static getName(): Lang.Names.Value {\r\n            return Lang.Names.ENGLISH__MIXEDCASE;\r\n        }\r\n\r\n        public static getBlurb(): string {\r\n            return \"\"; // TODO.doc\r\n        }\r\n\r\n        public static getInstance(): MixedCase {\r\n            if (!this.SINGLETON) {\r\n                this.SINGLETON  = new MixedCase();\r\n            }\r\n            return this.SINGLETON;\r\n        }\r\n\r\n        private constructor() {\r\n            let initializer: Lang.CharSeqPair.WeightedForwardMap = {};\r\n            const addMappings = (charSeqTransform: (charOrSeq: string) => string): void => {\r\n                initializer = Object.entries(LETTER_FREQUENCY).reduce(\r\n                    (accumulator, current) => {\r\n                        const char: Lang.Char = charSeqTransform(current[0]);\r\n                        const seq:  Lang.Seq  = charSeqTransform(current[0]);\r\n                        const weight: number  = current[1];\r\n                        accumulator[char] = { seq, weight, };\r\n                        return accumulator;\r\n                    },\r\n                    initializer,\r\n                );\r\n            };\r\n            addMappings((cs) => cs.toLowerCase());\r\n            addMappings((cs) => cs.toUpperCase());\r\n            super(\r\n                MixedCase,\r\n                initializer,\r\n            );\r\n        }\r\n    }\r\n    MixedCase as Lang.ClassIf;\r\n    Object.seal(MixedCase);\r\n    Object.freeze(MixedCase.prototype);\r\n\r\n\r\n    /**\r\n     * Values obtained from https://wikipedia.org/wiki/Letter_frequency\r\n     */\r\n    const LETTER_FREQUENCY = Object.freeze(<const>{\r\n        a: 8.167, b: 1.492, c: 2.202, d: 4.253,\r\n        e:12.702, f: 2.228, g: 2.015, h: 6.094,\r\n        i: 6.966, j: 0.153, k: 1.292, l: 4.025,\r\n        m: 2.406, n: 6.749, o: 7.507, p: 1.929,\r\n        q: 0.095, r: 5.987, s: 6.327, t: 9.356,\r\n        u: 2.758, v: 0.978, w: 2.560, x: 0.150,\r\n        y: 1.994, z: 0.077,\r\n    });\r\n\r\n}\r\nObject.seal(English);\r\n","import { OmHooks } from \"browser/OmHooks\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\n\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\n\r\n\r\nexport class VisiblePlayerStatus<S extends Coord.System> extends PlayerStatus<S> {\r\n\r\n    readonly #baseElem: HTMLElement;\r\n\r\n    private readonly __immigrantInfoCache: Tile.VisibleImmigrantInfo;\r\n\r\n\r\n    public constructor(player: Player<S>, noCheckGameOver: boolean) {\r\n        super(player, noCheckGameOver);\r\n        {\r\n            const baseElem = document.createElement(\"div\");\r\n            baseElem.classList.add(OmHooks.Player.Class.BASE);\r\n            this.#baseElem = baseElem;\r\n        } {\r\n            // Setup downedOverlay element:\r\n            const dOverlayElem = document.createElement(\"div\");\r\n            dOverlayElem.classList.add(OmHooks.Player.Class.DOWNED_OVERLAY);\r\n            this.#baseElem.appendChild(dOverlayElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public __afterAllPlayersConstruction(): void {\r\n        const player = this.player;\r\n        const operator = this.player.game.operator!;\r\n        if (!operator) {\r\n            // This _would_ be the case if we did it in the constructor\r\n            // where `this.player.game.operator` has not been defined yet.\r\n            throw new Error(\"this never happens. see comment in source.\");\r\n        }\r\n        this.#baseElem.dataset[OmHooks.Player.Dataset.FACE_SWATCH]\r\n        = (player === operator) ? \"me\"\r\n        : (player.teamId === operator.teamId) ? \"teammate\" : \"opponent\";\r\n\r\n        // Setup spotlight element:\r\n        if (player === operator) {\r\n            const spotlightElem = document.createElement(\"div\");\r\n            spotlightElem.classList.add(OmHooks.Player.Class.SPOTLIGHT);\r\n            this.#baseElem.appendChild(spotlightElem);\r\n        }\r\n        (this.__immigrantInfoCache as Tile.VisibleImmigrantInfo) = Object.freeze({\r\n            playerElem: this.#baseElem,\r\n            username: player.username,\r\n        });\r\n    }\r\n\r\n    public get immigrantInfo(): Tile.VisibleImmigrantInfo {\r\n        return this.__immigrantInfoCache;\r\n    }\r\n\r\n\r\n    public set score(newValue: Player.Health) {\r\n        super.score = newValue;\r\n    }\r\n\r\n    public set health(newHealth: Player.Health) {\r\n        const oldIsDowned = this.isDowned;\r\n        super.health = newHealth;\r\n\r\n        if (oldIsDowned !== this.isDowned) {\r\n            // CSS integration for Player.isDowned rendering.\r\n            const dataDowned = OmHooks.Player.Dataset.DOWNED;\r\n            if (this.isDowned) {\r\n                if (this.player.team.elimOrder) {\r\n                    this.#baseElem.dataset[dataDowned] = \"team\";\r\n                } else {\r\n                    this.#baseElem.dataset[dataDowned] = \"self\";\r\n                }\r\n            } else {this.#baseElem.dataset[dataDowned] = \"no\"; }\r\n        }\r\n    }\r\n}\r\nObject.freeze(VisiblePlayerStatus);\r\nObject.freeze(VisiblePlayerStatus.prototype);\r\n","import { Game } from \"../Game\";\r\nimport type { Lang } from 'utils/TypeDefs';\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Grid } from \"floor/Grid\";\r\nimport type { VisibleGrid } from \"floor/VisibleGrid\";\r\n\r\nimport { Player, PlayerStatus, Team } from \"../player/Player\";\r\nimport type { OperatorPlayer } from \"../player/OperatorPlayer\";\r\nimport type { ArtificialPlayer } from \"../player/ArtificialPlayer\";\r\nimport type { PlayerActionEvent } from \"game/events/PlayerActionEvent\";\r\n\r\n\r\n/**\r\n * Foundational parts of a Game that are not related to event handling.\r\n */\r\nexport abstract class GameBase<G extends Game.Type, S extends Coord.System> {\r\n\r\n    public readonly gameType: G;\r\n\r\n    public readonly grid: G extends Game.Type.SERVER ? Grid<S> : VisibleGrid<S>;\r\n\r\n    protected readonly players: TU.RoArr<Player<S>>;\r\n\r\n    public readonly operator: G extends Game.Type.SERVER ? undefined : OperatorPlayer<S>;\r\n\r\n    /**\r\n     * Indexable by team ID's.\r\n     */\r\n    public readonly teams: TU.RoArr<Team<S>>;\r\n\r\n    #status: Game.Status;\r\n\r\n    public readonly __playerStatusCtor: typeof PlayerStatus;\r\n\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * Performs the \"no invincible player\" check (See {@link Player#teamSet}).\r\n     *\r\n     * @param gameType -\r\n     * @param impl -\r\n     * @param desc -\r\n     */\r\n    public constructor(\r\n        gameType: G,\r\n        impl: Game.ImplArgs<S>,\r\n        desc: Game.CtorArgs<G,S>,\r\n    ) {\r\n        this.gameType = gameType;\r\n        const gridClass = this.__getGridImplementation(desc.coordSys);\r\n        this.grid = new (gridClass)({\r\n            gridClass:  gridClass,\r\n            tileClass:  impl.tileClass,\r\n            coordSys:   desc.coordSys,\r\n            dimensions: desc.gridDimensions,\r\n            domParentHtmlIdHook: (desc.gridHtmlIdHook || \"n/a\")!,\r\n        }) as GameBase<G,S>[\"grid\"];\r\n\r\n        // Construct players:\r\n        this.__playerStatusCtor = impl.playerStatusCtor;\r\n        this.players = this.createPlayers(desc);\r\n        if (desc.operatorIndex !== undefined) {\r\n            // Note at above comparison: we must be explicit\r\n            // since zero is a valid, _falsy_ operatorIndex.\r\n            (this.operator as Player<S>) = this.players[desc.operatorIndex!];\r\n        }\r\n        const teams: Array<Array<Player<S>>> = [];\r\n        this.players.forEach((player) => {\r\n            if (!teams[player.teamId]) {\r\n                teams[player.teamId] = [];\r\n            }\r\n            teams[player.teamId].push(player);\r\n        });\r\n        this.teams = teams.map((teammateArray, teamId) => {\r\n            return new Team<S>(teamId, teammateArray);\r\n        });\r\n        if (this.teams.every((team) => team.id === Team.ElimOrder.IMMORTAL)) {\r\n            // TODO.design put a check inside the UI code to prevent this.\r\n            // The purpose of this restriction is to prevent DoS attacks on\r\n            // a hosting server by creating games that can never end and\r\n            // leaving them open forever, thus leaking the server's resources.\r\n            throw new Error(\"All teams are immortal. The game will never end.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the grid.\r\n     */\r\n    public reset(): void {\r\n        this.grid.reset();\r\n        // We must reset status to PAUSED to pass a state-transition\r\n        // assertion when changing status later to PLAYING.\r\n        this.#status = Game.Status.PAUSED;\r\n    }\r\n\r\n    protected abstract __getGridImplementation(coordSys: S):\r\n    G extends Game.Type.SERVER ? Grid.ClassIf<S> : VisibleGrid.ClassIf<S>;\r\n\r\n\r\n    /**\r\n     * Private helper for the constructor to create player objects.\r\n     * This is bypassed in non-game-manager implementations (Ie. In\r\n     * OnlineGame).\r\n     *\r\n     * @param gameDesc -\r\n     * @returns A bundle of the constructed players.\r\n     */\r\n    private createPlayers(gameDesc: Readonly<Game.CtorArgs<G,S>>): GameBase<G,S>[\"players\"] {\r\n        type pCtorArgs = TU.RoArr<Player.CtorArgs>;\r\n        const playerDescs: pCtorArgs\r\n            = (gameDesc.playerDescs as pCtorArgs)\r\n            = (this.gameType === Game.Type.ONLINE)\r\n            // The client receives these descriptors already finalized / cleaned by the server.\r\n            ? gameDesc.playerDescs as pCtorArgs\r\n            : Player.CtorArgs.finalize(gameDesc.playerDescs, gameDesc.languageName);\r\n\r\n        return playerDescs.map((playerDesc, playerIndex) => {\r\n            if (playerDesc.familyId === Player.Family.HUMAN) {\r\n                return (playerIndex === gameDesc.operatorIndex)\r\n                    ? this.__createOperatorPlayer(playerDesc)\r\n                    : new Player(this, playerDesc);\r\n            } else {\r\n                return this.__createArtifPlayer(playerDesc);\r\n            }\r\n        });\r\n    }\r\n    protected abstract __createOperatorPlayer(desc: Player.CtorArgs): OperatorPlayer<S>;\r\n    protected abstract __createArtifPlayer(desc: Player.CtorArgs):\r\n    (G extends Game.Type.Manager ? ArtificialPlayer<S> : Player<S>);\r\n\r\n    public serializeResetState(): Game.ResetSer<S> {\r\n        const csps: Array<Lang.CharSeqPair> = [];\r\n        const playerCoords = this.players.map((player) => player.coord);\r\n        const healthCoords: TU.NoRo<Game.ResetSer<S>[\"healthCoords\"]> = [];\r\n        this.grid.forEachTile((tile) => {\r\n            csps.push({\r\n                char: tile.langChar,\r\n                seq:  tile.langSeq,\r\n            });\r\n            if (tile.freeHealth) {\r\n                healthCoords.push({\r\n                    coord:  tile.coord,\r\n                    health: tile.freeHealth,\r\n                })\r\n            }\r\n        });\r\n        return { csps, playerCoords, healthCoords, };\r\n    }\r\n\r\n    public deserializeResetState(ser: Game.ResetSer<S>): void {\r\n        { let i = 0;\r\n        // Could also use `csps.unshift`, but that may be slower\r\n        // because it modifies csps, which we don't need to do.\r\n        this.grid.forEachTile((tile) => {\r\n            tile.setLangCharSeqPair(ser.csps[i++]);\r\n            tile.lastKnownUpdateId = 1;\r\n        }); }\r\n        ser.playerCoords.forEach((coord, index) => {\r\n            this.players[index].moveTo(this.grid.tile.at(coord));\r\n        });\r\n        ser.healthCoords.forEach((desc) => {\r\n            this.grid.tile.at(desc.coord).freeHealth = desc.health;\r\n        });\r\n    }\r\n\r\n\r\n    public get status(): Game.Status {\r\n        return this.#status;\r\n    }\r\n    public statusBecomePlaying(): void {\r\n        if (this.status !== Game.Status.PAUSED) {\r\n            throw new Error(\"Can only resume a game that is currently paused.\");\r\n        }\r\n        this.players.forEach((player) => {\r\n            player.__abstractNotifyThatGameStatusBecamePlaying();\r\n        });\r\n        this.__abstractStatusBecomePlaying();\r\n        this.#status = Game.Status.PLAYING;\r\n        // Make sure focus goes back to the grid element so that it\r\n        // can pick up user input as keydown events:\r\n        if ((this.grid as VisibleGrid<S>).baseElem) {\r\n            (this.grid as VisibleGrid<S>).baseElem.focus();\r\n        }\r\n    }\r\n    public statusBecomePaused(): void {\r\n        if (this.status !== Game.Status.PLAYING) {\r\n            throw new Error(\"Can only pause a game that is currently playing.\");\r\n        }\r\n        this.players.forEach((player) => {\r\n            player.__abstractNotifyThatGameStatusBecamePaused();\r\n        });\r\n        this.__abstractStatusBecomePaused();\r\n        this.#status = Game.Status.PAUSED;\r\n    }\r\n    public statusBecomeOver(): void {\r\n        if (this.status !== Game.Status.PLAYING) {\r\n            throw new Error(\"Can only end a game that is currently playing.\");\r\n        }\r\n        this.players.forEach((player) => {\r\n            player.__abstractNotifyThatGameStatusBecameOver();\r\n        });\r\n        this.__abstractStatusBecomeOver();\r\n        this.#status = Game.Status.OVER;\r\n    }\r\n    protected __abstractStatusBecomePlaying(): void {}\r\n    protected __abstractStatusBecomePaused(): void {}\r\n    protected __abstractStatusBecomeOver(): void {}\r\n\r\n\r\n    public abstract setTimeout(callback: Function, millis: number, ...args: any[])\r\n    : G extends Game.Type.SERVER ? NodeJS.Timeout : number;\r\n\r\n    public abstract cancelTimeout(handle: number | NodeJS.Timeout): void;\r\n\r\n /* The implementations are fully defined and publicly exposed by\r\n    GameManager. These protected declarations higher up the class\r\n    hierarchy exist to allow OnlineGame to override them to send\r\n    a request to the ServerGame. */\r\n    public abstract processMoveRequest(desc: PlayerActionEvent.Movement<S>): void;\r\n    protected abstract processBubbleRequest(desc: PlayerActionEvent.Bubble): void;\r\n\r\n}\r\nObject.freeze(GameBase);\r\nObject.freeze(GameBase.prototype);\r\n","import type { Coord } from \"floor/Tile\";\r\nimport { Game } from \"../Game\";\r\n\r\nimport { PlayerActionEvent, TileModEvent } from \"../events/PlayerActionEvent\";\r\nimport { EventRecordEntry } from \"../events/EventRecordEntry\";\r\n\r\nimport { GameBase } from \"./Base\";\r\n\r\n\r\n/**\r\n * All events have two corresponding handler functions taking a\r\n * request descriptor object (\"desc\"):\r\n *\r\n * ### Request Processor\r\n *\r\n * The request processor is only used by the Game Manager. It decides\r\n * whether to accept or reject the request based on `desc` and may\r\n * throw exceptions on impossible arguments. It should not make any\r\n * changes to the game state. Instead, it is responsible to augment\r\n * `desc` with information describing what changes to the game state\r\n * must be made.\r\n *\r\n * ### Request Executor\r\n *\r\n * This takes the `desc` augmented by the request processor and enacts\r\n * all the described changes upon the game's state. If the Game Manager\r\n * is not local to the client (a server process), then this handler is\r\n * called at both the server and client.\r\n *\r\n * Updates the event record if the response is accepted.\r\n */\r\nexport abstract class GameEvents<G extends Game.Type, S extends Coord.System> extends GameBase<G,S> {\r\n\r\n    /**\r\n     * All copies of the game should contain identical entries. That\r\n     * in a {@link OnlineGame} may at any instant be missing trailing\r\n     * entries, or contain some trailing holes, but such gaps should\r\n     * eventually be filled to match those in the Game Manager.\r\n     *\r\n     * Do not modify this directly. To register an accepted event,\r\n     * call the {@link Game#recordEvent} method, passing it the event\r\n     * descriptor. To create a new event ID at the Game Manager, just\r\n     * take the current length of this array.\r\n     */\r\n    private readonly eventRecord: Array<Readonly<EventRecordEntry>>;\r\n\r\n    public constructor(\r\n        gameType: G,\r\n        impl: Game.ImplArgs<S>,\r\n        gameDesc: Game.CtorArgs<G,S>,\r\n    ) {\r\n        super(gameType, impl, gameDesc);\r\n        this.eventRecord = [];\r\n    }\r\n\r\n    public reset(): void {\r\n        // Clear the event record:\r\n        this.eventRecord.splice(0);\r\n\r\n        super.reset();\r\n    }\r\n\r\n    protected getNextUnusedEventId(): EventRecordEntry[\"eventId\"] {\r\n        return this.eventRecord.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * Basically does `this.eventRecord[id] = desc;` with value checking.\r\n     *\r\n     * @param desc -\r\n     *\r\n     * @throws\r\n     * In the given order of priority:\r\n     * - TypeError if the event ID indicates a rejected request\r\n     * - RangeError if it is not a positive integer\r\n     * - Error if another event was already recorded with the same ID.\r\n     */\r\n    private recordEvent(desc: Readonly<EventRecordEntry>): void {\r\n        const id = desc.eventId;\r\n        if (id === EventRecordEntry.EVENT_ID_REJECT) {\r\n            throw new TypeError(\"Do not try to record events for rejected requests.\");\r\n        } else if (id < 0 || id !== Math.trunc(id)) {\r\n            throw new RangeError(\"Event ID's must only be assigned positive, integer values.\");\r\n        } else if (this.eventRecord[id]) {\r\n            throw new Error(\"Event ID's must be assigned unique values.\");\r\n        }\r\n        // NOTE: If storage becomes a concern with logging events,\r\n        // create a static constant for the record's buffer size,\r\n        // and then here, wrap around.\r\n        this.eventRecord[id] = desc;\r\n    }\r\n\r\n\r\n    protected executeTileModEvent(\r\n        desc: TileModEvent<S>,\r\n        doCheckOperatorSeqBuffer: boolean = true,\r\n    ): void {\r\n        const dest = this.grid.tile.at(desc.coord);\r\n        if (dest.lastKnownUpdateId < desc.lastKnownUpdateId) {\r\n            if (desc.newCharSeqPair) {\r\n                dest.setLangCharSeqPair(desc.newCharSeqPair);\r\n                // Refresh the operator's `seqBuffer` (maintain invariant) for new CSP:\r\n                if (doCheckOperatorSeqBuffer && this.operator !== undefined\r\n                    && !(this.operator.tile.destsFrom().get.includes(dest))) {\r\n                    // ^Do this when non-operator moves into the the operator's vicinity.\r\n                    this.operator.seqBufferAcceptKey(\"\");\r\n                }\r\n            }\r\n            dest.lastKnownUpdateId = desc.lastKnownUpdateId;\r\n            dest.freeHealth = desc.newFreeHealth!;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the {@link Game#grid}. Call either at the end of\r\n     * {@link Game#processMoveRequest} if I am a {@link ServerGame} or\r\n     * {@link OfflineGame}, or as an event callback if I am a\r\n     * {@link OnlineGame}.\r\n     *\r\n     * Automatically lowers the {@link Player#requestInFlight} field\r\n     * for the requesting `Player` if the arriving event description\r\n     * is the newest one for the specified `Player`.\r\n     *\r\n     * Updates that are received after others that are more recent and\r\n     * concern the same {@link Tile} are ignored. This is okay since\r\n     * the only thing that matters about a {@link Tile} to the outside\r\n     * world is its last known state.\r\n     *\r\n     * @param desc\r\n     * A descriptor for all changes mandated by the player-movement event.\r\n     */\r\n    protected processMoveExecute(desc: Readonly<PlayerActionEvent.Movement<S>>): void {\r\n        const player = this.players[desc.playerId];\r\n        const dest   = this.grid.tile.at(desc.dest.coord);\r\n        const clientEventLag = desc.playerLastAcceptedRequestId - player.lastAcceptedRequestId;\r\n\r\n        if (desc.eventId === EventRecordEntry.EVENT_ID_REJECT) {\r\n            // Rejected request. Implies either that: clientEventLag === 0,\r\n            // or that (at Game Manager): dest.numTimesOccupied > desc.destNumTimesOccupied\r\n            if (clientEventLag === 1) {\r\n                player.requestInFlight = false;\r\n            }\r\n            return; // Short-circuit!\r\n        }\r\n        this.recordEvent(desc);\r\n        this.executeTileModEvent(desc.dest, player !== this.operator);\r\n        desc.tilesWithHealthUpdates!.forEach((desc) => {\r\n            this.executeTileModEvent(desc);\r\n        });\r\n\r\n        if (clientEventLag > 1) {\r\n            // ===== Out of order receipt (client-side) =====\r\n            // Already received more recent request responses.\r\n            if (player === this.operator) {\r\n                // Operator never receives their own updates out of\r\n                // order because they only have one unacknowledged\r\n                // in-flight request at a time.\r\n                throw new Error(\"This never happens. See comment in source.\");\r\n            }\r\n            return; // Short-circuit!\r\n        }\r\n        // Okay- the response is an acceptance of the specified player's most\r\n        // recent request pending this acknowledgement.\r\n        player.requestInFlight = false;\r\n        if ((player === this.operator)\r\n            ? (clientEventLag === 1)\r\n            : (clientEventLag <= 1)) {\r\n            player.status.score     = desc.newPlayerHealth!.score;\r\n            player.status.health = desc.newPlayerHealth!.health;\r\n\r\n            player.moveTo(dest);\r\n            // Below is computationally the same as \"(player.lastAcceptedRequestId)++\"\r\n            player.lastAcceptedRequestId = desc.playerLastAcceptedRequestId;\r\n\r\n        } else {\r\n            // Apparent negative lag. The operator may somehow have\r\n            // tampered with their player's request counter.\r\n            throw new Error(\"This never happens. See comment in source\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * Automatically lowers the {@link Player#requestInFlight} field\r\n     * for the requesting `Player`.\r\n     *\r\n     * @param desc -\r\n     */\r\n    protected processBubbleExecute(desc: Readonly<PlayerActionEvent.Bubble>): void {\r\n        // TODO.impl Visually highlight the affected tiles for the specified estimate-duration.\r\n        const bubbler = this.players[desc.playerId];\r\n\r\n        bubbler.requestInFlight = false;\r\n\r\n        if (desc.eventId !== EventRecordEntry.EVENT_ID_REJECT) {\r\n            this.recordEvent(desc); // Record the event.\r\n        }\r\n    }\r\n\r\n}\r\nObject.freeze(GameEvents);\r\nObject.freeze(GameEvents.prototype);\r\n","import { OmHooks } from \"browser/OmHooks\";\r\nimport { Coord, Tile } from \"./Tile\";\r\nimport { TileGetter } from \"./TileGetter\";\r\n\r\nimport type { Euclid2 } from \"./impl/Euclid2\";\r\nimport type { Beehive } from \"./impl/Beehive\";\r\nimport { VisibleGrid } from \"floor/VisibleGrid\";\r\n\r\n\r\n/**\r\n * # 🗺 The Grid Class\r\n *\r\n * A Collection of Tiles.\r\n */\r\nexport abstract class Grid<S extends Coord.System> implements TileGetter.Source<S> {\r\n\r\n    // A type-annotated alias to this.constructor.\r\n    public readonly static: Grid.ClassIf<S>;\r\n\r\n    public readonly dimensions: Grid.Dimensions<S>;\r\n\r\n    public get area(): number {\r\n        return this.static.getArea(this.dimensions);\r\n    }\r\n\r\n    public readonly tile: TileGetter<S,[Coord.Bare<S>]>;\r\n\r\n\r\n    /**\r\n     * Protected. See `Grid.getImplementation` for how to access class\r\n     * literals for construction.\r\n     *\r\n     * _Does not call reset._\r\n     *\r\n     * @param desc -\r\n     */\r\n    protected constructor(desc: Grid.CtorArgs<S>) {\r\n        this.static = desc.gridClass;\r\n        this.dimensions = desc.dimensions;\r\n        this.tile = new TileGetter(this);\r\n    }\r\n\r\n    /**\r\n     * Calls {@link Tile#reset} for each {@link Tile} in this `Grid`.\r\n     */\r\n    public reset(): void {\r\n        this.forEachTile((tile) => tile.reset());\r\n    }\r\n\r\n    /**\r\n     * Performs simple checks that the grid is playable.\r\n     *\r\n     * - Each tile in the grid has a non-self destination (coord#equals).\r\n     * - (compute-heavyish): Each tile follows Impl.getAmbiguityThreshold\r\n     */\r\n    protected check(): void {\r\n        // Check that\r\n    }\r\n\r\n\r\n    /**\r\n     * For BaseGame's implementation of SER/DES to work, the traversal\r\n     * order taken by an implementation of this method must depend\r\n     * only on the dimensions of the instance. Ie. If two Grids (such\r\n     * as those at the Client and Server when separated by a network)\r\n     * were constructed with the same arguments for their dimensions,\r\n     * then their Tiles should be traversed in the same order by this\r\n     * function.\r\n     *\r\n     * @param consumer -\r\n     * @param thisArg -\r\n     */\r\n    public abstract forEachTile(consumer: (tile: Tile<S>) => void, thisArg?: object): void;\r\n\r\n    /**\r\n     * @returns\r\n     * One of the closest unoccupied neighbouring tiles toward the\r\n     * direction of `intendedDest`. When possible, ties are encouraged\r\n     * to be broken in such a way that imitates movement in a straight\r\n     * path (visually speaking).\r\n     *\r\n     * **Important:** If All destinations from sourceCoord are occupied\r\n     * (which includes `sourceCoord` itself), the implementation must\r\n     * return `sourceCoord`.\r\n     *\r\n     * @param sourceCoord\r\n     * The coordinate from which to find the next hop.\r\n     *\r\n     * @param intendedDest\r\n     * Does not need to be within the boundaries of the {@link Game}'s\r\n     * grid, or have integer-valued coordinate values.\r\n     */\r\n    public abstract getUntToward(sourceCoord: Coord<S>, intendedDest: Coord<S>): Tile<S>;\r\n\r\n    /**\r\n     *\r\n     * @param sourceCoord -\r\n     * @param avoidCoord -\r\n     */\r\n    // TODO.doc\r\n    public abstract getUntAwayFrom(sourceCoord: Coord<S>, avoidCoord: Coord<S>): Tile<S>;\r\n\r\n    public getRandomCoord(): Coord<S> {\r\n        return this.static.getRandomCoord(this.dimensions);\r\n    }\r\n\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public abstract __getTileAt(coord: Coord.Bare<S>): Tile<S>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public abstract __getTileDestsFrom(coord: Coord.Bare<S>): Array<Tile<S>>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public abstract __getTileSourcesTo(coord: Coord.Bare<S>): Array<Tile<S>>;\r\n\r\n    /**\r\n     * Note: I would rather have this implementation go under the\r\n     * `VisibleGrid` class, but I don't want to get into mixins as of\r\n     * now to get around no-multiple-inheritance.\r\n     *\r\n     * @param desc -\r\n     * @param gridImplElem -\r\n     */\r\n    public __VisibleGrid_super(desc: Grid.CtorArgs<S>, gridImplElem: HTMLElement): void {\r\n        const OHG = OmHooks.Grid;\r\n        gridImplElem.tabIndex = 0;\r\n        gridImplElem.classList.add(OHG.Class.IMPL_BODY);\r\n        const parentElem = document.getElementById(desc.domParentHtmlIdHook);\r\n        if (!parentElem) {\r\n            throw new RangeError(`The ID \\\"${desc.domParentHtmlIdHook}\\\"`\r\n            + ` did not refer to an existing html element.`);\r\n        }\r\n        parentElem.dataset[OHG.Dataset.COORD_SYS] = desc.coordSys;\r\n        parentElem.classList.add(\r\n            OHG.Class.GRID,\r\n            OmHooks.General.Class.TEXT_SELECT_DISABLED,\r\n        );\r\n        // Remove all child elements from host and then append the new grid:\r\n        parentElem.querySelectorAll(`.${OHG.Class.IMPL_BODY}`).forEach((node) => node.remove());\r\n        parentElem.appendChild(gridImplElem);\r\n        (this as TU.NoRo<Grid<S>> as TU.NoRo<VisibleGrid<S>>).baseElem = gridImplElem;\r\n        {\r\n            // Add a \"keyboard-disconnected\" icon if not added already:\r\n            // This needs to be a _later_ sibling of gridImplElem.\r\n            let kbdDcIcon: HTMLElement | null = parentElem\r\n                .querySelector(`:scope > .${OHG.Class.KBD_DC_ICON}`);\r\n            if (!kbdDcIcon) {\r\n                // TODO.impl Add an <svg> with icon instead please.\r\n                kbdDcIcon = document.createElement(\"div\");\r\n                kbdDcIcon.classList.add(OHG.Class.KBD_DC_ICON);\r\n                kbdDcIcon.innerText = \"(click grid to continue typing)\";\r\n                parentElem.appendChild(kbdDcIcon);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\nexport namespace Grid {\r\n\r\n    /**\r\n     * Values do not _need_ to be in range or integers.\r\n     */\r\n    export type Dimensions<S extends Coord.System>\r\n        = S extends Coord.System.EUCLID2 ? Euclid2.Grid.Dimensions\r\n        : S extends Coord.System.BEEHIVE ? Beehive.Grid.Dimensions\r\n        : never;\r\n\r\n    // ==============================================================\r\n    // Note: The below exports do not require any modifications with\r\n    // the additions of new coordinate systems.\r\n    // ==============================================================\r\n\r\n    export type CtorArgs<S extends Coord.System> = {\r\n        gridClass: Grid.ClassIf<S>;\r\n        tileClass: Tile.ClassIf<S>;\r\n        coordSys: S;\r\n        dimensions: Dimensions<S>;\r\n        domParentHtmlIdHook: string;\r\n    };\r\n\r\n    /**\r\n     * Used to simulate abstract static methods.\r\n     */\r\n    export interface ClassIf<S extends Coord.System> {\r\n\r\n        /**\r\n         * Constructor\r\n         */\r\n        new(desc: CtorArgs<S>): Grid<S>;\r\n\r\n        /**\r\n         * @returns\r\n         * From the caller's point of view, the ambiguity floor is the\r\n         * minimum number of leaf nodes a language must have to be\r\n         * playable with this coordinate system's grid.\r\n         *\r\n         * From the specification's point of view, it is the promised\r\n         * maximum size- for any tile in the grid- of the set of all\r\n         * destinations from sources to itself, excluding itself.\r\n         */\r\n        // TODO.test write a test that checks that this holds for each implementation?\r\n        getAmbiguityThreshold(): number;\r\n\r\n        /**\r\n         * @see Grid.DimensionBounds\r\n         */\r\n        getSizeLimits(): Grid.DimensionBounds<S>;\r\n\r\n        /**\r\n         * @returns\r\n         * The number of Tiles that could fit in a Grid of such bounds.\r\n         *\r\n         * @param bounds -\r\n         */\r\n        getArea(bounds: Dimensions<S>): number;\r\n\r\n        /**\r\n         * @returns\r\n         * A coordinate with random, integer-valued fields within the\r\n         * specified upper limits\r\n         *\r\n         * @param boundX An exclusive bound on x-coordinate.\r\n         * @param boundY An exclusive bound on y-coordinate. Optional. Defaults to `boundX`.\r\n         */\r\n        getRandomCoord(bounds: Dimensions<S>): Coord<S>;\r\n\r\n        /**\r\n         * Return values do not need to be the same for repeated calls\r\n         * with identical arguments. None of the returned coordinates\r\n         * should be the same.\r\n         *\r\n         * @param playerCounts -\r\n         */\r\n        getSpawnCoords(\r\n            playerCounts: number,\r\n            dimensions: Dimensions<S>,\r\n        ): TU.RoArr<Coord.Bare<S>>;\r\n\r\n    };\r\n\r\n    // Each implementation must register itself into this dictionary.\r\n    export declare const __Constructors: {\r\n        readonly [ S in Coord.System ]: Grid.ClassIf<S>\r\n    };\r\n\r\n    /**\r\n     * @returns\r\n     * A Grid class for the specified coordinate system.\r\n     *\r\n     * @param coordSys -\r\n     */\r\n    export const getImplementation = <S extends Coord.System>(coordSys: S): ClassIf<S> => {\r\n        // Note: At the time of writing this, separating this into\r\n        // two lines is necessary (otherwise Typescript will feel\r\n        // overwhelmed)\r\n        const ctor = __Constructors[coordSys];\r\n        return ctor as unknown as ClassIf<S>;\r\n    };\r\n\r\n    /**\r\n     * Bounds are inclusive. Ie. the specified values are _just_ allowed.\r\n     *\r\n     * Upper and lower bounds must be strictly positive integer values.\r\n     */\r\n    export type DimensionBounds<S extends Coord.System> = Readonly<{\r\n        [ P in keyof Dimensions<S> ]: Readonly<{\r\n            min: number;\r\n            max: number;\r\n        }>;\r\n    }>;\r\n\r\n}\r\n// Grid gets frozen in PostInit after __Constructors get initialized.\r\n","import { Coord as BaseCoord, Tile } from \"../Tile\";\r\nimport type { VisibleTile } from \"floor/VisibleTile\";\r\nimport { Grid as AbstractGrid } from \"../Grid\";\r\nimport { VisibleGrid } from \"../VisibleGrid\";\r\n\r\n\r\ntype S = BaseCoord.System.EUCLID2;\r\n\r\n/**\r\n *\r\n */\r\nexport namespace Euclid2 {\r\n\r\n    /**\r\n     * # Euclid2 Coord\r\n     */\r\n    export class Coord extends BaseCoord.Abstract.Mathy<S> implements Coord.Bare {\r\n\r\n        public readonly x: number;\r\n        public readonly y: number;\r\n\r\n        public constructor(desc: Coord.Bare) {\r\n            super(desc);\r\n            this.x = desc.x;\r\n            this.y = desc.y;\r\n            Object.freeze(this);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public equals(other: Coord.Bare): boolean {\r\n            return (this.x === other.x) && (this.y === other.y);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public round(): Coord {\r\n            return new Coord({\r\n                x: Math.round(this.x),\r\n                y: Math.round(this.y),\r\n            });\r\n        }\r\n\r\n\r\n\r\n        /**\r\n         * Also known as the \"manhattan norm\".\r\n         *\r\n         * _Do not override this._\r\n         *\r\n         * @param other - The norm is taken relative to `other`.\r\n         * @returns The sum of the absolute values of each coordinate.\r\n         */\r\n        public oneNorm(other: Coord.Bare): number {\r\n            return this.sub(other).originOneNorm();\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public originOneNorm(): number {\r\n            return Math.abs(this.x) + Math.abs(this.y);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * _Do not override this._\r\n         *\r\n         * @param other - The norm is taken relative to `other`.\r\n         * @returns The length of the longest dimension.\r\n         */\r\n        public infNorm(other: Coord.Bare): number {\r\n            return this.sub(other).originInfNorm();\r\n        }\r\n\r\n        public originInfNorm(): number {\r\n            return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n        }\r\n\r\n        /**\r\n         * @returns\r\n         * A number in the range (0, 1). `One` means the x and y coordinates\r\n         * align to the x or y axis, and `Zero` means they are plus or minus\r\n         * 45 degrees from the x or y axis.\r\n         *\r\n         * You can try this yourself in [Desmos](https://www.desmos.com/calculator)\r\n         * by pasting in the below code segment and adding a slider for `a`\r\n         * for continuous values between zero and one.\r\n         *\r\n         * ```latex\r\n         * \\frac{\\left|\\left|x\\right|-\\left|y\\right|\\right|}{\\left|x\\right|+\\left|y\\right|}=a\r\n         * ```\r\n         *\r\n         * @param other - The alignment is taken relative to `other`.\r\n         */\r\n        public axialAlignment(other: Coord.Bare): number {\r\n            return this.sub(other).originAxialAlignment();\r\n        }\r\n\r\n        public originAxialAlignment(): number {\r\n            return Math.abs(Math.abs(this.x) - Math.abs(this.y))\r\n                / (Math.abs(this.x) + Math.abs(this.y));\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public add(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                x: this.x + other.x,\r\n                y: this.y + other.y,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public sub(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                x: this.x - other.x,\r\n                y: this.y - other.y,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public mul(scalar: number): Coord {\r\n            return new Coord({\r\n                x: scalar * this.x,\r\n                y: scalar * this.y,\r\n            });\r\n        }\r\n    }\r\n\r\n    export namespace Coord {\r\n        export type Bare = Readonly<{\r\n            x: number;\r\n            y: number;\r\n        }>;\r\n    }\r\n    Object.freeze(Coord);\r\n    Object.freeze(Coord.prototype);\r\n\r\n\r\n\r\n    /**\r\n     * # Euclid2 Grid\r\n     */\r\n    export class Grid extends AbstractGrid<S> {\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getAmbiguityThreshold(): 24 {\r\n            return 24;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSizeLimits(): AbstractGrid.DimensionBounds<S> { return this.SIZE_LIMITS; }\r\n        private static readonly SIZE_LIMITS = Object.freeze(<const>{\r\n            height: Object.freeze(<const>{ min: 11, max: 51, }),\r\n            width:  Object.freeze(<const>{ min: 11, max: 51, }),\r\n        });\r\n\r\n        /**\r\n         * A 2-dimensional rectangular array with height and width following\r\n         * their corresponding fields, containing `Tile` objects with `pos`\r\n         * fields allowing indexing to themselves. Uses _row-major_ ordering.\r\n         */\r\n        protected readonly grid: TU.RoArr<TU.RoArr<Tile<S>>>;\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n            super(desc);\r\n\r\n            const grid: Array<TU.RoArr<Tile<S>>> = [];\r\n            for (let row = 0; row < this.dimensions.height; row++) {\r\n                const newRow: Array<Tile<S>> = [];\r\n                for (let col = 0; col < this.dimensions.width; col++) {\r\n                    const newTile = new desc.tileClass(new Coord({ x: col, y: row, }));\r\n                    newRow.push(newTile);\r\n                }\r\n                grid.push(newRow);\r\n            }\r\n            this.grid = grid;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public forEachTile(consumer: (tile: Tile<S>) => void, thisArg: object = this): void {\r\n            this.grid.forEach((row) => row.forEach((tile) => {\r\n                consumer(tile);\r\n            }, thisArg), thisArg);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public getUntToward(sourceCoord: Coord, intendedDest: Coord.Bare): Tile<S> {\r\n            const options = this.tile.destsFrom(sourceCoord).unoccupied.get;\r\n            if (options.length === 0) {\r\n                return this.tile.at(sourceCoord);\r\n            }\r\n            if (options.length === 1) {\r\n                // Minor optimization:\r\n                return options[0];\r\n            }\r\n            options.sort((tileA, TileB) => {\r\n                // Break (some) ties by one-norm:\r\n                return tileA.coord.oneNorm(intendedDest) - TileB.coord.oneNorm(intendedDest);\r\n            }).sort((tileA, TileB) => {\r\n                // Break (some) ties by one-norm:\r\n                return tileA.coord.infNorm(intendedDest) - TileB.coord.infNorm(intendedDest);\r\n            });\r\n            // Filter out options that are not equally favourable as the\r\n            // most favourable option. I think this is the best method:\r\n            // Note: it is safe to start at index `1` because of the\r\n            // above short-circuit if `options.length === 1`.\r\n            for (let i = 1; i < options.length; i++) {\r\n                if (options[i].coord.infNorm(intendedDest) > options[0].coord.infNorm(intendedDest)) {\r\n                    options.splice(i);\r\n                    break;\r\n                }\r\n            }\r\n            if (options.length === 1) {\r\n                // Minor optimization:\r\n                return options[0];\r\n            }\r\n            // Choose one of the most favourable using some randomness\r\n            // weighted to follow a straight-looking path of movement.\r\n            if (options[0].coord.x - sourceCoord.x === 0 || options[0].coord.y - sourceCoord.y === 0) {\r\n                // (the axial option (if it exists) should be the first\r\n                // due to the previous sort's tie-breaker.\r\n                if (sourceCoord.axialAlignment(sourceCoord.sub(intendedDest)) - 0.5 > 0.0) {\r\n                    // The path to the intended destination is aligned more\r\n                    // with the x or y axis than they are with those axes\r\n                    // rotated 45 degrees.\r\n                    return options[0];\r\n                } else {\r\n                    // Ignore the axial option in further computations:\r\n                    options.shift();\r\n                }\r\n            }\r\n            // Choose a random non-axial option:\r\n            return options[Math.floor(options.length * Math.random())];\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public getUntAwayFrom(sourceCoord: Coord, avoidCoord: Coord): Tile<S> {\r\n            return this.getUntToward(sourceCoord, sourceCoord.add(\r\n                sourceCoord.sub(avoidCoord)\r\n            ));\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileAt(coord: Coord.Bare): Tile<S> {\r\n            if (coord.x < 0 || coord.x >= this.dimensions.width ||\r\n                coord.y < 0 || coord.y >= this.dimensions.height\r\n            ) {\r\n                throw new RangeError(\"Out of bounds. No such tile exists.\");\r\n            }\r\n            return this.grid[coord.y][coord.x];\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileDestsFrom(coord: Coord.Bare, radius: number = 1): Array<Tile<S>> {\r\n            let t = coord.y - radius;\r\n            let b = coord.y + radius + 1;\r\n            let l = coord.x - radius;\r\n            let r = coord.x + radius + 1;\r\n            if (t >= this.dimensions.height || b < 0\r\n             || l >= this.dimensions.width  || r < 0) return [];\r\n            return this.grid.slice(\r\n                // filter for included rows:\r\n                Math.max(0, t),\r\n                Math.min(this.dimensions.height, b),\r\n            ).flatMap((gridRow) => gridRow.slice(\r\n                // filter for included slices of rows (columns):\r\n                Math.max(0, l),\r\n                Math.min(this.dimensions.width, r),\r\n            ));\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileSourcesTo(coord: Coord.Bare, radius: number = 1): Array<Tile<S>> {\r\n            // Same behaviour as getting destinations from `coord`.\r\n            return this.__getTileDestsFrom(coord, radius);\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSpawnCoords(\r\n            playerCounts: number,\r\n            dimensions: Grid.Dimensions,\r\n        ):  TU.RoArr<Coord.Bare> {\r\n            return [{x:0,y:0,},];\r\n\r\n            // TODO.impl A proper, nice looking version of this.\r\n            //\r\n            //\r\n            //\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getArea(dim: Grid.Dimensions): number {\r\n            return dim.height * dim.width;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getRandomCoord(dimensions: Grid.Dimensions): Coord {\r\n            const x = Math.floor(dimensions.width  * Math.random());\r\n            const y = Math.floor(dimensions.height * Math.random());\r\n            return new Coord({x,y,});\r\n        }\r\n    }\r\n\r\n    export namespace Grid {\r\n        /**\r\n         * If `width` is not specified, `height` is taken as its default value.\r\n         */\r\n        export type Dimensions = {\r\n            height: number,\r\n            width:  number,\r\n        };\r\n\r\n        export class Visible extends Grid implements VisibleGrid<S> {\r\n            public readonly baseElem: HTMLElement;\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            declare protected readonly grid: TU.RoArr<TU.RoArr<VisibleTile<S>>>;\r\n\r\n            public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n                super(desc);\r\n                const gridElem = document.createElement(\"div\");\r\n                gridElem.style.setProperty(\"--euclid2-grid-width\",  this.dimensions.width.toString());\r\n                //gridElem.style.setProperty(\"--euclid2-grid-height\", this.dimensions.height.toString());\r\n                for (const row of this.grid) {\r\n                    for (const tile of row) {\r\n                        tile.__addToDom(gridElem);\r\n                    }\r\n                }\r\n                this.__VisibleGrid_super(desc, gridElem);\r\n            }\r\n        }\r\n    }\r\n    Object.freeze(Grid);\r\n    Object.freeze(Grid.prototype);\r\n\r\n}\r\nObject.freeze(Euclid2);\r\n","import { Coord as BaseCoord, Tile } from \"../Tile\";\r\nimport type { VisibleTile } from \"floor/VisibleTile\";\r\nimport { Grid as AbstractGrid } from \"../Grid\";\r\nimport { VisibleGrid } from \"../VisibleGrid\";\r\n\r\n\r\ntype S = BaseCoord.System.BEEHIVE;\r\n\r\n/**\r\n * # 🐝 BEES !\r\n *\r\n * # 🐝 BEES !\r\n *\r\n * # 🐝 BEES !\r\n *\r\n * ```text\r\n *   ___   ___\r\n *  //  \\_//  \\__\r\n *  \\\\__/  \\__/  \\\r\n *     \\\\__/ \\\\__/\r\n * ```\r\n *\r\n *\r\n * [(bees)](https://giphy.com/gifs/oprah-bees-VhFps32TlNgsg)\r\n */\r\nexport namespace Beehive {\r\n\r\n    /**\r\n     * # Beehive Coord\r\n     */\r\n    export class Coord extends BaseCoord.Abstract.Mathy<S> implements Coord.Bare {\r\n\r\n        /**\r\n         * # 🕒 3'o'clock direction\r\n         */\r\n        public readonly dash: number;\r\n\r\n        /**\r\n         * # 🕔 5'o'clock direction\r\n         */\r\n        public readonly bash: number;\r\n\r\n        public constructor(desc: Coord.Bare) {\r\n            super(desc);\r\n            this.dash = desc.dash;\r\n            this.bash = desc.bash;\r\n            Object.freeze(this);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public equals(other: Coord.Bare): boolean {\r\n            return (this.dash === other.dash) && (this.bash === other.bash);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public round(): Coord {\r\n            // I'm pretty proud of this despite the fact that I don't\r\n            // think there's anything very impressive about it.\r\n            const floorDash = Math.floor(this.dash);\r\n            const floorBash = Math.floor(this.bash);\r\n            const d = floorDash - this.dash;\r\n            const b = floorBash - this.bash;\r\n            if (d > 2 * b) {\r\n                return new Coord({ dash: floorDash+1, bash: floorBash  , });\r\n            } else if (d < 0.5 * b) {\r\n                return new Coord({ dash: floorDash  , bash: floorBash+1, });\r\n            } else if (Math.min(d, b) > 0.5) {\r\n                return new Coord({ dash: floorDash+1, bash: floorBash+1, });\r\n            } else {\r\n                return new Coord({ dash: floorDash  , bash: floorBash  , });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public add(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                dash: this.dash + other.dash,\r\n                bash: this.bash + other.bash,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public sub(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                dash: this.dash - other.dash,\r\n                bash: this.bash - other.bash,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public mul(scalar: number): Coord {\r\n            return new Coord({\r\n                dash: scalar * this.dash,\r\n                bash: scalar * this.bash,\r\n            });\r\n        }\r\n    }\r\n\r\n    export namespace Coord {\r\n        export type Bare = Readonly<{\r\n            dash: number;\r\n            bash: number;\r\n        }>;\r\n    }\r\n    Object.freeze(Coord);\r\n    Object.freeze(Coord.prototype);\r\n\r\n\r\n\r\n    /**\r\n     * # Beehive Grid\r\n     */\r\n    export class Grid extends AbstractGrid<S> {\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getAmbiguityThreshold(): 18 {\r\n            return 18;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSizeLimits(): AbstractGrid.DimensionBounds<S> { return this.SIZE_LIMITS; }\r\n        private static readonly SIZE_LIMITS = Object.freeze({\r\n            dash:    Object.freeze({ min: 10, max: 50, }),\r\n            bslash:  Object.freeze({ min: 10, max: 50, }),\r\n            fslash:  Object.freeze({ min: 10, max: 50, }),\r\n        });\r\n\r\n        /**\r\n         *\r\n         */\r\n        // TODO.design determine spec for indexing\r\n        // Then initialize the field in the constructor\r\n        // Also design HTML representation and initialize in Grid.Visible\r\n        private readonly grid: TU.RoArr<TU.RoArr<Tile<S>>>;\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n            super(desc);\r\n\r\n            // Initialize `grid`:\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public forEachTile(consumer: (tile: Tile<S>) => void, thisArg: object = this): void {\r\n            this.grid.forEach((row) => row.forEach((tile) => {\r\n                consumer(tile);\r\n            }, thisArg), thisArg);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public getUntToward(sourceCoord: Coord, intendedDest: Coord.Bare): Tile<S> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public getUntAwayFrom(sourceCoord: Coord, avoidCoord: Coord): Tile<S> {\r\n            return this.getUntToward(sourceCoord, sourceCoord.add(\r\n                sourceCoord.sub(avoidCoord)\r\n            ));\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileAt(coord: Coord.Bare): Tile<S> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileDestsFrom(coord: Coord.Bare): Array<Tile<S>> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileSourcesTo(coord: Coord.Bare): Array<Tile<S>> {\r\n            return undefined!;\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSpawnCoords(\r\n            playerCounts: number,\r\n            dimensions: Grid.Dimensions,\r\n        ): ReadonlyArray<Coord.Bare> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getArea(dim: Grid.Dimensions): number {\r\n            const shorterSide = Math.min(dim.fslash, dim.bslash);\r\n            const longerSide  = Math.max(dim.fslash, dim.bslash);\r\n            const width = (-1) + dim.dash + shorterSide;\r\n            let area = 2 * shorterSide * (dim.dash + width);\r\n            area += (longerSide - shorterSide - 1) * width;\r\n            return area;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getRandomCoord(dimensions: Grid.Dimensions): Coord {\r\n            return new Coord(undefined!);\r\n        }\r\n    }\r\n\r\n    export namespace Grid {\r\n        export type Dimensions = {\r\n            dash: number;\r\n            bslash: number;\r\n            fslash: number;\r\n        };\r\n\r\n        export class Visible extends Grid implements VisibleGrid<S> {\r\n            public readonly baseElem: HTMLElement;\r\n            public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n                super(desc);\r\n                const domGrid: HTMLElement = undefined!;\r\n                // TODO.impl Beehive VisibleGrid ctor.\r\n                this.__VisibleGrid_super(desc, domGrid);\r\n            }\r\n        }\r\n    }\r\n    Object.freeze(Grid);\r\n    Object.freeze(Grid.prototype);\r\n\r\n}\r\nObject.freeze(Beehive);\r\n","import { Grid } from \"floor/Grid\";\r\nimport { VisibleGrid } from \"floor/VisibleGrid\";\r\n\r\nimport { Euclid2 } from \"floor/impl/Euclid2\";\r\nimport { Beehive } from \"floor/impl/Beehive\";\r\n\r\nimport { ArtificialPlayer } from \"./player/ArtificialPlayer\";\r\nimport { Chaser } from \"./player/artificials/Chaser\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport namespace IndexTasks {\r\n\r\n    /**\r\n     * This function should be imported and run at the beginning of each\r\n     * index.js file before calling any constructors for SnaKey-related\r\n     * classes.\r\n     *\r\n     * It serves the dual purpose of initializing implementation\r\n     * registries _after_ implementations and their class hierarchy have\r\n     * been defined, and of importing implementations so they don't get\r\n     * tree-shaken-out by webpack.\r\n     */\r\n    export function INIT_CLASS_REGISTRIES(): void\r\n    { {\r\n        // Non-Visible Grid Implementation Registry:\r\n        (<TU.NoRo<typeof Grid.__Constructors>>Grid.__Constructors)\r\n        = Object.freeze({\r\n            [ \"EUCLID2\" ]: Euclid2.Grid,\r\n            [ \"BEEHIVE\" ]: Beehive.Grid,\r\n        });\r\n        Object.freeze(Grid);\r\n        Object.freeze(Grid.prototype);\r\n    } {\r\n        // Visible Grid Implementation Registry:\r\n        const VGr = VisibleGrid;\r\n        (<TU.NoRo<typeof VGr.__Constructors>>VGr.__Constructors)\r\n        = Object.freeze({\r\n            [ \"EUCLID2\" ]: Euclid2.Grid.Visible,\r\n            [ \"BEEHIVE\" ]: Beehive.Grid.Visible,\r\n        });\r\n        Object.freeze(VGr);\r\n        // This is just an interface. There is no instance prototype to freeze.\r\n    } {\r\n        const AP = ArtificialPlayer;\r\n        (<TU.NoRo<typeof AP.__Constructors>>AP.__Constructors)\r\n        = Object.freeze({\r\n            CHASER: Chaser,\r\n        });\r\n        Object.freeze(AP);\r\n        Object.freeze(AP.prototype);\r\n    } }\r\n    Object.freeze(INIT_CLASS_REGISTRIES);\r\n}\r\nObject.freeze(IndexTasks);","import { Lang } from \"lang/Lang\";\r\nimport { Game } from \"game/Game\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"../player/Player\";\r\n\r\nimport { PlayerGeneratedRequest } from \"../events/EventRecordEntry\";\r\nimport { PlayerActionEvent, TileModEvent } from \"../events/PlayerActionEvent\";\r\n\r\nimport { English } from \"lang/impl/English\"; // NOTE: temporary placeholder.\r\nimport { GameEvents } from \"game/__gameparts/Events\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport abstract class GameManager<G extends Game.Type, S extends Coord.System> extends GameEvents<G,S> {\r\n\r\n    public readonly averageFreeHealth: Player.Health;\r\n    public readonly averageFreeHealthPerTile: Player.Health;\r\n    #currentFreeHealth: Player.Health;\r\n\r\n    public readonly lang: Lang;\r\n\r\n    /**\r\n     * NOTE: Shuffling operations and the\r\n     * {@link Lang} implementation are able to support mid-game changes\r\n     * to the balancing behaviour. Making it fixed for the lifetime of\r\n     * a `Game` is a choice I made in order to make the user experience\r\n     * more simple. It's one less thing they'll see in the in-game UI,\r\n     * and I don't think they'd feel as if it were missing.\r\n     */\r\n    protected readonly langBalancingScheme: Lang.BalancingScheme;\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * Performs the \"no invincible player\" check (See {@link Player#teamSet}).\r\n     *\r\n     * @param gameType -\r\n     * @param impl -\r\n     * @param desc -\r\n     */\r\n    public constructor(\r\n        gameType: G,\r\n        impl: Game.ImplArgs<S>,\r\n        desc: Game.CtorArgs<G,S>,\r\n    ) {\r\n        super(gameType, impl, desc);\r\n        this.averageFreeHealth = desc.averageFreeHealthPerTile * this.grid.area;\r\n        this.averageFreeHealthPerTile = desc.averageFreeHealthPerTile;\r\n\r\n        // TODO.impl Change this to use a dynamic import for a Lang registry dict.\r\n        // We need to make that registry dict first!\r\n        this.lang = English.Lowercase.getInstance();\r\n\r\n        // TODO.impl Enforce this in the UI code by greying out unusable combos of lang and coord-sys.\r\n        const minLangLeaves = this.grid.static.getAmbiguityThreshold();\r\n        if (this.lang.numLeaves < minLangLeaves) {\r\n            throw new Error(`Found ${this.lang.numLeaves} leaves, but at`\r\n            + ` least ${minLangLeaves} were required. The provided mappings`\r\n            + ` composing the current Lang-under-construction are not`\r\n            + ` sufficient to ensure that a shuffling operation will always`\r\n            + ` be able to find a safe candidate to use as a replacement.`\r\n            + ` Please see the spec for Lang.getNonConflictingChar.`\r\n            );\r\n        }\r\n        this.langBalancingScheme = desc.langBalancingScheme;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public reset(): void {\r\n        // Reset the grid and event record:\r\n        super.reset();\r\n\r\n        this.#currentFreeHealth = 0.0;\r\n\r\n        // Reset hit-counters in the current language:\r\n        // This must be done before shuffling so that the previous\r\n        // history of shuffle-ins has no effects on the new pairs.\r\n        this.lang.reset();\r\n        // Shuffle everything:\r\n        this.grid.forEachTile((tile) => {\r\n            tile.setLangCharSeqPair(this.dryRunShuffleLangCharSeqAt(tile));\r\n        });\r\n\r\n        // Reset and spawn players:\r\n        this.teams.forEach((team) => team.reset());\r\n        const spawnPoints = this.grid.static.getSpawnCoords(\r\n            this.players.length,\r\n            this.grid.dimensions,\r\n        );\r\n        this.players.forEach((player) => {\r\n            player.reset(this.grid.tile.at(spawnPoints[player.playerId]));\r\n        });\r\n\r\n        // Targets should be spawned _after_ players have spawned so\r\n        // that they do not spawn in the same tile as any players.\r\n        this.dryRunSpawnFreeHealth().forEach((tileModDesc) => {\r\n            this.executeTileModEvent(tileModDesc);\r\n        })\r\n    }\r\n\r\n\r\n    /**\r\n     * **Important:** Nullifies the existing values at `tile` and does\r\n     * not consume the returned values, which must be done externally.\r\n     *\r\n     * @param targetTile\r\n     * The {@link Tile} to shuffle their {@link Lang.CharSeqPair}\r\n     * pair for.\r\n     *\r\n     * @returns\r\n     * A {@link Lang.CharSeqPair} that can be used as a replacement\r\n     * for that currently being used by `tile`.\r\n     */\r\n    public dryRunShuffleLangCharSeqAt(targetTile: Tile<S>): Lang.CharSeqPair {\r\n        // First, clear values for the target tile so its current\r\n        // (to-be-previous) values don't get unnecessarily avoided.\r\n        targetTile.setLangCharSeqPair(Lang.CharSeqPair.NULL);\r\n\r\n        const avoid: TU.RoArr<Tile<S>> = Array.from(new Set(\r\n            this.grid.tile.sourcesTo(targetTile.coord).get\r\n            .flatMap((sourceToTarget) => this.grid.tile.destsFrom(sourceToTarget.coord).get)\r\n        ));\r\n        return this.lang.getNonConflictingChar(avoid\r\n                .map((tile) => tile.langSeq)\r\n                .filter((seq) => seq), // no falsy values.\r\n            this.langBalancingScheme,\r\n        );\r\n    }\r\n\r\n    public get currentFreeHealth(): Player.Health {\r\n        return this.#currentFreeHealth;\r\n    }\r\n\r\n    /**\r\n     * @returns\r\n     * A descriptor of changes to make to tiles regarding health spawning.\r\n     *\r\n     * **`IMPORTANT`**: This method does not have any override structure\r\n     * where the Server additionally notifies clients of the changes. It\r\n     * is intended to be wrapped inside other events with such behaviour.\r\n     */\r\n    public dryRunSpawnFreeHealth(): TU.RoArr<TileModEvent<S>> {\r\n        let healthToSpawn = this.averageFreeHealth - this.currentFreeHealth;\r\n        if (healthToSpawn <= 0) return [];\r\n        const retval: Array<TileModEvent<S>> = [];\r\n        while (healthToSpawn > 0) {\r\n            let tile: Tile<S>;\r\n            do {\r\n                tile = this.grid.tile.at(this.grid.getRandomCoord());\r\n                // The below equality check is necessary to prevent counting bugs.\r\n                // TODO.learn see other TODO about the type cast seen here on the below line.\r\n            } while (tile.isOccupied || retval.find((desc) => tile.coord.equals(desc.coord as any)));\r\n            const tileHealthToAdd = 1;\r\n            retval.push({\r\n                coord: tile.coord,\r\n                lastKnownUpdateId: 1 + tile.lastKnownUpdateId,\r\n                newCharSeqPair: undefined, // \"do not change\".\r\n                newFreeHealth: tile.freeHealth + tileHealthToAdd,\r\n            })\r\n            healthToSpawn -= tileHealthToAdd;\r\n        }\r\n        return retval;\r\n    }\r\n\r\n\r\n    /**\r\n     * Perform checks on an incoming event request for some action that\r\n     * a player can perform while the game is playing (ie. not paused\r\n     * or over).\r\n     *\r\n     * @param desc -\r\n     * @returns\r\n     * The player specified by the given ID, or undefined if the\r\n     * game is not playing, in which case the event request should\r\n     * be rejected.\r\n     *\r\n     * @throws\r\n     * `RangeError` if the request was made before receiving an\r\n     * acknowledgement for the previous request, or if the given ID\r\n     * does not belong to any existing player.\r\n     */\r\n    private managerCheckGamePlayingRequest(desc: PlayerGeneratedRequest): Player<S> | undefined {\r\n        if (this.status !== Game.Status.PLAYING) {\r\n            return undefined;\r\n        }\r\n        const player = this.players[desc.playerId];\r\n        if (!player) {\r\n            throw new Error(\"No such player exists.\");\r\n        }\r\n        if (desc.playerLastAcceptedRequestId !== player.lastAcceptedRequestId) {\r\n            throw new RangeError((desc.playerLastAcceptedRequestId < player.lastAcceptedRequestId)\r\n            ? (\"Clients should not make requests until they have\"\r\n                + \" received my response to their last request.\")\r\n            : (\"Client seems to have incremented the request ID\"\r\n                + \" counter on their own, which is is illegal.\")\r\n            );\r\n        }\r\n        return player;\r\n    }\r\n\r\n\r\n    /**\r\n     * @see PlayerMovementEvent\r\n     *\r\n     * Reject the request if `dest` is occupied, or if the specified\r\n     * player does not exist, or the client is missing updates for the\r\n     * destination they requested to move to, or the player is bubbling.\r\n     *\r\n     * @param desc\r\n     * A descriptor of the request describing the requester's views\r\n     * of critical parts of the game-state from their copy of the game\r\n     * state at the time of the request. Is modified to describe changes\r\n     * to be made.\r\n     */\r\n    public processMoveRequest(desc: PlayerActionEvent.Movement<S>): void {\r\n        const player = this.managerCheckGamePlayingRequest(desc);\r\n        if (!player) {\r\n            // Reject the request:\r\n            this.processMoveExecute(desc);\r\n            return;\r\n        }\r\n        const dest = this.grid.tile.at(desc.dest.coord);\r\n        if (dest.isOccupied ||\r\n            dest.lastKnownUpdateId !== desc.dest.lastKnownUpdateId) {\r\n            // The update ID check is not essential, but it helps\r\n            // enforce stronger client-experience consistency: they cannot\r\n            // move somewhere where they have not realized the `LangSeq` has\r\n            // changed.\r\n            this.processMoveExecute(desc); // Reject the request.\r\n            return;\r\n        }\r\n\r\n        // Set response fields according to spec in `PlayerMovementEvent`:\r\n        desc.playerLastAcceptedRequestId = (1 + player.lastAcceptedRequestId);\r\n        desc.newPlayerHealth = {\r\n            score:  player.status.score  + dest.freeHealth,\r\n            health: player.status.health + dest.freeHealth,\r\n        };\r\n        desc.dest.lastKnownUpdateId = (1 + dest.lastKnownUpdateId);\r\n        desc.dest.newFreeHealth = 0;\r\n        desc.dest.newCharSeqPair = this.dryRunShuffleLangCharSeqAt(dest);\r\n        desc.tilesWithHealthUpdates = this.dryRunSpawnFreeHealth();\r\n\r\n        // Accept the request, and trigger calculation\r\n        // and enactment of the requested changes:\r\n        desc.eventId = this.getNextUnusedEventId();\r\n        this.processMoveExecute(desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected executeTileModEvent(\r\n        desc: TileModEvent<S>,\r\n        doCheckOperatorSeqBuffer: boolean = true,\r\n    ): void {\r\n        const tile = this.grid.tile.at(desc.coord);\r\n        if (desc.lastKnownUpdateId !== tile.lastKnownUpdateId + 1) {\r\n            // TODO.fix Why are we running into this?\r\n            // We literally just specified this in processMoveRequest.\r\n            throw new Error(\"this never happens. see comment in source.\");\r\n        }\r\n        this.#currentFreeHealth += desc.newFreeHealth! - tile.freeHealth;\r\n        super.executeTileModEvent(desc, doCheckOperatorSeqBuffer);\r\n    }\r\n\r\n\r\n    /**\r\n     * @see PlayerActionEvent.Bubble\r\n     * @param desc - Is modified to describe changes to be made.\r\n     */\r\n    public processBubbleRequest(desc: PlayerActionEvent.Bubble): void {\r\n        // TODO.impl\r\n        // - If successful, make sure to lower the health field.\r\n        // - Make an abstract method in the OperatorPlayer class called in\r\n        //   the top-level input processor for it to trigger this event.\r\n        const bubbler = this.managerCheckGamePlayingRequest(desc);\r\n        if (!bubbler) {\r\n            // Reject the request:\r\n            this.processBubbleExecute(desc);\r\n            return;\r\n        }\r\n        desc.playerLastAcceptedRequestId = (1 + bubbler.lastAcceptedRequestId);\r\n\r\n        // We are all go! Do it.\r\n        desc.eventId = this.getNextUnusedEventId();\r\n        this.processBubbleExecute(desc);\r\n    }\r\n\r\n}\r\nObject.freeze(GameManager);\r\nObject.freeze(GameManager.prototype);\r\n","import { Game } from \"game/Game\";\r\n\r\nimport type { Coord }           from \"floor/Tile\";\r\nimport { VisibleTile }          from \"floor/VisibleTile\";\r\nimport { VisibleGrid }          from \"floor/VisibleGrid\";\r\n\r\nimport type { Player }          from \"game/player/Player\";\r\nimport { OperatorPlayer }       from \"game/player/OperatorPlayer\";\r\nimport { VisiblePlayerStatus }  from \"game/player/VisiblePlayerStatus\";\r\nimport { ArtificialPlayer }     from \"game/player/ArtificialPlayer\";\r\n\r\nimport { GameManager } from \"game/__gameparts/Manager\";\r\n\r\n\r\ntype G = Game.Type.OFFLINE;\r\n\r\n/**\r\n *\r\n *\r\n * @extends Game\r\n */\r\nexport class OfflineGame<S extends Coord.System> extends GameManager<G,S> {\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected __getGridImplementation(coordSys: S): VisibleGrid.ClassIf<S> {\r\n        return VisibleGrid.getImplementation(coordSys);\r\n    }\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param gameDesc -\r\n     */\r\n    public constructor(gameDesc: Game.CtorArgs<G,S>) {\r\n        super(\r\n            Game.Type.OFFLINE, {\r\n            tileClass: VisibleTile,\r\n            playerStatusCtor: VisiblePlayerStatus,\r\n            }, gameDesc,\r\n        );\r\n        if (!this.operator) {\r\n            throw new Error(\"The Operator for an OfflineGame should be defined.\");\r\n        }\r\n        this.players.forEach((player) => player.status.__afterAllPlayersConstruction());\r\n\r\n        // =====================================\r\n        // CALL TO RESET\r\n        this.reset();\r\n        // =====================================\r\n\r\n        /* TODO.test This should be safe in a garbage-collection and\r\n        event-handler sense: Since the event handler is added to the\r\n        event-handler-list of the `.game-grid__impl-body` element as an\r\n        anonymous function, which makes it impossible to remove from\r\n        the list without a reference to that function. Luckily for us,\r\n        Grid.__VisibleGrid_super will automatically remove the old game-\r\n        grid__impl-body child, thus allowing it to be GC-ed, and its\r\n        event-handler function with it. */\r\n        this.grid.baseElem.addEventListener(\"keydown\", (ev): boolean => {\r\n            // console.log(`key: ${ev.key}, code: ${ev.code},`\r\n            // + ` keyCode: ${ev.keyCode}, char: ${ev.char},`\r\n            // + ` charCode: ${ev.charCode}`);\r\n            this.operator.processKeyboardInput(ev);\r\n            // Disable scroll-down via spacebar:\r\n            if (ev.keyCode === 32) {\r\n                ev.preventDefault();\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected __createOperatorPlayer(desc: Player.CtorArgs): OperatorPlayer<S> {\r\n        return new OperatorPlayer<S>(this, desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected __createArtifPlayer(desc: Player.CtorArgs): ArtificialPlayer<S> {\r\n        return ArtificialPlayer.of(this, desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public setTimeout(callback: TimerHandler, millis: number, ...args: any[]): number {\r\n        return setTimeout(callback, millis, args);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public cancelTimeout(handle: number): void {\r\n        clearTimeout(handle);\r\n    }\r\n}\r\nObject.freeze(OfflineGame);\r\nObject.freeze(OfflineGame.prototype);\r\n","import type { Coord } from \"floor/Coord\";\r\nimport type { GameManager } from \"game/__gameparts/Manager\";\r\n\r\nimport { Player } from \"game/player/Player\";\r\nimport { ArtificialPlayer } from \"../ArtificialPlayer\";\r\n\r\n\r\n/**\r\n *\r\n * @extends ArtificialPlayer\r\n */\r\n// TODO.impl\r\nexport class Chaser<S extends Coord.System> extends ArtificialPlayer<S> {\r\n\r\n    protected constructor(game: GameManager<any,S>, desc: Player.CtorArgs) {\r\n        super(game, desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected computeDesiredDestination(): Coord<S> {\r\n        //const humans = this.game.__players.HUMAN;\r\n        return undefined!;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected computeNextMovementTimer(): number {\r\n        return undefined!;\r\n    }\r\n}\r\nObject.freeze(Chaser);\r\nObject.freeze(Chaser.prototype);\r\n","require(\"../../assets/style/game/index.css\");\r\n\r\nimport { OmHooks }          from \"browser/OmHooks\";\r\nimport type { Coord }       from \"floor/Tile\";\r\nimport { Lang }             from \"utils/TypeDefs\";\r\nimport { OfflineGame }      from \"./OfflineGame\";\r\nimport { IndexTasks }       from \"game/IndexTasks\";\r\n\r\nIndexTasks.INIT_CLASS_REGISTRIES();\r\n\r\n// TODO.design override ctor args for each impl, and make it so they adapt input to pass to super ctor.\r\n// TODO.build this has been set to `var` for testing purposes. It should be `const` in production.\r\nexport const game = new OfflineGame<Coord.System.EUCLID2>({\r\n    coordSys: \"EUCLID2\" as Coord.System.EUCLID2,\r\n    gridDimensions: {\r\n        height: 21,\r\n        width:  21,\r\n    },\r\n    gridHtmlIdHook: OmHooks.Grid.Id.GRID,\r\n    averageFreeHealthPerTile: 1.0 / 45.0,\r\n    langBalancingScheme: Lang.BalancingScheme.WEIGHT,\r\n    languageName: \"engl-low\",\r\n    operatorIndex: 0,\r\n    playerDescs: [\r\n        {\r\n            familyId:   \"HUMAN\",\r\n            teamId:     0,\r\n            socketId:   undefined,\r\n            username:   \"hello world\",\r\n            noCheckGameOver: false,\r\n        },\r\n    ],\r\n});\r\n\r\n// Print some things:\r\n// console.log(game);\r\n// console.log(game.lang.simpleView());\r\n\r\ngame.statusBecomePlaying();\r\n"],"sourceRoot":""}