/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksnakey3"] = self["webpackChunksnakey3"] || []).push([["game/offline"],{

/***/ "./src/base/game/ScoreInfo.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScoreInfo\": () => /* binding */ ScoreInfo\n/* harmony export */ });\n/* harmony import */ var defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/defs/JsUtils.ts\");\n/* harmony import */ var defs_TypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/base/defs/TypeDefs.ts\");\n\r\n\r\n/**\r\n * Information about each Player's scores and statistics since the\r\n * last Game reset. This is separated from Player instances since\r\n * non-GameManagers have no need to maintain such records throughout\r\n * the game.\r\n */\r\nclass ScoreInfo {\r\n    constructor(playerIds) {\r\n        const entries = [];\r\n        for (const id of playerIds) {\r\n            entries[id] = new ScoreInfo.Entry();\r\n        }\r\n        this.entries = entries;\r\n        defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils.propNoWrite(this, [\"entries\"]);\r\n    }\r\n    reset() {\r\n        for (const entry of this.entries) {\r\n            entry.reset();\r\n        }\r\n    }\r\n}\r\n(function (ScoreInfo) {\r\n    /**\r\n     */\r\n    class Entry {\r\n        constructor() {\r\n            this.moveCounts = {}; // This will be initialized during reset.\r\n        }\r\n        reset() {\r\n            this.totalHealthPickedUp = 0.0;\r\n            Object.getOwnPropertyNames(defs_TypeDefs__WEBPACK_IMPORTED_MODULE_1__.Player.MoveType).forEach((key) => {\r\n                this.moveCounts[key] = 0;\r\n            });\r\n        }\r\n    }\r\n    ScoreInfo.Entry = Entry;\r\n    Object.freeze(Entry);\r\n    Object.freeze(Entry.prototype);\r\n})(ScoreInfo || (ScoreInfo = {}));\r\nObject.freeze(ScoreInfo);\r\nObject.freeze(ScoreInfo.prototype);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9nYW1lL1Njb3JlSW5mby50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3NuYWtleTMvLi9zcmMvYmFzZS9nYW1lL1Njb3JlSW5mby50cz9iZTRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEpzVXRpbHMgfSBmcm9tIFwiZGVmcy9Kc1V0aWxzXCI7XHJcbmltcG9ydCB7IFBsYXllciBhcyBfUGxheWVyIH0gZnJvbSBcImRlZnMvVHlwZURlZnNcIjtcclxuLyoqXHJcbiAqIEluZm9ybWF0aW9uIGFib3V0IGVhY2ggUGxheWVyJ3Mgc2NvcmVzIGFuZCBzdGF0aXN0aWNzIHNpbmNlIHRoZVxyXG4gKiBsYXN0IEdhbWUgcmVzZXQuIFRoaXMgaXMgc2VwYXJhdGVkIGZyb20gUGxheWVyIGluc3RhbmNlcyBzaW5jZVxyXG4gKiBub24tR2FtZU1hbmFnZXJzIGhhdmUgbm8gbmVlZCB0byBtYWludGFpbiBzdWNoIHJlY29yZHMgdGhyb3VnaG91dFxyXG4gKiB0aGUgZ2FtZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTY29yZUluZm8ge1xyXG4gICAgY29uc3RydWN0b3IocGxheWVySWRzKSB7XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgcGxheWVySWRzKSB7XHJcbiAgICAgICAgICAgIGVudHJpZXNbaWRdID0gbmV3IFNjb3JlSW5mby5FbnRyeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xyXG4gICAgICAgIEpzVXRpbHMucHJvcE5vV3JpdGUodGhpcywgW1wiZW50cmllc1wiXSk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcykge1xyXG4gICAgICAgICAgICBlbnRyeS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4oZnVuY3Rpb24gKFNjb3JlSW5mbykge1xyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIEVudHJ5IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlQ291bnRzID0ge307IC8vIFRoaXMgd2lsbCBiZSBpbml0aWFsaXplZCBkdXJpbmcgcmVzZXQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0KCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsSGVhbHRoUGlja2VkVXAgPSAwLjA7XHJcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKF9QbGF5ZXIuTW92ZVR5cGUpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ291bnRzW2tleV0gPSAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBTY29yZUluZm8uRW50cnkgPSBFbnRyeTtcclxuICAgIE9iamVjdC5mcmVlemUoRW50cnkpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShFbnRyeS5wcm90b3R5cGUpO1xyXG59KShTY29yZUluZm8gfHwgKFNjb3JlSW5mbyA9IHt9KSk7XHJcbk9iamVjdC5mcmVlemUoU2NvcmVJbmZvKTtcclxuT2JqZWN0LmZyZWV6ZShTY29yZUluZm8ucHJvdG90eXBlKTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/base/game/ScoreInfo.ts\n");

/***/ }),

/***/ "./src/base/game/ctormaps/CmapManager.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var floor_Grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/floor/Grid.ts\");\n/* harmony import */ var floor_impl_Euclid2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/base/floor/impl/Euclid2.ts\");\n/* harmony import */ var floor_impl_Beehive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/base/floor/impl/Beehive.ts\");\n/* harmony import */ var _player_ArtificialPlayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/base/game/player/ArtificialPlayer.ts\");\n/* harmony import */ var _player_artificials_Chaser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/base/game/player/artificials/Chaser.ts\");\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {\r\n    {\r\n        // Non-Visible Grid Implementation Registry:\r\n        floor_Grid__WEBPACK_IMPORTED_MODULE_0__.Grid._Constructors\r\n            = Object.freeze({\r\n                [\"EUCLID2\"]: floor_impl_Euclid2__WEBPACK_IMPORTED_MODULE_1__.Euclid2.Grid,\r\n                [\"BEEHIVE\"]: floor_impl_Beehive__WEBPACK_IMPORTED_MODULE_2__.Beehive.Grid,\r\n            });\r\n        Object.freeze(floor_Grid__WEBPACK_IMPORTED_MODULE_0__.Grid);\r\n        Object.freeze(floor_Grid__WEBPACK_IMPORTED_MODULE_0__.Grid.prototype);\r\n    }\r\n    {\r\n        const AP = _player_ArtificialPlayer__WEBPACK_IMPORTED_MODULE_3__.ArtificialPlayer;\r\n        AP._Constructors\r\n            = Object.freeze({\r\n                CHASER: _player_artificials_Chaser__WEBPACK_IMPORTED_MODULE_4__.Chaser,\r\n            });\r\n        Object.freeze(AP);\r\n        Object.freeze(AP.prototype);\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9nYW1lL2N0b3JtYXBzL0NtYXBNYW5hZ2VyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc25ha2V5My8uL3NyYy9iYXNlL2dhbWUvY3Rvcm1hcHMvQ21hcE1hbmFnZXIudHM/NTQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcmlkIH0gZnJvbSBcImZsb29yL0dyaWRcIjtcclxuaW1wb3J0IHsgRXVjbGlkMiB9IGZyb20gXCJmbG9vci9pbXBsL0V1Y2xpZDJcIjtcclxuaW1wb3J0IHsgQmVlaGl2ZSB9IGZyb20gXCJmbG9vci9pbXBsL0JlZWhpdmVcIjtcclxuaW1wb3J0IHsgQXJ0aWZpY2lhbFBsYXllciB9IGZyb20gXCIuLi9wbGF5ZXIvQXJ0aWZpY2lhbFBsYXllclwiO1xyXG5pbXBvcnQgeyBDaGFzZXIgfSBmcm9tIFwiLi4vcGxheWVyL2FydGlmaWNpYWxzL0NoYXNlclwiO1xyXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XHJcbiAgICB7XHJcbiAgICAgICAgLy8gTm9uLVZpc2libGUgR3JpZCBJbXBsZW1lbnRhdGlvbiBSZWdpc3RyeTpcclxuICAgICAgICBHcmlkLl9Db25zdHJ1Y3RvcnNcclxuICAgICAgICAgICAgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgICAgIFtcIkVVQ0xJRDJcIl06IEV1Y2xpZDIuR3JpZCxcclxuICAgICAgICAgICAgICAgIFtcIkJFRUhJVkVcIl06IEJlZWhpdmUuR3JpZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShHcmlkKTtcclxuICAgICAgICBPYmplY3QuZnJlZXplKEdyaWQucHJvdG90eXBlKTtcclxuICAgIH1cclxuICAgIHtcclxuICAgICAgICBjb25zdCBBUCA9IEFydGlmaWNpYWxQbGF5ZXI7XHJcbiAgICAgICAgQVAuX0NvbnN0cnVjdG9yc1xyXG4gICAgICAgICAgICA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgICAgICAgICAgQ0hBU0VSOiBDaGFzZXIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5mcmVlemUoQVApO1xyXG4gICAgICAgIE9iamVjdC5mcmVlemUoQVAucHJvdG90eXBlKTtcclxuICAgIH1cclxufTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/base/game/ctormaps/CmapManager.ts\n");

/***/ }),

/***/ "./src/base/game/gameparts/GamepartManager.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GamepartManager\": () => /* binding */ GamepartManager\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/defs/JsUtils.ts\");\n/* harmony import */ var lang_Lang__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/base/lang/Lang.ts\");\n/* harmony import */ var game_Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/base/game/Game.ts\");\n/* harmony import */ var floor_Coord__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./src/base/floor/Coord.ts\");\n/* harmony import */ var _player_Player__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./src/base/game/player/Player.ts\");\n/* harmony import */ var _player_ArtificialPlayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./src/base/game/player/ArtificialPlayer.ts\");\n/* harmony import */ var _ScoreInfo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./src/base/game/ScoreInfo.ts\");\n/* harmony import */ var _GamepartEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./src/base/game/gameparts/GamepartEvents.ts\");\n/* harmony import */ var game_ctormaps_CmapManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./src/base/game/ctormaps/CmapManager.ts\");\nvar _currentFreeHealth, _freeHealthTiles, _langImportPromise;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n // <- has side-effects.\r\n(0,game_ctormaps_CmapManager__WEBPACK_IMPORTED_MODULE_8__.default)();\r\n/**\r\n *\r\n */\r\nclass GamepartManager extends _GamepartEvents__WEBPACK_IMPORTED_MODULE_7__.GamepartEvents {\r\n    /**\r\n     * Performs the \"no invincible player\" check (See {@link Player#teamSet}).\r\n     *\r\n     * @param gameType -\r\n     * @param impl -\r\n     * @param desc -\r\n     */\r\n    constructor(gameType, impl, desc) {\r\n        super(gameType, impl, desc);\r\n        _currentFreeHealth.set(this, void 0);\r\n        _freeHealthTiles.set(this, void 0);\r\n        _langImportPromise.set(this, void 0);\r\n        this.averageFreeHealth = desc.averageFreeHealthPerTile * this.grid.area;\r\n        this.averageFreeHealthPerTile = desc.averageFreeHealthPerTile;\r\n        this.healthCostOfBoost = game_Game__WEBPACK_IMPORTED_MODULE_2__.Game.K.HEALTH_COST_OF_BOOST(this.averageFreeHealthPerTile, this.grid.static.getDiameterOfLatticePatchHavingArea);\r\n        (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldSet)(this, _freeHealthTiles, new Set());\r\n        this.scoreInfo = new _ScoreInfo__WEBPACK_IMPORTED_MODULE_6__.ScoreInfo(this.players.map((player) => player.playerId));\r\n        defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils.propNoWrite(this, [\r\n            \"averageFreeHealth\", \"averageFreeHealthPerTile\", \"healthCostOfBoost\", \"scoreInfo\",\r\n        ]);\r\n        // https://webpack.js.org/api/module-methods/#dynamic-expressions-in-import\r\n        (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldSet)(this, _langImportPromise, (__webpack_require__(\"./src/base/lang/impl lazy recursive ^\\\\.\\\\/.*\\\\.ts$\")(`./${this.langFrontend.module}.ts`)).then((langModule) => {\r\n            const LangConstructor = this.langFrontend.export.split(\".\").reduce((nsps, propName) => nsps[propName], langModule[this.langFrontend.module]);\r\n            // @ts-expect-error : RO=\r\n            this.lang = new LangConstructor(desc.langWeightExaggeration);\r\n            defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils.propNoWrite(this, [\"lang\"]);\r\n            // TODO.impl Enforce this in the UI code by greying out unusable combos of lang and coord-sys.\r\n            const minLangLeaves = this.grid.static.getAmbiguityThreshold();\r\n            if (this.lang.numLeaves < minLangLeaves) {\r\n                throw new Error(`Found ${this.lang.numLeaves} leaves, but at`\r\n                    + ` least ${minLangLeaves} were required. The provided mappings`\r\n                    + ` composing the current Lang-under-construction are not`\r\n                    + ` sufficient to ensure that a shuffling operation will always`\r\n                    + ` be able to find a safe candidate to use as a replacement.`\r\n                    + ` Please see the spec for Lang.getNonConflictingChar.`);\r\n            }\r\n            return this.lang;\r\n        }));\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    reset() {\r\n        const _super = Object.create(null, {\r\n            reset: { get: () => super.reset }\r\n        });\r\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {\r\n            // Reset the grid and event record:\r\n            yield _super.reset.call(this);\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldSet)(this, _currentFreeHealth, 0.0);\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _freeHealthTiles).clear();\r\n            // Reset hit-counters in the current language:\r\n            // This must be done before shuffling so that the previous\r\n            // history of shuffle-ins has no effects on the new pairs.\r\n            yield (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _langImportPromise);\r\n            this.lang.reset();\r\n            // Shuffle everything:\r\n            this.grid.shuffledForEachTile((tile) => {\r\n                tile.setLangCharSeqPair(this.dryRunShuffleLangCharSeqAt(tile));\r\n            });\r\n            // Reset and spawn players:\r\n            this.teams.forEach((team) => team.reset());\r\n            const spawnPoints = this.grid.static.getSpawnCoords(this.teams.map((team) => team.members.length), this.grid.dimensions);\r\n            this.teams.forEach((team, teamIndex) => {\r\n                team.members.forEach((member, memberIndex) => {\r\n                    member.reset(this.grid.tile.at(spawnPoints[teamIndex][memberIndex]));\r\n                });\r\n            });\r\n            this.scoreInfo.reset();\r\n            return Promise.resolve();\r\n        });\r\n    }\r\n    /**\r\n     * @override\r\n     */\r\n    _createArtifPlayer(desc) {\r\n        return _player_ArtificialPlayer__WEBPACK_IMPORTED_MODULE_5__.ArtificialPlayer.of(this, desc);\r\n    }\r\n    /**\r\n     * **Important:** Nullifies the existing values at `tile` and does\r\n     * not consume the returned values, which must be done externally.\r\n     *\r\n     * @param targetTile\r\n     * The {@link Tile} to shuffle their {@link Lang.CharSeqPair}\r\n     * pair for.\r\n     *\r\n     * @param doCheckEmptyTiles\r\n     * Pass `true` when populating a grid which has been reset.\r\n     *\r\n     * @returns\r\n     * A {@link Lang.CharSeqPair} that can be used as a replacement\r\n     * for that currently being used by `tile`.\r\n     */\r\n    dryRunShuffleLangCharSeqAt(targetTile, doCheckEmptyTiles = false) {\r\n        // First, clear values for the target tile so its current\r\n        // (to-be-previous) values don't get unnecessarily avoided.\r\n        targetTile.setLangCharSeqPair(lang_Lang__WEBPACK_IMPORTED_MODULE_1__.Lang.CharSeqPair.NULL);\r\n        let avoid = this.grid\r\n            .getDestsFromSourcesTo(targetTile.coord)\r\n            .map((tile) => tile.langSeq);\r\n        // ^ Note: An array of CharSeq from unique Tiles. It is okay\r\n        // for those tiles to include `targetTile`, and it is okay for\r\n        // those\r\n        if (doCheckEmptyTiles) {\r\n            const nullSeq = lang_Lang__WEBPACK_IMPORTED_MODULE_1__.Lang.CharSeqPair.NULL.seq;\r\n            avoid = avoid.filter((seq) => seq !== nullSeq);\r\n        }\r\n        return this.lang.getNonConflictingChar(avoid);\r\n    }\r\n    get currentFreeHealth() {\r\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _currentFreeHealth);\r\n    }\r\n    get freeHealthTiles() {\r\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _freeHealthTiles);\r\n    }\r\n    /**\r\n     * @returns\r\n     * A descriptor of changes to make to tiles regarding health spawning.\r\n     *\r\n     * **`IMPORTANT`**: This method does not have any override structure\r\n     * where the Server additionally notifies clients of the changes. It\r\n     * is intended to be wrapped inside other events with such behaviour.\r\n     *\r\n     * Note that this will seem to have a one-movement-event delay in\r\n     * specifying changes to be made because `this.currentFreeHealth`\r\n     * does not update until after the movement request has been\r\n     * executed.\r\n     *\r\n     * @param sameReqOtherModDescs\r\n     * A list of other descs including those specifying modifications\r\n     * to be made in the same `execute???Request` function as the one\r\n     * for which this is being called. Without this information, we\r\n     * could mess up `lastKnownUpdateId` counters at those locations.\r\n     */\r\n    dryRunSpawnFreeHealth(sameReqOtherModDescs) {\r\n        var _a;\r\n        let healthToSpawn = this.averageFreeHealth - this.currentFreeHealth;\r\n        if (healthToSpawn <= 0)\r\n            return undefined;\r\n        const retval = [];\r\n        while (healthToSpawn > 0) {\r\n            let tile;\r\n            do {\r\n                tile = this.grid.tile.at(this.grid.getRandomCoord());\r\n            } while ((() => {\r\n                return tile.isOccupied\r\n                    // The below equality check is necessary to prevent counting bugs.\r\n                    || retval.find((desc) => floor_Coord__WEBPACK_IMPORTED_MODULE_3__.Coord.equals(tile.coord, desc.coord));\r\n                // TODO.impl add other checks to improve distribution and reduce\r\n                // crowding of freeHealth. Make sure it is sensitive to\r\n                // `this.averageFreeHealthPerTile`.\r\n            })());\r\n            const tileHealthToAdd = game_Game__WEBPACK_IMPORTED_MODULE_2__.Game.K.AVERAGE_HEALTH_TO_SPAWN_ON_TILE;\r\n            if ((Math.random() < game_Game__WEBPACK_IMPORTED_MODULE_2__.Game.K.HEALTH_UPDATE_CHANCE)) {\r\n                let otherDesc;\r\n                if (otherDesc = sameReqOtherModDescs.find((desc) => floor_Coord__WEBPACK_IMPORTED_MODULE_3__.Coord.equals(tile.coord, desc.coord))) {\r\n                    otherDesc.newFreeHealth = ((_a = otherDesc.newFreeHealth) !== null && _a !== void 0 ? _a : 0) + tileHealthToAdd;\r\n                }\r\n                else {\r\n                    retval.push({\r\n                        coord: tile.coord,\r\n                        lastKnownUpdateId: 1 + tile.lastKnownUpdateId,\r\n                        newCharSeqPair: undefined,\r\n                        newFreeHealth: tile.freeHealth + tileHealthToAdd,\r\n                    });\r\n                }\r\n            }\r\n            healthToSpawn -= tileHealthToAdd;\r\n        }\r\n        return retval;\r\n    }\r\n    /**\r\n     * @override\r\n     */\r\n    executeTileModEvent(desc, doCheckOperatorSeqBuffer = true) {\r\n        Object.freeze(desc);\r\n        const tile = this.grid.tile.at(desc.coord);\r\n        // NOTE: This assertion must be performed before executing\r\n        // changes by making a supercall or else the previous state\r\n        // will be gone.\r\n        if (desc.lastKnownUpdateId !== (1 + tile.lastKnownUpdateId)) {\r\n            // We literally just specified this in processMoveRequest.\r\n            throw new RangeError(\"never\");\r\n        }\r\n        (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldSet)(this, _currentFreeHealth, (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _currentFreeHealth) + (desc.newFreeHealth - tile.freeHealth));\r\n        if (desc.newFreeHealth === 0) {\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _freeHealthTiles).delete(tile);\r\n        }\r\n        else {\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__classPrivateFieldGet)(this, _freeHealthTiles).add(tile);\r\n        }\r\n        super.executeTileModEvent(desc, doCheckOperatorSeqBuffer);\r\n        return tile;\r\n    }\r\n    /**\r\n     * Perform checks on an incoming event request for some action that\r\n     * a player can perform while the game is playing (ie. not paused\r\n     * or over).\r\n     *\r\n     * @param desc -\r\n     * @returns\r\n     * The player specified by the given ID, or undefined if the\r\n     * game is not playing, in which case the event request should\r\n     * be rejected.\r\n     *\r\n     * @throws\r\n     * `RangeError` if the request was made before receiving an\r\n     * acknowledgement for the previous request, or if the given ID\r\n     * does not belong to any existing player.\r\n     */\r\n    managerCheckGamePlayingRequest(desc) {\r\n        if (this.status !== game_Game__WEBPACK_IMPORTED_MODULE_2__.Game.Status.PLAYING) {\r\n            return undefined;\r\n        }\r\n        const player = this.players[desc.playerId];\r\n        if (!player) {\r\n            throw new Error(\"No such player exists.\");\r\n        }\r\n        if (desc.playerLastAcceptedRequestId !== player.lastAcceptedRequestId) {\r\n            throw new RangeError((desc.playerLastAcceptedRequestId < player.lastAcceptedRequestId)\r\n                ? (\"Clients should not make requests until they have\"\r\n                    + \" received my response to their last request.\")\r\n                : (\"Client seems to have incremented the request ID\"\r\n                    + \" counter on their own, which is is illegal.\"));\r\n        }\r\n        return player;\r\n    }\r\n    /**\r\n     * @see PlayerMovementEvent\r\n     *\r\n     * Reject the request if `dest` is occupied, or if the specified\r\n     * player does not exist, or the client is missing updates for the\r\n     * destination they requested to move to, or the player is bubbling.\r\n     *\r\n     * @param desc\r\n     * A descriptor of the request describing the requester's views\r\n     * of critical parts of the game-state from their copy of the game\r\n     * state at the time of the request. Is modified to describe changes\r\n     * to be made.\r\n     */\r\n    processMoveRequest(desc) {\r\n        const player = this.managerCheckGamePlayingRequest(desc);\r\n        if (!player) {\r\n            // Reject the request:\r\n            this.executePlayerMoveEvent(desc);\r\n            return;\r\n        }\r\n        const dest = this.grid.tile.at(desc.destModDesc.coord);\r\n        if (dest.isOccupied ||\r\n            dest.lastKnownUpdateId !== desc.destModDesc.lastKnownUpdateId) {\r\n            // The update ID check is not essential, but it helps\r\n            // enforce stronger client-experience consistency: they cannot\r\n            // move somewhere where they have not realized the `LangSeq` has\r\n            // changed.\r\n            this.executePlayerMoveEvent(desc); // Reject the request.\r\n            return;\r\n        }\r\n        const moveIsBoost = (desc.moveType === _player_Player__WEBPACK_IMPORTED_MODULE_4__.Player.MoveType.BOOST);\r\n        const newPlayerHealthValue = player.status.health\r\n            + (dest.freeHealth * (player.status.isDowned ? game_Game__WEBPACK_IMPORTED_MODULE_2__.Game.K.HEALTH_EFFECT_FOR_DOWNED_PLAYER : 1.0))\r\n            - (moveIsBoost ? this.healthCostOfBoost : 0);\r\n        if (moveIsBoost && newPlayerHealthValue < 0) {\r\n            // Reject a boost-type movement request if it would make\r\n            // the player become downed (or if they are already downed):\r\n            this.executePlayerMoveEvent(desc);\r\n            return;\r\n        }\r\n        // Update stats records:\r\n        const playerScoreInfo = this.scoreInfo.entries[player.playerId];\r\n        playerScoreInfo.totalHealthPickedUp += dest.freeHealth;\r\n        playerScoreInfo.moveCounts[desc.moveType] += 1;\r\n        // Set response fields according to spec in `PlayerMovementEvent`:\r\n        desc.playerLastAcceptedRequestId = (1 + player.lastAcceptedRequestId);\r\n        desc.newPlayerHealth = {\r\n            health: newPlayerHealthValue,\r\n        };\r\n        desc.destModDesc.lastKnownUpdateId = (1 + dest.lastKnownUpdateId);\r\n        desc.destModDesc.newFreeHealth = 0;\r\n        desc.destModDesc.newCharSeqPair = this.dryRunShuffleLangCharSeqAt(dest);\r\n        desc.tileHealthModDescs = this.dryRunSpawnFreeHealth([desc.destModDesc]);\r\n        // Accept the request, and trigger calculation\r\n        // and enactment of the requested changes:\r\n        desc.eventId = this.nextUnusedEventId;\r\n        this.executePlayerMoveEvent(desc);\r\n    }\r\n    processPlayerContact(sourceP) {\r\n        return undefined;\r\n    }\r\n    /**\r\n     * @see PlayerActionEvent.Bubble\r\n     * @param desc - Is modified to describe changes to be made.\r\n     */\r\n    processBubbleRequest(desc) {\r\n        // TODO.impl\r\n        // - If successful, make sure to lower the health field.\r\n        // - Make an abstract method in the OperatorPlayer class called in\r\n        //   the top-level input processor for it to trigger this event.\r\n        const bubbler = this.managerCheckGamePlayingRequest(desc);\r\n        if (!bubbler) {\r\n            // Reject the request:\r\n            this.executePlayerBubbleEvent(desc);\r\n            return;\r\n        }\r\n        desc.playerLastAcceptedRequestId = (1 + bubbler.lastAcceptedRequestId);\r\n        // We are all go! Do it.\r\n        desc.eventId = this.nextUnusedEventId;\r\n        this.executePlayerBubbleEvent(desc);\r\n    }\r\n}\r\n_currentFreeHealth = new WeakMap(), _freeHealthTiles = new WeakMap(), _langImportPromise = new WeakMap();\r\n(function (GamepartManager) {\r\n    /**\r\n     * If cleaning can be appropriately performed, this function will\r\n     * do so. If not, it will indicate invalidities in its return value.\r\n     */\r\n    function CHECK_VALID_CTOR_ARGS(args) {\r\n        const fr = [];\r\n        const requiredFields = Object.freeze({\r\n            coordSys: 0, gridDimensions: 0, averageFreeHealthPerTile: 0,\r\n            langId: 0, langWeightExaggeration: 0, playerDescs: 0,\r\n        });\r\n        const missingFields = [];\r\n        for (const fieldName in requiredFields) {\r\n            const field = args[fieldName];\r\n            if (field === undefined || field === null) {\r\n                missingFields.push(fieldName);\r\n            }\r\n        }\r\n        if (missingFields.length) {\r\n            fr.push(\"Missing the following arguments: \" + missingFields);\r\n        }\r\n        if (lang_Lang__WEBPACK_IMPORTED_MODULE_1__.Lang.GET_FRONTEND_DESC_BY_ID(args.langId) === undefined) {\r\n            fr.push(`No language with the ID \\`${args.langId}\\` exists.`);\r\n        }\r\n        if (parseInt(args.langWeightExaggeration) === NaN) {\r\n            fr.push(`Language Weight Exaggeration expected a number, but`\r\n                + `\\`${args.langWeightExaggeration}\\` is not a number.`);\r\n        }\r\n        else {\r\n            args.langWeightExaggeration = Math.max(0, parseFloat(args.langWeightExaggeration));\r\n        }\r\n        // TODO.impl check all the rest of the things.\r\n        // if (!(Player.Username.REGEXP.test(desc.username))) {\r\n        //     throw new RangeError(`Username \\\"${desc.username}\\\"`\r\n        //     + ` does not match the required regular expression,`\r\n        //     + ` \\\"${Player.Username.REGEXP.source}\\\".`\r\n        //     );\r\n        // }\r\n        return fr;\r\n    }\r\n    GamepartManager.CHECK_VALID_CTOR_ARGS = CHECK_VALID_CTOR_ARGS;\r\n})(GamepartManager || (GamepartManager = {}));\r\ndefs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils.protoNoEnum(GamepartManager, [\"managerCheckGamePlayingRequest\"]);\r\nObject.freeze(GamepartManager);\r\nObject.freeze(GamepartManager.prototype);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9nYW1lL2dhbWVwYXJ0cy9HYW1lcGFydE1hbmFnZXIudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbmFrZXkzLy4vc3JjL2Jhc2UvZ2FtZS9nYW1lcGFydHMvR2FtZXBhcnRNYW5hZ2VyLnRzPzg4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jdXJyZW50RnJlZUhlYWx0aCwgX2ZyZWVIZWFsdGhUaWxlcywgX2xhbmdJbXBvcnRQcm9taXNlO1xyXG5pbXBvcnQgeyBfX2F3YWl0ZXIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgSnNVdGlscyB9IGZyb20gXCJkZWZzL0pzVXRpbHNcIjtcclxuaW1wb3J0IHsgTGFuZyB9IGZyb20gXCJsYW5nL0xhbmdcIjtcclxuaW1wb3J0IHsgR2FtZSB9IGZyb20gXCJnYW1lL0dhbWVcIjtcclxuaW1wb3J0IHsgQ29vcmQgfSBmcm9tIFwiZmxvb3IvQ29vcmRcIjtcclxuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSBcIi4uL3BsYXllci9QbGF5ZXJcIjtcclxuaW1wb3J0IHsgQXJ0aWZpY2lhbFBsYXllciB9IGZyb20gXCIuLi9wbGF5ZXIvQXJ0aWZpY2lhbFBsYXllclwiO1xyXG5pbXBvcnQgeyBTY29yZUluZm8gfSBmcm9tIFwiLi4vU2NvcmVJbmZvXCI7XHJcbmltcG9ydCB7IEdhbWVwYXJ0RXZlbnRzLCB9IGZyb20gXCIuL0dhbWVwYXJ0RXZlbnRzXCI7XHJcbmltcG9ydCBJbml0R2FtZU1hbmFnZXJDdG9yTWFwcyBmcm9tIFwiZ2FtZS9jdG9ybWFwcy9DbWFwTWFuYWdlclwiOyAvLyA8LSBoYXMgc2lkZS1lZmZlY3RzLlxyXG5Jbml0R2FtZU1hbmFnZXJDdG9yTWFwcygpO1xyXG4vKipcclxuICpcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHYW1lcGFydE1hbmFnZXIgZXh0ZW5kcyBHYW1lcGFydEV2ZW50cyB7XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIHRoZSBcIm5vIGludmluY2libGUgcGxheWVyXCIgY2hlY2sgKFNlZSB7QGxpbmsgUGxheWVyI3RlYW1TZXR9KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2FtZVR5cGUgLVxyXG4gICAgICogQHBhcmFtIGltcGwgLVxyXG4gICAgICogQHBhcmFtIGRlc2MgLVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnYW1lVHlwZSwgaW1wbCwgZGVzYykge1xyXG4gICAgICAgIHN1cGVyKGdhbWVUeXBlLCBpbXBsLCBkZXNjKTtcclxuICAgICAgICBfY3VycmVudEZyZWVIZWFsdGguc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgX2ZyZWVIZWFsdGhUaWxlcy5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICBfbGFuZ0ltcG9ydFByb21pc2Uuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgdGhpcy5hdmVyYWdlRnJlZUhlYWx0aCA9IGRlc2MuYXZlcmFnZUZyZWVIZWFsdGhQZXJUaWxlICogdGhpcy5ncmlkLmFyZWE7XHJcbiAgICAgICAgdGhpcy5hdmVyYWdlRnJlZUhlYWx0aFBlclRpbGUgPSBkZXNjLmF2ZXJhZ2VGcmVlSGVhbHRoUGVyVGlsZTtcclxuICAgICAgICB0aGlzLmhlYWx0aENvc3RPZkJvb3N0ID0gR2FtZS5LLkhFQUxUSF9DT1NUX09GX0JPT1NUKHRoaXMuYXZlcmFnZUZyZWVIZWFsdGhQZXJUaWxlLCB0aGlzLmdyaWQuc3RhdGljLmdldERpYW1ldGVyT2ZMYXR0aWNlUGF0Y2hIYXZpbmdBcmVhKTtcclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9mcmVlSGVhbHRoVGlsZXMsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgdGhpcy5zY29yZUluZm8gPSBuZXcgU2NvcmVJbmZvKHRoaXMucGxheWVycy5tYXAoKHBsYXllcikgPT4gcGxheWVyLnBsYXllcklkKSk7XHJcbiAgICAgICAgSnNVdGlscy5wcm9wTm9Xcml0ZSh0aGlzLCBbXHJcbiAgICAgICAgICAgIFwiYXZlcmFnZUZyZWVIZWFsdGhcIiwgXCJhdmVyYWdlRnJlZUhlYWx0aFBlclRpbGVcIiwgXCJoZWFsdGhDb3N0T2ZCb29zdFwiLCBcInNjb3JlSW5mb1wiLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIC8vIGh0dHBzOi8vd2VicGFjay5qcy5vcmcvYXBpL21vZHVsZS1tZXRob2RzLyNkeW5hbWljLWV4cHJlc3Npb25zLWluLWltcG9ydFxyXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX2xhbmdJbXBvcnRQcm9taXNlLCAoaW1wb3J0KFxyXG4gICAgICAgIC8qIHdlYnBhY2tDaHVua05hbWU6IFwibGFuZy9bcmVxdWVzdF1cIiAqL1xyXG4gICAgICAgIGBsYW5nL2ltcGwvJHt0aGlzLmxhbmdGcm9udGVuZC5tb2R1bGV9LnRzYCkpLnRoZW4oKGxhbmdNb2R1bGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgTGFuZ0NvbnN0cnVjdG9yID0gdGhpcy5sYW5nRnJvbnRlbmQuZXhwb3J0LnNwbGl0KFwiLlwiKS5yZWR1Y2UoKG5zcHMsIHByb3BOYW1lKSA9PiBuc3BzW3Byb3BOYW1lXSwgbGFuZ01vZHVsZVt0aGlzLmxhbmdGcm9udGVuZC5tb2R1bGVdKTtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciA6IFJPPVxyXG4gICAgICAgICAgICB0aGlzLmxhbmcgPSBuZXcgTGFuZ0NvbnN0cnVjdG9yKGRlc2MubGFuZ1dlaWdodEV4YWdnZXJhdGlvbik7XHJcbiAgICAgICAgICAgIEpzVXRpbHMucHJvcE5vV3JpdGUodGhpcywgW1wibGFuZ1wiXSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8uaW1wbCBFbmZvcmNlIHRoaXMgaW4gdGhlIFVJIGNvZGUgYnkgZ3JleWluZyBvdXQgdW51c2FibGUgY29tYm9zIG9mIGxhbmcgYW5kIGNvb3JkLXN5cy5cclxuICAgICAgICAgICAgY29uc3QgbWluTGFuZ0xlYXZlcyA9IHRoaXMuZ3JpZC5zdGF0aWMuZ2V0QW1iaWd1aXR5VGhyZXNob2xkKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhbmcubnVtTGVhdmVzIDwgbWluTGFuZ0xlYXZlcykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCAke3RoaXMubGFuZy5udW1MZWF2ZXN9IGxlYXZlcywgYnV0IGF0YFxyXG4gICAgICAgICAgICAgICAgICAgICsgYCBsZWFzdCAke21pbkxhbmdMZWF2ZXN9IHdlcmUgcmVxdWlyZWQuIFRoZSBwcm92aWRlZCBtYXBwaW5nc2BcclxuICAgICAgICAgICAgICAgICAgICArIGAgY29tcG9zaW5nIHRoZSBjdXJyZW50IExhbmctdW5kZXItY29uc3RydWN0aW9uIGFyZSBub3RgXHJcbiAgICAgICAgICAgICAgICAgICAgKyBgIHN1ZmZpY2llbnQgdG8gZW5zdXJlIHRoYXQgYSBzaHVmZmxpbmcgb3BlcmF0aW9uIHdpbGwgYWx3YXlzYFxyXG4gICAgICAgICAgICAgICAgICAgICsgYCBiZSBhYmxlIHRvIGZpbmQgYSBzYWZlIGNhbmRpZGF0ZSB0byB1c2UgYXMgYSByZXBsYWNlbWVudC5gXHJcbiAgICAgICAgICAgICAgICAgICAgKyBgIFBsZWFzZSBzZWUgdGhlIHNwZWMgZm9yIExhbmcuZ2V0Tm9uQ29uZmxpY3RpbmdDaGFyLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmc7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgcmVzZXQ6IHsgZ2V0OiAoKSA9PiBzdXBlci5yZXNldCB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGdyaWQgYW5kIGV2ZW50IHJlY29yZDpcclxuICAgICAgICAgICAgeWllbGQgX3N1cGVyLnJlc2V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX2N1cnJlbnRGcmVlSGVhbHRoLCAwLjApO1xyXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9mcmVlSGVhbHRoVGlsZXMpLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGhpdC1jb3VudGVycyBpbiB0aGUgY3VycmVudCBsYW5ndWFnZTpcclxuICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHNodWZmbGluZyBzbyB0aGF0IHRoZSBwcmV2aW91c1xyXG4gICAgICAgICAgICAvLyBoaXN0b3J5IG9mIHNodWZmbGUtaW5zIGhhcyBubyBlZmZlY3RzIG9uIHRoZSBuZXcgcGFpcnMuXHJcbiAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2xhbmdJbXBvcnRQcm9taXNlKTtcclxuICAgICAgICAgICAgdGhpcy5sYW5nLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIC8vIFNodWZmbGUgZXZlcnl0aGluZzpcclxuICAgICAgICAgICAgdGhpcy5ncmlkLnNodWZmbGVkRm9yRWFjaFRpbGUoKHRpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRpbGUuc2V0TGFuZ0NoYXJTZXFQYWlyKHRoaXMuZHJ5UnVuU2h1ZmZsZUxhbmdDaGFyU2VxQXQodGlsZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gUmVzZXQgYW5kIHNwYXduIHBsYXllcnM6XHJcbiAgICAgICAgICAgIHRoaXMudGVhbXMuZm9yRWFjaCgodGVhbSkgPT4gdGVhbS5yZXNldCgpKTtcclxuICAgICAgICAgICAgY29uc3Qgc3Bhd25Qb2ludHMgPSB0aGlzLmdyaWQuc3RhdGljLmdldFNwYXduQ29vcmRzKHRoaXMudGVhbXMubWFwKCh0ZWFtKSA9PiB0ZWFtLm1lbWJlcnMubGVuZ3RoKSwgdGhpcy5ncmlkLmRpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLnRlYW1zLmZvckVhY2goKHRlYW0sIHRlYW1JbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGVhbS5tZW1iZXJzLmZvckVhY2goKG1lbWJlciwgbWVtYmVySW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXIucmVzZXQodGhpcy5ncmlkLnRpbGUuYXQoc3Bhd25Qb2ludHNbdGVhbUluZGV4XVttZW1iZXJJbmRleF0pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zY29yZUluZm8ucmVzZXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgX2NyZWF0ZUFydGlmUGxheWVyKGRlc2MpIHtcclxuICAgICAgICByZXR1cm4gQXJ0aWZpY2lhbFBsYXllci5vZih0aGlzLCBkZXNjKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogKipJbXBvcnRhbnQ6KiogTnVsbGlmaWVzIHRoZSBleGlzdGluZyB2YWx1ZXMgYXQgYHRpbGVgIGFuZCBkb2VzXHJcbiAgICAgKiBub3QgY29uc3VtZSB0aGUgcmV0dXJuZWQgdmFsdWVzLCB3aGljaCBtdXN0IGJlIGRvbmUgZXh0ZXJuYWxseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0VGlsZVxyXG4gICAgICogVGhlIHtAbGluayBUaWxlfSB0byBzaHVmZmxlIHRoZWlyIHtAbGluayBMYW5nLkNoYXJTZXFQYWlyfVxyXG4gICAgICogcGFpciBmb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvQ2hlY2tFbXB0eVRpbGVzXHJcbiAgICAgKiBQYXNzIGB0cnVlYCB3aGVuIHBvcHVsYXRpbmcgYSBncmlkIHdoaWNoIGhhcyBiZWVuIHJlc2V0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKiBBIHtAbGluayBMYW5nLkNoYXJTZXFQYWlyfSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcmVwbGFjZW1lbnRcclxuICAgICAqIGZvciB0aGF0IGN1cnJlbnRseSBiZWluZyB1c2VkIGJ5IGB0aWxlYC5cclxuICAgICAqL1xyXG4gICAgZHJ5UnVuU2h1ZmZsZUxhbmdDaGFyU2VxQXQodGFyZ2V0VGlsZSwgZG9DaGVja0VtcHR5VGlsZXMgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIEZpcnN0LCBjbGVhciB2YWx1ZXMgZm9yIHRoZSB0YXJnZXQgdGlsZSBzbyBpdHMgY3VycmVudFxyXG4gICAgICAgIC8vICh0by1iZS1wcmV2aW91cykgdmFsdWVzIGRvbid0IGdldCB1bm5lY2Vzc2FyaWx5IGF2b2lkZWQuXHJcbiAgICAgICAgdGFyZ2V0VGlsZS5zZXRMYW5nQ2hhclNlcVBhaXIoTGFuZy5DaGFyU2VxUGFpci5OVUxMKTtcclxuICAgICAgICBsZXQgYXZvaWQgPSB0aGlzLmdyaWRcclxuICAgICAgICAgICAgLmdldERlc3RzRnJvbVNvdXJjZXNUbyh0YXJnZXRUaWxlLmNvb3JkKVxyXG4gICAgICAgICAgICAubWFwKCh0aWxlKSA9PiB0aWxlLmxhbmdTZXEpO1xyXG4gICAgICAgIC8vIF4gTm90ZTogQW4gYXJyYXkgb2YgQ2hhclNlcSBmcm9tIHVuaXF1ZSBUaWxlcy4gSXQgaXMgb2theVxyXG4gICAgICAgIC8vIGZvciB0aG9zZSB0aWxlcyB0byBpbmNsdWRlIGB0YXJnZXRUaWxlYCwgYW5kIGl0IGlzIG9rYXkgZm9yXHJcbiAgICAgICAgLy8gdGhvc2VcclxuICAgICAgICBpZiAoZG9DaGVja0VtcHR5VGlsZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbnVsbFNlcSA9IExhbmcuQ2hhclNlcVBhaXIuTlVMTC5zZXE7XHJcbiAgICAgICAgICAgIGF2b2lkID0gYXZvaWQuZmlsdGVyKChzZXEpID0+IHNlcSAhPT0gbnVsbFNlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhbmcuZ2V0Tm9uQ29uZmxpY3RpbmdDaGFyKGF2b2lkKTtcclxuICAgIH1cclxuICAgIGdldCBjdXJyZW50RnJlZUhlYWx0aCgpIHtcclxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY3VycmVudEZyZWVIZWFsdGgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZyZWVIZWFsdGhUaWxlcygpIHtcclxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZnJlZUhlYWx0aFRpbGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqIEEgZGVzY3JpcHRvciBvZiBjaGFuZ2VzIHRvIG1ha2UgdG8gdGlsZXMgcmVnYXJkaW5nIGhlYWx0aCBzcGF3bmluZy5cclxuICAgICAqXHJcbiAgICAgKiAqKmBJTVBPUlRBTlRgKio6IFRoaXMgbWV0aG9kIGRvZXMgbm90IGhhdmUgYW55IG92ZXJyaWRlIHN0cnVjdHVyZVxyXG4gICAgICogd2hlcmUgdGhlIFNlcnZlciBhZGRpdGlvbmFsbHkgbm90aWZpZXMgY2xpZW50cyBvZiB0aGUgY2hhbmdlcy4gSXRcclxuICAgICAqIGlzIGludGVuZGVkIHRvIGJlIHdyYXBwZWQgaW5zaWRlIG90aGVyIGV2ZW50cyB3aXRoIHN1Y2ggYmVoYXZpb3VyLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2VlbSB0byBoYXZlIGEgb25lLW1vdmVtZW50LWV2ZW50IGRlbGF5IGluXHJcbiAgICAgKiBzcGVjaWZ5aW5nIGNoYW5nZXMgdG8gYmUgbWFkZSBiZWNhdXNlIGB0aGlzLmN1cnJlbnRGcmVlSGVhbHRoYFxyXG4gICAgICogZG9lcyBub3QgdXBkYXRlIHVudGlsIGFmdGVyIHRoZSBtb3ZlbWVudCByZXF1ZXN0IGhhcyBiZWVuXHJcbiAgICAgKiBleGVjdXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2FtZVJlcU90aGVyTW9kRGVzY3NcclxuICAgICAqIEEgbGlzdCBvZiBvdGhlciBkZXNjcyBpbmNsdWRpbmcgdGhvc2Ugc3BlY2lmeWluZyBtb2RpZmljYXRpb25zXHJcbiAgICAgKiB0byBiZSBtYWRlIGluIHRoZSBzYW1lIGBleGVjdXRlPz8/UmVxdWVzdGAgZnVuY3Rpb24gYXMgdGhlIG9uZVxyXG4gICAgICogZm9yIHdoaWNoIHRoaXMgaXMgYmVpbmcgY2FsbGVkLiBXaXRob3V0IHRoaXMgaW5mb3JtYXRpb24sIHdlXHJcbiAgICAgKiBjb3VsZCBtZXNzIHVwIGBsYXN0S25vd25VcGRhdGVJZGAgY291bnRlcnMgYXQgdGhvc2UgbG9jYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBkcnlSdW5TcGF3bkZyZWVIZWFsdGgoc2FtZVJlcU90aGVyTW9kRGVzY3MpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IGhlYWx0aFRvU3Bhd24gPSB0aGlzLmF2ZXJhZ2VGcmVlSGVhbHRoIC0gdGhpcy5jdXJyZW50RnJlZUhlYWx0aDtcclxuICAgICAgICBpZiAoaGVhbHRoVG9TcGF3biA8PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHJldHZhbCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChoZWFsdGhUb1NwYXduID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgdGlsZTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdGlsZSA9IHRoaXMuZ3JpZC50aWxlLmF0KHRoaXMuZ3JpZC5nZXRSYW5kb21Db29yZCgpKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlLmlzT2NjdXBpZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmVsb3cgZXF1YWxpdHkgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgY291bnRpbmcgYnVncy5cclxuICAgICAgICAgICAgICAgICAgICB8fCByZXR2YWwuZmluZCgoZGVzYykgPT4gQ29vcmQuZXF1YWxzKHRpbGUuY29vcmQsIGRlc2MuY29vcmQpKTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8uaW1wbCBhZGQgb3RoZXIgY2hlY2tzIHRvIGltcHJvdmUgZGlzdHJpYnV0aW9uIGFuZCByZWR1Y2VcclxuICAgICAgICAgICAgICAgIC8vIGNyb3dkaW5nIG9mIGZyZWVIZWFsdGguIE1ha2Ugc3VyZSBpdCBpcyBzZW5zaXRpdmUgdG9cclxuICAgICAgICAgICAgICAgIC8vIGB0aGlzLmF2ZXJhZ2VGcmVlSGVhbHRoUGVyVGlsZWAuXHJcbiAgICAgICAgICAgIH0pKCkpO1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlSGVhbHRoVG9BZGQgPSBHYW1lLksuQVZFUkFHRV9IRUFMVEhfVE9fU1BBV05fT05fVElMRTtcclxuICAgICAgICAgICAgaWYgKChNYXRoLnJhbmRvbSgpIDwgR2FtZS5LLkhFQUxUSF9VUERBVEVfQ0hBTkNFKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG90aGVyRGVzYztcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlckRlc2MgPSBzYW1lUmVxT3RoZXJNb2REZXNjcy5maW5kKChkZXNjKSA9PiBDb29yZC5lcXVhbHModGlsZS5jb29yZCwgZGVzYy5jb29yZCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJEZXNjLm5ld0ZyZWVIZWFsdGggPSAoKF9hID0gb3RoZXJEZXNjLm5ld0ZyZWVIZWFsdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICsgdGlsZUhlYWx0aFRvQWRkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZDogdGlsZS5jb29yZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duVXBkYXRlSWQ6IDEgKyB0aWxlLmxhc3RLbm93blVwZGF0ZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGFyU2VxUGFpcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGcmVlSGVhbHRoOiB0aWxlLmZyZWVIZWFsdGggKyB0aWxlSGVhbHRoVG9BZGQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGVhbHRoVG9TcGF3biAtPSB0aWxlSGVhbHRoVG9BZGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBleGVjdXRlVGlsZU1vZEV2ZW50KGRlc2MsIGRvQ2hlY2tPcGVyYXRvclNlcUJ1ZmZlciA9IHRydWUpIHtcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlc2MpO1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLmdyaWQudGlsZS5hdChkZXNjLmNvb3JkKTtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIGFzc2VydGlvbiBtdXN0IGJlIHBlcmZvcm1lZCBiZWZvcmUgZXhlY3V0aW5nXHJcbiAgICAgICAgLy8gY2hhbmdlcyBieSBtYWtpbmcgYSBzdXBlcmNhbGwgb3IgZWxzZSB0aGUgcHJldmlvdXMgc3RhdGVcclxuICAgICAgICAvLyB3aWxsIGJlIGdvbmUuXHJcbiAgICAgICAgaWYgKGRlc2MubGFzdEtub3duVXBkYXRlSWQgIT09ICgxICsgdGlsZS5sYXN0S25vd25VcGRhdGVJZCkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbGl0ZXJhbGx5IGp1c3Qgc3BlY2lmaWVkIHRoaXMgaW4gcHJvY2Vzc01vdmVSZXF1ZXN0LlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm5ldmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9jdXJyZW50RnJlZUhlYWx0aCwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY3VycmVudEZyZWVIZWFsdGgpICsgKGRlc2MubmV3RnJlZUhlYWx0aCAtIHRpbGUuZnJlZUhlYWx0aCkpO1xyXG4gICAgICAgIGlmIChkZXNjLm5ld0ZyZWVIZWFsdGggPT09IDApIHtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZnJlZUhlYWx0aFRpbGVzKS5kZWxldGUodGlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9mcmVlSGVhbHRoVGlsZXMpLmFkZCh0aWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuZXhlY3V0ZVRpbGVNb2RFdmVudChkZXNjLCBkb0NoZWNrT3BlcmF0b3JTZXFCdWZmZXIpO1xyXG4gICAgICAgIHJldHVybiB0aWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGNoZWNrcyBvbiBhbiBpbmNvbWluZyBldmVudCByZXF1ZXN0IGZvciBzb21lIGFjdGlvbiB0aGF0XHJcbiAgICAgKiBhIHBsYXllciBjYW4gcGVyZm9ybSB3aGlsZSB0aGUgZ2FtZSBpcyBwbGF5aW5nIChpZS4gbm90IHBhdXNlZFxyXG4gICAgICogb3Igb3ZlcikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlc2MgLVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqIFRoZSBwbGF5ZXIgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBJRCwgb3IgdW5kZWZpbmVkIGlmIHRoZVxyXG4gICAgICogZ2FtZSBpcyBub3QgcGxheWluZywgaW4gd2hpY2ggY2FzZSB0aGUgZXZlbnQgcmVxdWVzdCBzaG91bGRcclxuICAgICAqIGJlIHJlamVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3NcclxuICAgICAqIGBSYW5nZUVycm9yYCBpZiB0aGUgcmVxdWVzdCB3YXMgbWFkZSBiZWZvcmUgcmVjZWl2aW5nIGFuXHJcbiAgICAgKiBhY2tub3dsZWRnZW1lbnQgZm9yIHRoZSBwcmV2aW91cyByZXF1ZXN0LCBvciBpZiB0aGUgZ2l2ZW4gSURcclxuICAgICAqIGRvZXMgbm90IGJlbG9uZyB0byBhbnkgZXhpc3RpbmcgcGxheWVyLlxyXG4gICAgICovXHJcbiAgICBtYW5hZ2VyQ2hlY2tHYW1lUGxheWluZ1JlcXVlc3QoZGVzYykge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gR2FtZS5TdGF0dXMuUExBWUlORykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnBsYXllcnNbZGVzYy5wbGF5ZXJJZF07XHJcbiAgICAgICAgaWYgKCFwbGF5ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBwbGF5ZXIgZXhpc3RzLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2MucGxheWVyTGFzdEFjY2VwdGVkUmVxdWVzdElkICE9PSBwbGF5ZXIubGFzdEFjY2VwdGVkUmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKChkZXNjLnBsYXllckxhc3RBY2NlcHRlZFJlcXVlc3RJZCA8IHBsYXllci5sYXN0QWNjZXB0ZWRSZXF1ZXN0SWQpXHJcbiAgICAgICAgICAgICAgICA/IChcIkNsaWVudHMgc2hvdWxkIG5vdCBtYWtlIHJlcXVlc3RzIHVudGlsIHRoZXkgaGF2ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiByZWNlaXZlZCBteSByZXNwb25zZSB0byB0aGVpciBsYXN0IHJlcXVlc3QuXCIpXHJcbiAgICAgICAgICAgICAgICA6IChcIkNsaWVudCBzZWVtcyB0byBoYXZlIGluY3JlbWVudGVkIHRoZSByZXF1ZXN0IElEXCJcclxuICAgICAgICAgICAgICAgICAgICArIFwiIGNvdW50ZXIgb24gdGhlaXIgb3duLCB3aGljaCBpcyBpcyBpbGxlZ2FsLlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbGF5ZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBzZWUgUGxheWVyTW92ZW1lbnRFdmVudFxyXG4gICAgICpcclxuICAgICAqIFJlamVjdCB0aGUgcmVxdWVzdCBpZiBgZGVzdGAgaXMgb2NjdXBpZWQsIG9yIGlmIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIHBsYXllciBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGNsaWVudCBpcyBtaXNzaW5nIHVwZGF0ZXMgZm9yIHRoZVxyXG4gICAgICogZGVzdGluYXRpb24gdGhleSByZXF1ZXN0ZWQgdG8gbW92ZSB0bywgb3IgdGhlIHBsYXllciBpcyBidWJibGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGVzY1xyXG4gICAgICogQSBkZXNjcmlwdG9yIG9mIHRoZSByZXF1ZXN0IGRlc2NyaWJpbmcgdGhlIHJlcXVlc3RlcidzIHZpZXdzXHJcbiAgICAgKiBvZiBjcml0aWNhbCBwYXJ0cyBvZiB0aGUgZ2FtZS1zdGF0ZSBmcm9tIHRoZWlyIGNvcHkgb2YgdGhlIGdhbWVcclxuICAgICAqIHN0YXRlIGF0IHRoZSB0aW1lIG9mIHRoZSByZXF1ZXN0LiBJcyBtb2RpZmllZCB0byBkZXNjcmliZSBjaGFuZ2VzXHJcbiAgICAgKiB0byBiZSBtYWRlLlxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzTW92ZVJlcXVlc3QoZGVzYykge1xyXG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMubWFuYWdlckNoZWNrR2FtZVBsYXlpbmdSZXF1ZXN0KGRlc2MpO1xyXG4gICAgICAgIGlmICghcGxheWVyKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCB0aGUgcmVxdWVzdDpcclxuICAgICAgICAgICAgdGhpcy5leGVjdXRlUGxheWVyTW92ZUV2ZW50KGRlc2MpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLmdyaWQudGlsZS5hdChkZXNjLmRlc3RNb2REZXNjLmNvb3JkKTtcclxuICAgICAgICBpZiAoZGVzdC5pc09jY3VwaWVkIHx8XHJcbiAgICAgICAgICAgIGRlc3QubGFzdEtub3duVXBkYXRlSWQgIT09IGRlc2MuZGVzdE1vZERlc2MubGFzdEtub3duVXBkYXRlSWQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSBJRCBjaGVjayBpcyBub3QgZXNzZW50aWFsLCBidXQgaXQgaGVscHNcclxuICAgICAgICAgICAgLy8gZW5mb3JjZSBzdHJvbmdlciBjbGllbnQtZXhwZXJpZW5jZSBjb25zaXN0ZW5jeTogdGhleSBjYW5ub3RcclxuICAgICAgICAgICAgLy8gbW92ZSBzb21ld2hlcmUgd2hlcmUgdGhleSBoYXZlIG5vdCByZWFsaXplZCB0aGUgYExhbmdTZXFgIGhhc1xyXG4gICAgICAgICAgICAvLyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVQbGF5ZXJNb3ZlRXZlbnQoZGVzYyk7IC8vIFJlamVjdCB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb3ZlSXNCb29zdCA9IChkZXNjLm1vdmVUeXBlID09PSBQbGF5ZXIuTW92ZVR5cGUuQk9PU1QpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BsYXllckhlYWx0aFZhbHVlID0gcGxheWVyLnN0YXR1cy5oZWFsdGhcclxuICAgICAgICAgICAgKyAoZGVzdC5mcmVlSGVhbHRoICogKHBsYXllci5zdGF0dXMuaXNEb3duZWQgPyBHYW1lLksuSEVBTFRIX0VGRkVDVF9GT1JfRE9XTkVEX1BMQVlFUiA6IDEuMCkpXHJcbiAgICAgICAgICAgIC0gKG1vdmVJc0Jvb3N0ID8gdGhpcy5oZWFsdGhDb3N0T2ZCb29zdCA6IDApO1xyXG4gICAgICAgIGlmIChtb3ZlSXNCb29zdCAmJiBuZXdQbGF5ZXJIZWFsdGhWYWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IGEgYm9vc3QtdHlwZSBtb3ZlbWVudCByZXF1ZXN0IGlmIGl0IHdvdWxkIG1ha2VcclxuICAgICAgICAgICAgLy8gdGhlIHBsYXllciBiZWNvbWUgZG93bmVkIChvciBpZiB0aGV5IGFyZSBhbHJlYWR5IGRvd25lZCk6XHJcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVBsYXllck1vdmVFdmVudChkZXNjKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgc3RhdHMgcmVjb3JkczpcclxuICAgICAgICBjb25zdCBwbGF5ZXJTY29yZUluZm8gPSB0aGlzLnNjb3JlSW5mby5lbnRyaWVzW3BsYXllci5wbGF5ZXJJZF07XHJcbiAgICAgICAgcGxheWVyU2NvcmVJbmZvLnRvdGFsSGVhbHRoUGlja2VkVXAgKz0gZGVzdC5mcmVlSGVhbHRoO1xyXG4gICAgICAgIHBsYXllclNjb3JlSW5mby5tb3ZlQ291bnRzW2Rlc2MubW92ZVR5cGVdICs9IDE7XHJcbiAgICAgICAgLy8gU2V0IHJlc3BvbnNlIGZpZWxkcyBhY2NvcmRpbmcgdG8gc3BlYyBpbiBgUGxheWVyTW92ZW1lbnRFdmVudGA6XHJcbiAgICAgICAgZGVzYy5wbGF5ZXJMYXN0QWNjZXB0ZWRSZXF1ZXN0SWQgPSAoMSArIHBsYXllci5sYXN0QWNjZXB0ZWRSZXF1ZXN0SWQpO1xyXG4gICAgICAgIGRlc2MubmV3UGxheWVySGVhbHRoID0ge1xyXG4gICAgICAgICAgICBoZWFsdGg6IG5ld1BsYXllckhlYWx0aFZhbHVlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVzYy5kZXN0TW9kRGVzYy5sYXN0S25vd25VcGRhdGVJZCA9ICgxICsgZGVzdC5sYXN0S25vd25VcGRhdGVJZCk7XHJcbiAgICAgICAgZGVzYy5kZXN0TW9kRGVzYy5uZXdGcmVlSGVhbHRoID0gMDtcclxuICAgICAgICBkZXNjLmRlc3RNb2REZXNjLm5ld0NoYXJTZXFQYWlyID0gdGhpcy5kcnlSdW5TaHVmZmxlTGFuZ0NoYXJTZXFBdChkZXN0KTtcclxuICAgICAgICBkZXNjLnRpbGVIZWFsdGhNb2REZXNjcyA9IHRoaXMuZHJ5UnVuU3Bhd25GcmVlSGVhbHRoKFtkZXNjLmRlc3RNb2REZXNjXSk7XHJcbiAgICAgICAgLy8gQWNjZXB0IHRoZSByZXF1ZXN0LCBhbmQgdHJpZ2dlciBjYWxjdWxhdGlvblxyXG4gICAgICAgIC8vIGFuZCBlbmFjdG1lbnQgb2YgdGhlIHJlcXVlc3RlZCBjaGFuZ2VzOlxyXG4gICAgICAgIGRlc2MuZXZlbnRJZCA9IHRoaXMubmV4dFVudXNlZEV2ZW50SWQ7XHJcbiAgICAgICAgdGhpcy5leGVjdXRlUGxheWVyTW92ZUV2ZW50KGRlc2MpO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BsYXllckNvbnRhY3Qoc291cmNlUCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBzZWUgUGxheWVyQWN0aW9uRXZlbnQuQnViYmxlXHJcbiAgICAgKiBAcGFyYW0gZGVzYyAtIElzIG1vZGlmaWVkIHRvIGRlc2NyaWJlIGNoYW5nZXMgdG8gYmUgbWFkZS5cclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0J1YmJsZVJlcXVlc3QoZGVzYykge1xyXG4gICAgICAgIC8vIFRPRE8uaW1wbFxyXG4gICAgICAgIC8vIC0gSWYgc3VjY2Vzc2Z1bCwgbWFrZSBzdXJlIHRvIGxvd2VyIHRoZSBoZWFsdGggZmllbGQuXHJcbiAgICAgICAgLy8gLSBNYWtlIGFuIGFic3RyYWN0IG1ldGhvZCBpbiB0aGUgT3BlcmF0b3JQbGF5ZXIgY2xhc3MgY2FsbGVkIGluXHJcbiAgICAgICAgLy8gICB0aGUgdG9wLWxldmVsIGlucHV0IHByb2Nlc3NvciBmb3IgaXQgdG8gdHJpZ2dlciB0aGlzIGV2ZW50LlxyXG4gICAgICAgIGNvbnN0IGJ1YmJsZXIgPSB0aGlzLm1hbmFnZXJDaGVja0dhbWVQbGF5aW5nUmVxdWVzdChkZXNjKTtcclxuICAgICAgICBpZiAoIWJ1YmJsZXIpIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IHRoZSByZXF1ZXN0OlxyXG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVQbGF5ZXJCdWJibGVFdmVudChkZXNjKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXNjLnBsYXllckxhc3RBY2NlcHRlZFJlcXVlc3RJZCA9ICgxICsgYnViYmxlci5sYXN0QWNjZXB0ZWRSZXF1ZXN0SWQpO1xyXG4gICAgICAgIC8vIFdlIGFyZSBhbGwgZ28hIERvIGl0LlxyXG4gICAgICAgIGRlc2MuZXZlbnRJZCA9IHRoaXMubmV4dFVudXNlZEV2ZW50SWQ7XHJcbiAgICAgICAgdGhpcy5leGVjdXRlUGxheWVyQnViYmxlRXZlbnQoZGVzYyk7XHJcbiAgICB9XHJcbn1cclxuX2N1cnJlbnRGcmVlSGVhbHRoID0gbmV3IFdlYWtNYXAoKSwgX2ZyZWVIZWFsdGhUaWxlcyA9IG5ldyBXZWFrTWFwKCksIF9sYW5nSW1wb3J0UHJvbWlzZSA9IG5ldyBXZWFrTWFwKCk7XHJcbihmdW5jdGlvbiAoR2FtZXBhcnRNYW5hZ2VyKSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIGNsZWFuaW5nIGNhbiBiZSBhcHByb3ByaWF0ZWx5IHBlcmZvcm1lZCwgdGhpcyBmdW5jdGlvbiB3aWxsXHJcbiAgICAgKiBkbyBzby4gSWYgbm90LCBpdCB3aWxsIGluZGljYXRlIGludmFsaWRpdGllcyBpbiBpdHMgcmV0dXJuIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDSEVDS19WQUxJRF9DVE9SX0FSR1MoYXJncykge1xyXG4gICAgICAgIGNvbnN0IGZyID0gW107XHJcbiAgICAgICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgY29vcmRTeXM6IDAsIGdyaWREaW1lbnNpb25zOiAwLCBhdmVyYWdlRnJlZUhlYWx0aFBlclRpbGU6IDAsXHJcbiAgICAgICAgICAgIGxhbmdJZDogMCwgbGFuZ1dlaWdodEV4YWdnZXJhdGlvbjogMCwgcGxheWVyRGVzY3M6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbWlzc2luZ0ZpZWxkcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIGluIHJlcXVpcmVkRmllbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gYXJnc1tmaWVsZE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCB8fCBmaWVsZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbWlzc2luZ0ZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pc3NpbmdGaWVsZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZyLnB1c2goXCJNaXNzaW5nIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOiBcIiArIG1pc3NpbmdGaWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTGFuZy5HRVRfRlJPTlRFTkRfREVTQ19CWV9JRChhcmdzLmxhbmdJZCkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBmci5wdXNoKGBObyBsYW5ndWFnZSB3aXRoIHRoZSBJRCBcXGAke2FyZ3MubGFuZ0lkfVxcYCBleGlzdHMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJzZUludChhcmdzLmxhbmdXZWlnaHRFeGFnZ2VyYXRpb24pID09PSBOYU4pIHtcclxuICAgICAgICAgICAgZnIucHVzaChgTGFuZ3VhZ2UgV2VpZ2h0IEV4YWdnZXJhdGlvbiBleHBlY3RlZCBhIG51bWJlciwgYnV0YFxyXG4gICAgICAgICAgICAgICAgKyBgXFxgJHthcmdzLmxhbmdXZWlnaHRFeGFnZ2VyYXRpb259XFxgIGlzIG5vdCBhIG51bWJlci5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyZ3MubGFuZ1dlaWdodEV4YWdnZXJhdGlvbiA9IE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoYXJncy5sYW5nV2VpZ2h0RXhhZ2dlcmF0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8uaW1wbCBjaGVjayBhbGwgdGhlIHJlc3Qgb2YgdGhlIHRoaW5ncy5cclxuICAgICAgICAvLyBpZiAoIShQbGF5ZXIuVXNlcm5hbWUuUkVHRVhQLnRlc3QoZGVzYy51c2VybmFtZSkpKSB7XHJcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVc2VybmFtZSBcXFwiJHtkZXNjLnVzZXJuYW1lfVxcXCJgXHJcbiAgICAgICAgLy8gICAgICsgYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgcmVndWxhciBleHByZXNzaW9uLGBcclxuICAgICAgICAvLyAgICAgKyBgIFxcXCIke1BsYXllci5Vc2VybmFtZS5SRUdFWFAuc291cmNlfVxcXCIuYFxyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gZnI7XHJcbiAgICB9XHJcbiAgICBHYW1lcGFydE1hbmFnZXIuQ0hFQ0tfVkFMSURfQ1RPUl9BUkdTID0gQ0hFQ0tfVkFMSURfQ1RPUl9BUkdTO1xyXG59KShHYW1lcGFydE1hbmFnZXIgfHwgKEdhbWVwYXJ0TWFuYWdlciA9IHt9KSk7XHJcbkpzVXRpbHMucHJvdG9Ob0VudW0oR2FtZXBhcnRNYW5hZ2VyLCBbXCJtYW5hZ2VyQ2hlY2tHYW1lUGxheWluZ1JlcXVlc3RcIl0pO1xyXG5PYmplY3QuZnJlZXplKEdhbWVwYXJ0TWFuYWdlcik7XHJcbk9iamVjdC5mcmVlemUoR2FtZXBhcnRNYW5hZ2VyLnByb3RvdHlwZSk7XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRLQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/base/game/gameparts/GamepartManager.ts\n");

/***/ }),

/***/ "./src/base/game/player/ArtificialPlayer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JsUtils\": () => /* reexport safe */ defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils,\n/* harmony export */   \"Player\": () => /* reexport safe */ _Player__WEBPACK_IMPORTED_MODULE_2__.Player,\n/* harmony export */   \"ArtificialPlayer\": () => /* binding */ ArtificialPlayer\n/* harmony export */ });\n/* harmony import */ var defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/defs/JsUtils.ts\");\n/* harmony import */ var game_Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/base/game/Game.ts\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/base/game/player/Player.ts\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Unlike {@link HumanPlayer}s, these are not guided by human input.\r\n * Instead, they are essentially defined by how often they move, and\r\n * where they decide to move toward each time they move.\r\n *\r\n * Can be paused and un-paused by the Game Manager.\r\n *\r\n * @extends Player\r\n */\r\nclass ArtificialPlayer extends _Player__WEBPACK_IMPORTED_MODULE_2__.Player {\r\n    /**\r\n     * See {@link ArtificialPlayer.of} for the public constructor\r\n     * interface.\r\n     *\r\n     * @param game -\r\n     * @param desc -\r\n     */\r\n    constructor(game, desc) {\r\n        super(game, desc);\r\n        if (game.gameType === game_Game__WEBPACK_IMPORTED_MODULE_1__.Game.Type.ONLINE) {\r\n            throw new TypeError(\"OnlineGames should be using regular Players instead.\");\r\n        }\r\n    }\r\n    _notifyGameNowPlaying() {\r\n        this.delayedMovementContinue();\r\n    }\r\n    _notifyGameNowPaused() {\r\n        this.game.cancelTimeout(this._scheduledMovementCallbackId);\r\n        this._scheduledMovementCallbackId = undefined;\r\n    }\r\n    _notifyGameNowOver() {\r\n        this.game.cancelTimeout(this._scheduledMovementCallbackId);\r\n        this._scheduledMovementCallbackId = undefined;\r\n    }\r\n    /**\r\n     * Executes a single movement and then calls `delayedMovementContinue`.\r\n     */\r\n    movementContinue() {\r\n        const desiredDest = this.computeDesiredDest();\r\n        // This is a little different than how human players experience\r\n        // \"penalties\" when moving to tiles with long language-sequences-\r\n        // humans must pay the penalty before landing on the tile, but\r\n        // in the implementation here, it's much easier to simulate such\r\n        // a penalty if it applies _after_ landing on the tile.\r\n        this._nextMovementTimerMultiplier = this.game.grid.tile.at(desiredDest).langSeq.length;\r\n        this.makeMovementRequest(this.game.grid.getUntToward(desiredDest, this.coord), this.getNextMoveType());\r\n        // Schedule a task to do this again:\r\n        this.delayedMovementContinue();\r\n    }\r\n    /**\r\n     * Schedules a call to `movementContinue`.\r\n     */\r\n    delayedMovementContinue() {\r\n        // Schedule the next movement.\r\n        this._scheduledMovementCallbackId = this.game.setTimeout(this.movementContinue.bind(this), this.computeNextMovementTimer() * this._nextMovementTimerMultiplier);\r\n        return;\r\n    }\r\n}\r\n(function (ArtificialPlayer) {\r\n    ArtificialPlayer.of = (game, playerDesc) => {\r\n        const familyId = playerDesc.familyId;\r\n        return new (ArtificialPlayer._Constructors[familyId])(game, playerDesc);\r\n    };\r\n})(ArtificialPlayer || (ArtificialPlayer = {}));\r\ndefs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils.protoNoEnum(ArtificialPlayer, [\"movementContinue\"]);\r\n// ArtificialPlayer is frozen in PostInit after _Constructors get initialized.\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9nYW1lL3BsYXllci9BcnRpZmljaWFsUGxheWVyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc25ha2V5My8uL3NyYy9iYXNlL2dhbWUvcGxheWVyL0FydGlmaWNpYWxQbGF5ZXIudHM/YjI3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBKc1V0aWxzIH0gZnJvbSBcImRlZnMvSnNVdGlsc1wiO1xyXG5pbXBvcnQgeyBHYW1lIH0gZnJvbSBcImdhbWUvR2FtZVwiO1xyXG5leHBvcnQgeyBKc1V0aWxzIH07XHJcbmltcG9ydCB7IFBsYXllciB9IGZyb20gXCIuL1BsYXllclwiO1xyXG5leHBvcnQgeyBQbGF5ZXIgfTtcclxuLyoqXHJcbiAqIFVubGlrZSB7QGxpbmsgSHVtYW5QbGF5ZXJ9cywgdGhlc2UgYXJlIG5vdCBndWlkZWQgYnkgaHVtYW4gaW5wdXQuXHJcbiAqIEluc3RlYWQsIHRoZXkgYXJlIGVzc2VudGlhbGx5IGRlZmluZWQgYnkgaG93IG9mdGVuIHRoZXkgbW92ZSwgYW5kXHJcbiAqIHdoZXJlIHRoZXkgZGVjaWRlIHRvIG1vdmUgdG93YXJkIGVhY2ggdGltZSB0aGV5IG1vdmUuXHJcbiAqXHJcbiAqIENhbiBiZSBwYXVzZWQgYW5kIHVuLXBhdXNlZCBieSB0aGUgR2FtZSBNYW5hZ2VyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBQbGF5ZXJcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcnRpZmljaWFsUGxheWVyIGV4dGVuZHMgUGxheWVyIHtcclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBBcnRpZmljaWFsUGxheWVyLm9mfSBmb3IgdGhlIHB1YmxpYyBjb25zdHJ1Y3RvclxyXG4gICAgICogaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnYW1lIC1cclxuICAgICAqIEBwYXJhbSBkZXNjIC1cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2FtZSwgZGVzYykge1xyXG4gICAgICAgIHN1cGVyKGdhbWUsIGRlc2MpO1xyXG4gICAgICAgIGlmIChnYW1lLmdhbWVUeXBlID09PSBHYW1lLlR5cGUuT05MSU5FKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmxpbmVHYW1lcyBzaG91bGQgYmUgdXNpbmcgcmVndWxhciBQbGF5ZXJzIGluc3RlYWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9ub3RpZnlHYW1lTm93UGxheWluZygpIHtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRNb3ZlbWVudENvbnRpbnVlKCk7XHJcbiAgICB9XHJcbiAgICBfbm90aWZ5R2FtZU5vd1BhdXNlZCgpIHtcclxuICAgICAgICB0aGlzLmdhbWUuY2FuY2VsVGltZW91dCh0aGlzLl9zY2hlZHVsZWRNb3ZlbWVudENhbGxiYWNrSWQpO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZE1vdmVtZW50Q2FsbGJhY2tJZCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9ub3RpZnlHYW1lTm93T3ZlcigpIHtcclxuICAgICAgICB0aGlzLmdhbWUuY2FuY2VsVGltZW91dCh0aGlzLl9zY2hlZHVsZWRNb3ZlbWVudENhbGxiYWNrSWQpO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZE1vdmVtZW50Q2FsbGJhY2tJZCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgYSBzaW5nbGUgbW92ZW1lbnQgYW5kIHRoZW4gY2FsbHMgYGRlbGF5ZWRNb3ZlbWVudENvbnRpbnVlYC5cclxuICAgICAqL1xyXG4gICAgbW92ZW1lbnRDb250aW51ZSgpIHtcclxuICAgICAgICBjb25zdCBkZXNpcmVkRGVzdCA9IHRoaXMuY29tcHV0ZURlc2lyZWREZXN0KCk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgdGhhbiBob3cgaHVtYW4gcGxheWVycyBleHBlcmllbmNlXHJcbiAgICAgICAgLy8gXCJwZW5hbHRpZXNcIiB3aGVuIG1vdmluZyB0byB0aWxlcyB3aXRoIGxvbmcgbGFuZ3VhZ2Utc2VxdWVuY2VzLVxyXG4gICAgICAgIC8vIGh1bWFucyBtdXN0IHBheSB0aGUgcGVuYWx0eSBiZWZvcmUgbGFuZGluZyBvbiB0aGUgdGlsZSwgYnV0XHJcbiAgICAgICAgLy8gaW4gdGhlIGltcGxlbWVudGF0aW9uIGhlcmUsIGl0J3MgbXVjaCBlYXNpZXIgdG8gc2ltdWxhdGUgc3VjaFxyXG4gICAgICAgIC8vIGEgcGVuYWx0eSBpZiBpdCBhcHBsaWVzIF9hZnRlcl8gbGFuZGluZyBvbiB0aGUgdGlsZS5cclxuICAgICAgICB0aGlzLl9uZXh0TW92ZW1lbnRUaW1lck11bHRpcGxpZXIgPSB0aGlzLmdhbWUuZ3JpZC50aWxlLmF0KGRlc2lyZWREZXN0KS5sYW5nU2VxLmxlbmd0aDtcclxuICAgICAgICB0aGlzLm1ha2VNb3ZlbWVudFJlcXVlc3QodGhpcy5nYW1lLmdyaWQuZ2V0VW50VG93YXJkKGRlc2lyZWREZXN0LCB0aGlzLmNvb3JkKSwgdGhpcy5nZXROZXh0TW92ZVR5cGUoKSk7XHJcbiAgICAgICAgLy8gU2NoZWR1bGUgYSB0YXNrIHRvIGRvIHRoaXMgYWdhaW46XHJcbiAgICAgICAgdGhpcy5kZWxheWVkTW92ZW1lbnRDb250aW51ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYSBjYWxsIHRvIGBtb3ZlbWVudENvbnRpbnVlYC5cclxuICAgICAqL1xyXG4gICAgZGVsYXllZE1vdmVtZW50Q29udGludWUoKSB7XHJcbiAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgbW92ZW1lbnQuXHJcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVkTW92ZW1lbnRDYWxsYmFja0lkID0gdGhpcy5nYW1lLnNldFRpbWVvdXQodGhpcy5tb3ZlbWVudENvbnRpbnVlLmJpbmQodGhpcyksIHRoaXMuY29tcHV0ZU5leHRNb3ZlbWVudFRpbWVyKCkgKiB0aGlzLl9uZXh0TW92ZW1lbnRUaW1lck11bHRpcGxpZXIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufVxyXG4oZnVuY3Rpb24gKEFydGlmaWNpYWxQbGF5ZXIpIHtcclxuICAgIEFydGlmaWNpYWxQbGF5ZXIub2YgPSAoZ2FtZSwgcGxheWVyRGVzYykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZhbWlseUlkID0gcGxheWVyRGVzYy5mYW1pbHlJZDtcclxuICAgICAgICByZXR1cm4gbmV3IChBcnRpZmljaWFsUGxheWVyLl9Db25zdHJ1Y3RvcnNbZmFtaWx5SWRdKShnYW1lLCBwbGF5ZXJEZXNjKTtcclxuICAgIH07XHJcbn0pKEFydGlmaWNpYWxQbGF5ZXIgfHwgKEFydGlmaWNpYWxQbGF5ZXIgPSB7fSkpO1xyXG5Kc1V0aWxzLnByb3RvTm9FbnVtKEFydGlmaWNpYWxQbGF5ZXIsIFtcIm1vdmVtZW50Q29udGludWVcIl0pO1xyXG4vLyBBcnRpZmljaWFsUGxheWVyIGlzIGZyb3plbiBpbiBQb3N0SW5pdCBhZnRlciBfQ29uc3RydWN0b3JzIGdldCBpbml0aWFsaXplZC5cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/base/game/player/ArtificialPlayer.ts\n");

/***/ }),

/***/ "./src/base/game/player/artificials/Chaser.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Chaser\": () => /* binding */ Chaser\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _ArtificialPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/game/player/ArtificialPlayer.ts\");\nvar _prevCoord;\r\n\r\n\r\n/**\r\n *\r\n * @extends ArtificialPlayer\r\n */\r\nclass Chaser extends _ArtificialPlayer__WEBPACK_IMPORTED_MODULE_0__.ArtificialPlayer {\r\n    constructor(game, desc) {\r\n        super(game, desc);\r\n        _prevCoord.set(this, void 0);\r\n        this.behaviour = Object.freeze(Object.assign({}, Chaser.Behaviour.DEFAULT, desc.familyArgs));\r\n        this.grid = this.game.grid;\r\n    }\r\n    _afterAllPlayersConstruction() {\r\n        super._afterAllPlayersConstruction();\r\n        // We need to cast off read-only-ness below.\r\n        // @ts-expect-error : RO=\r\n        this.threatProximity = this.game.teams\r\n            .filter((team) => team.id !== this.teamId)\r\n            .flatMap((team) => team.members);\r\n        // @ts-expect-error : RO=\r\n        this.targetProximity = [...this.threatProximity];\r\n        _ArtificialPlayer__WEBPACK_IMPORTED_MODULE_0__.JsUtils.propNoWrite(this, [\r\n            \"threatProximity\", \"targetProximity\",\r\n            \"behaviour\", \"grid\",\r\n        ]);\r\n    }\r\n    reset(spawnTile) {\r\n        super.reset(spawnTile);\r\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldSet)(this, _prevCoord, this.coord);\r\n    }\r\n    moveTo(dest) {\r\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldSet)(this, _prevCoord, this.coord);\r\n        super.moveTo(dest);\r\n    }\r\n    computeDesiredDest() {\r\n        // Check if there is anyone to run away from:\r\n        this.threatProximity.sort((pa, pb) => {\r\n            return this.grid.minMovesFromTo(pa.coord, this.coord)\r\n                - this.grid.minMovesFromTo(pb.coord, this.coord);\r\n        });\r\n        for (const threatP of this.threatProximity) {\r\n            if (this.grid.minMovesFromTo(threatP.coord, this.coord)\r\n                > this.behaviour.fearDistance)\r\n                break;\r\n            if (threatP.status.isDowned)\r\n                continue;\r\n            if (threatP.status.health > this.status.health) {\r\n                // TODO.design Something that avoids getting cornered.\r\n                return this.grid.getUntAwayFrom(threatP.coord, this.coord).coord;\r\n            }\r\n        }\r\n        // If there is nobody to run away from,\r\n        // Check if there is anyone we want to attack:\r\n        this.targetProximity.sort((pa, pb) => {\r\n            return this.grid.minMovesFromTo(this.coord, pa.coord)\r\n                - this.grid.minMovesFromTo(this.coord, pb.coord);\r\n        });\r\n        if (this.status.isDowned) {\r\n            for (const targetP of this.targetProximity) {\r\n                if (this.grid.minMovesFromTo(this.coord, targetP.coord)\r\n                    > this.behaviour.bloodThirstDistance)\r\n                    break;\r\n                if (targetP.status.health < this.status.health - this.behaviour.healthReserve) {\r\n                    return targetP.coord;\r\n                }\r\n            }\r\n        }\r\n        // If there is nobody we want to chase after to attack,\r\n        // Head toward the nearest free health if it exists.\r\n        if (this.game.freeHealthTiles.size === 0) {\r\n            // No tiles close by. Wander around:\r\n            if (Math.random() < this.behaviour.wanderingAimlessness) {\r\n                // Big direction change:\r\n                return this.grid.getRandomCoordAround(this.coord, 3);\r\n            }\r\n            else {\r\n                // Continue wandering with a subtle, random direction:\r\n                const awayFunc = this.grid.getUntAwayFrom.bind(this.grid, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(this, _prevCoord));\r\n                return this.grid.getRandomCoordAround(awayFunc(awayFunc(this.coord).coord).coord, 1);\r\n            }\r\n        }\r\n        let closestFht = undefined;\r\n        let closestFhtDistance = Infinity;\r\n        for (const fht of this.game.freeHealthTiles) {\r\n            const distance = this.grid.minMovesFromTo(this.coord, fht.coord);\r\n            if (distance < closestFhtDistance) {\r\n                closestFht = fht;\r\n                closestFhtDistance = distance;\r\n            }\r\n        }\r\n        return closestFht.coord;\r\n    }\r\n    getNextMoveType() {\r\n        return _ArtificialPlayer__WEBPACK_IMPORTED_MODULE_0__.Player.MoveType.NORMAL;\r\n    }\r\n    computeNextMovementTimer() {\r\n        return 1000 / this.behaviour.keyPressesPerSecond;\r\n    }\r\n}\r\n_prevCoord = new WeakMap();\r\n(function (Chaser) {\r\n    let Behaviour;\r\n    (function (Behaviour) {\r\n        Behaviour.DEFAULT = Object.freeze({\r\n            fearDistance: 5,\r\n            bloodThirstDistance: 7,\r\n            healthReserve: 3.0,\r\n            keyPressesPerSecond: 2.0,\r\n            wanderingAimlessness: 0.2,\r\n        });\r\n    })(Behaviour = Chaser.Behaviour || (Chaser.Behaviour = {}));\r\n})(Chaser || (Chaser = {}));\r\n_ArtificialPlayer__WEBPACK_IMPORTED_MODULE_0__.JsUtils.protoNoEnum(Chaser, [\"_afterAllPlayersConstruction\"]);\r\nObject.freeze(Chaser);\r\nObject.freeze(Chaser.prototype);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9nYW1lL3BsYXllci9hcnRpZmljaWFscy9DaGFzZXIudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbmFrZXkzLy4vc3JjL2Jhc2UvZ2FtZS9wbGF5ZXIvYXJ0aWZpY2lhbHMvQ2hhc2VyLnRzPzg2YTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9wcmV2Q29vcmQ7XHJcbmltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgSnNVdGlscywgUGxheWVyLCBBcnRpZmljaWFsUGxheWVyLCB9IGZyb20gXCIuLi9BcnRpZmljaWFsUGxheWVyXCI7XHJcbi8qKlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBcnRpZmljaWFsUGxheWVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hhc2VyIGV4dGVuZHMgQXJ0aWZpY2lhbFBsYXllciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnYW1lLCBkZXNjKSB7XHJcbiAgICAgICAgc3VwZXIoZ2FtZSwgZGVzYyk7XHJcbiAgICAgICAgX3ByZXZDb29yZC5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgICAgICB0aGlzLmJlaGF2aW91ciA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgQ2hhc2VyLkJlaGF2aW91ci5ERUZBVUxULCBkZXNjLmZhbWlseUFyZ3MpKTtcclxuICAgICAgICB0aGlzLmdyaWQgPSB0aGlzLmdhbWUuZ3JpZDtcclxuICAgIH1cclxuICAgIF9hZnRlckFsbFBsYXllcnNDb25zdHJ1Y3Rpb24oKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyQWxsUGxheWVyc0NvbnN0cnVjdGlvbigpO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FzdCBvZmYgcmVhZC1vbmx5LW5lc3MgYmVsb3cuXHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciA6IFJPPVxyXG4gICAgICAgIHRoaXMudGhyZWF0UHJveGltaXR5ID0gdGhpcy5nYW1lLnRlYW1zXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHRlYW0pID0+IHRlYW0uaWQgIT09IHRoaXMudGVhbUlkKVxyXG4gICAgICAgICAgICAuZmxhdE1hcCgodGVhbSkgPT4gdGVhbS5tZW1iZXJzKTtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIDogUk89XHJcbiAgICAgICAgdGhpcy50YXJnZXRQcm94aW1pdHkgPSBbLi4udGhpcy50aHJlYXRQcm94aW1pdHldO1xyXG4gICAgICAgIEpzVXRpbHMucHJvcE5vV3JpdGUodGhpcywgW1xyXG4gICAgICAgICAgICBcInRocmVhdFByb3hpbWl0eVwiLCBcInRhcmdldFByb3hpbWl0eVwiLFxyXG4gICAgICAgICAgICBcImJlaGF2aW91clwiLCBcImdyaWRcIixcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJlc2V0KHNwYXduVGlsZSkge1xyXG4gICAgICAgIHN1cGVyLnJlc2V0KHNwYXduVGlsZSk7XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfcHJldkNvb3JkLCB0aGlzLmNvb3JkKTtcclxuICAgIH1cclxuICAgIG1vdmVUbyhkZXN0KSB7XHJcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfcHJldkNvb3JkLCB0aGlzLmNvb3JkKTtcclxuICAgICAgICBzdXBlci5tb3ZlVG8oZGVzdCk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlRGVzaXJlZERlc3QoKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW55b25lIHRvIHJ1biBhd2F5IGZyb206XHJcbiAgICAgICAgdGhpcy50aHJlYXRQcm94aW1pdHkuc29ydCgocGEsIHBiKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQubWluTW92ZXNGcm9tVG8ocGEuY29vcmQsIHRoaXMuY29vcmQpXHJcbiAgICAgICAgICAgICAgICAtIHRoaXMuZ3JpZC5taW5Nb3Zlc0Zyb21UbyhwYi5jb29yZCwgdGhpcy5jb29yZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aHJlYXRQIG9mIHRoaXMudGhyZWF0UHJveGltaXR5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQubWluTW92ZXNGcm9tVG8odGhyZWF0UC5jb29yZCwgdGhpcy5jb29yZClcclxuICAgICAgICAgICAgICAgID4gdGhpcy5iZWhhdmlvdXIuZmVhckRpc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGlmICh0aHJlYXRQLnN0YXR1cy5pc0Rvd25lZClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAodGhyZWF0UC5zdGF0dXMuaGVhbHRoID4gdGhpcy5zdGF0dXMuaGVhbHRoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPLmRlc2lnbiBTb21ldGhpbmcgdGhhdCBhdm9pZHMgZ2V0dGluZyBjb3JuZXJlZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0VW50QXdheUZyb20odGhyZWF0UC5jb29yZCwgdGhpcy5jb29yZCkuY29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm9ib2R5IHRvIHJ1biBhd2F5IGZyb20sXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW55b25lIHdlIHdhbnQgdG8gYXR0YWNrOlxyXG4gICAgICAgIHRoaXMudGFyZ2V0UHJveGltaXR5LnNvcnQoKHBhLCBwYikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkLm1pbk1vdmVzRnJvbVRvKHRoaXMuY29vcmQsIHBhLmNvb3JkKVxyXG4gICAgICAgICAgICAgICAgLSB0aGlzLmdyaWQubWluTW92ZXNGcm9tVG8odGhpcy5jb29yZCwgcGIuY29vcmQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cy5pc0Rvd25lZCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldFAgb2YgdGhpcy50YXJnZXRQcm94aW1pdHkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyaWQubWluTW92ZXNGcm9tVG8odGhpcy5jb29yZCwgdGFyZ2V0UC5jb29yZClcclxuICAgICAgICAgICAgICAgICAgICA+IHRoaXMuYmVoYXZpb3VyLmJsb29kVGhpcnN0RGlzdGFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UC5zdGF0dXMuaGVhbHRoIDwgdGhpcy5zdGF0dXMuaGVhbHRoIC0gdGhpcy5iZWhhdmlvdXIuaGVhbHRoUmVzZXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRQLmNvb3JkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vYm9keSB3ZSB3YW50IHRvIGNoYXNlIGFmdGVyIHRvIGF0dGFjayxcclxuICAgICAgICAvLyBIZWFkIHRvd2FyZCB0aGUgbmVhcmVzdCBmcmVlIGhlYWx0aCBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2FtZS5mcmVlSGVhbHRoVGlsZXMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBObyB0aWxlcyBjbG9zZSBieS4gV2FuZGVyIGFyb3VuZDpcclxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLmJlaGF2aW91ci53YW5kZXJpbmdBaW1sZXNzbmVzcykge1xyXG4gICAgICAgICAgICAgICAgLy8gQmlnIGRpcmVjdGlvbiBjaGFuZ2U6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldFJhbmRvbUNvb3JkQXJvdW5kKHRoaXMuY29vcmQsIDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgd2FuZGVyaW5nIHdpdGggYSBzdWJ0bGUsIHJhbmRvbSBkaXJlY3Rpb246XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhd2F5RnVuYyA9IHRoaXMuZ3JpZC5nZXRVbnRBd2F5RnJvbS5iaW5kKHRoaXMuZ3JpZCwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfcHJldkNvb3JkKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldFJhbmRvbUNvb3JkQXJvdW5kKGF3YXlGdW5jKGF3YXlGdW5jKHRoaXMuY29vcmQpLmNvb3JkKS5jb29yZCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RGaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RGaHREaXN0YW5jZSA9IEluZmluaXR5O1xyXG4gICAgICAgIGZvciAoY29uc3QgZmh0IG9mIHRoaXMuZ2FtZS5mcmVlSGVhbHRoVGlsZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmdyaWQubWluTW92ZXNGcm9tVG8odGhpcy5jb29yZCwgZmh0LmNvb3JkKTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdEZodERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0Rmh0ID0gZmh0O1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdEZodERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaHQuY29vcmQ7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0TW92ZVR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFBsYXllci5Nb3ZlVHlwZS5OT1JNQUw7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlTmV4dE1vdmVtZW50VGltZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLmJlaGF2aW91ci5rZXlQcmVzc2VzUGVyU2Vjb25kO1xyXG4gICAgfVxyXG59XHJcbl9wcmV2Q29vcmQgPSBuZXcgV2Vha01hcCgpO1xyXG4oZnVuY3Rpb24gKENoYXNlcikge1xyXG4gICAgbGV0IEJlaGF2aW91cjtcclxuICAgIChmdW5jdGlvbiAoQmVoYXZpb3VyKSB7XHJcbiAgICAgICAgQmVoYXZpb3VyLkRFRkFVTFQgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZmVhckRpc3RhbmNlOiA1LFxyXG4gICAgICAgICAgICBibG9vZFRoaXJzdERpc3RhbmNlOiA3LFxyXG4gICAgICAgICAgICBoZWFsdGhSZXNlcnZlOiAzLjAsXHJcbiAgICAgICAgICAgIGtleVByZXNzZXNQZXJTZWNvbmQ6IDIuMCxcclxuICAgICAgICAgICAgd2FuZGVyaW5nQWltbGVzc25lc3M6IDAuMixcclxuICAgICAgICB9KTtcclxuICAgIH0pKEJlaGF2aW91ciA9IENoYXNlci5CZWhhdmlvdXIgfHwgKENoYXNlci5CZWhhdmlvdXIgPSB7fSkpO1xyXG59KShDaGFzZXIgfHwgKENoYXNlciA9IHt9KSk7XHJcbkpzVXRpbHMucHJvdG9Ob0VudW0oQ2hhc2VyLCBbXCJfYWZ0ZXJBbGxQbGF5ZXJzQ29uc3RydWN0aW9uXCJdKTtcclxuT2JqZWN0LmZyZWV6ZShDaGFzZXIpO1xyXG5PYmplY3QuZnJlZXplKENoYXNlci5wcm90b3R5cGUpO1xyXG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/base/game/player/artificials/Chaser.ts\n");

/***/ }),

/***/ "./src/base/lang/Lang.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lang\": () => /* binding */ Lang\n/* harmony export */ });\n/* harmony import */ var defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/defs/JsUtils.ts\");\n/* harmony import */ var defs_TypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/base/defs/TypeDefs.ts\");\n/* harmony import */ var lang_LangSeqTreeNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./src/base/lang/LangSeqTreeNode.ts\");\n\r\n\r\n\r\n/**\r\n * A language is a map from a collection of unique characters to\r\n * corresponding key-sequences. the key-sequences may be non-unique.\r\n * (try searching up \"Chinese riddle where each syllable is pronounced\r\n * 'shi'\"). A character may have more than one corresponding sequence,\r\n * representing alternate \"spellings\" (ways of typing it).\r\n *\r\n * ### From Typeable Sequences to Written Characters\r\n *\r\n * To the game internals, the reverse thinking is more important: As\r\n * a map from typeable key-sequences to sets of language-unique written\r\n * characters (no character is mapped by multiple key-sequences). We\r\n * do not require support for retrieving the sequence corresponding to\r\n * a written character.\r\n *\r\n * ### Implementation Guide\r\n *\r\n * See the readme in [the implementations folder](./impl/readme.md)\r\n * for a guide on writing implementations of this class.\r\n */\r\nclass Lang extends defs_TypeDefs__WEBPACK_IMPORTED_MODULE_1__.Lang {\r\n    /**\r\n     * @param frontendDescId -\r\n     *\r\n     * @param forwardDict\r\n     * Weights are _relative_ values handled by tree nodes, which\r\n     * require the provided values to all be strictly positive values.\r\n     * Ie. They do not need to sum up to any specific value.\r\n     *\r\n     * @param weightExaggeration -\r\n     */\r\n    constructor(frontendDescId, forwardDict, weightExaggeration) {\r\n        super();\r\n        this.frontendDesc = Lang.GET_FRONTEND_DESC_BY_ID(frontendDescId);\r\n        this.treeMap = lang_LangSeqTreeNode__WEBPACK_IMPORTED_MODULE_2__.LangSeqTree.ParentNode.CREATE_TREE_MAP(forwardDict, weightExaggeration);\r\n        this.leafNodes = this.treeMap.getLeafNodes();\r\n        defs_JsUtils__WEBPACK_IMPORTED_MODULE_0__.JsUtils.propNoWrite(this, [\r\n            \"frontendDesc\", \"treeMap\", \"leafNodes\",\r\n        ]);\r\n        if (this.leafNodes.length !== this.frontendDesc.numLeaves) {\r\n            throw new Error(`maintenance required: the frontend constant`\r\n                + ` for the language \\\"${this.frontendDesc.id}\\\" needs to`\r\n                + ` be updated to the correct, computed value, which is`\r\n                + ` \\`${this.leafNodes.length}\\`.`);\r\n        }\r\n    }\r\n    get numLeaves() { return this.leafNodes.length; }\r\n    /**\r\n     */\r\n    reset() {\r\n        this.treeMap.reset();\r\n        // The below method of shuffling is not used because its effects\r\n        // on state are weaker / less desirable than those achieved by\r\n        // the currently-used method found in ChildNode.reset, whose\r\n        // drawback is that it is more performance costly.\r\n        // Shuffle the initial leaf order:\r\n        // this.leafNodes.sort((a,b) => Math.random() - 0.5);\r\n    }\r\n    /**\r\n     * @returns\r\n     * A random char in this language whose corresponding sequence is\r\n     * not a prefix of any `Lang.Seq` in `avoid`, and vice versa. Ie.\r\n     * They may share a common prefix as long as they are both longer\r\n     * than the shared prefix.\r\n     *\r\n     * @description\r\n     * This method is called to shuffle the char-seq pair at some tile\r\n     * A. `avoid` should contain the lang-sequences from all tiles\r\n     * reachable by a player occupying any tile B from which they can\r\n     * also reach A (except for A itself).\r\n     *\r\n     * @param avoid\r\n     * A collection of `Lang.Seq`s to avoid conflicts with when choosing\r\n     * a `Lang.Char` to return. Is allowed to contain empty strings,\r\n     * which will be ignored as if those entries did not exist.\r\n     *\r\n     * @requires\r\n     * In order for this language to satisfy these constraints, it must\r\n     * be true that the number of leaf nodes in its tree-structure must\r\n     * provably be greater than the number of non-empty entries in\r\n     * `avoid` for all expected combinations of internal state and\r\n     * passed-arguments under which it could be called.\r\n     */\r\n    getNonConflictingChar(avoid) {\r\n        // Wording the spec closer to this implementation: We must find\r\n        // characters from nodes that are not descendants or ancestors\r\n        // of nodes for sequences to avoid. We can be sure that none of\r\n        // the ancestors or descendants of avoid-nodes are avoid-nodes.\r\n        // Start by sorting according to the desired balancing scheme:\r\n        this.leafNodes.sort(lang_LangSeqTreeNode__WEBPACK_IMPORTED_MODULE_2__.LangSeqTree.ParentNode.LEAF_CMP);\r\n        let nodeToHit = undefined;\r\n        for (const leaf of this.leafNodes) {\r\n            // Take the next leaf node (don't remove it!), and if none of\r\n            // its parents are avoid-nodes, then, from the set of nodes\r\n            // including the leaf node and all its parents (minus the root),\r\n            // choose the node with the least actual/personal hit-count.\r\n            const upstreamNodes = leaf.andNonRootParents();\r\n            for (let i = 0; i < upstreamNodes.length; i++) {\r\n                const conflictSeq = avoid.find((avoidSeq) => {\r\n                    return avoidSeq.startsWith(upstreamNodes[i].sequence);\r\n                });\r\n                if (conflictSeq) {\r\n                    if (conflictSeq === upstreamNodes[i].sequence) {\r\n                        // Cannot use anything on this upstream path because\r\n                        // an avoid-node is directly inside it.\r\n                        upstreamNodes.length = 0;\r\n                    }\r\n                    else {\r\n                        // Found a node on an upstream path of an avoid-node.\r\n                        // Doesn't stop us from using what we've found so far.\r\n                        upstreamNodes.splice(i);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (upstreamNodes.length) {\r\n                // Found a non-conflicting upstream node.\r\n                // Find the node with the lowest personal hit-count:\r\n                nodeToHit = upstreamNodes[0];\r\n                for (const node of upstreamNodes) {\r\n                    if (node.personalWeightedHitCount < nodeToHit.personalWeightedHitCount) {\r\n                        nodeToHit = node;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (nodeToHit === undefined) {\r\n            // Should never reach here because there is a check in the\r\n            // constructor for this invariant.\r\n            throw new Error(`Invariants guaranteeing that a LangSeq can`\r\n                + `always be shuffled-in were not met.`);\r\n        }\r\n        return nodeToHit.chooseOnePair();\r\n    }\r\n    /**\r\n     */\r\n    simpleView() {\r\n        return Object.assign(Object.create(null), {\r\n            id: this.frontendDesc.id,\r\n            displayName: this.frontendDesc.displayName,\r\n            root: this.treeMap.simpleView(),\r\n            numLeaves: this.leafNodes.length,\r\n        });\r\n    }\r\n}\r\n(function (Lang) {\r\n    ;\r\n})(Lang || (Lang = {}));\r\nObject.freeze(Lang);\r\nObject.freeze(Lang.prototype);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9sYW5nL0xhbmcudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbmFrZXkzLy4vc3JjL2Jhc2UvbGFuZy9MYW5nLnRzPzQyZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSnNVdGlscyB9IGZyb20gXCJkZWZzL0pzVXRpbHNcIjtcclxuaW1wb3J0IHsgTGFuZyBhcyBfTGFuZyB9IGZyb20gXCJkZWZzL1R5cGVEZWZzXCI7XHJcbmltcG9ydCB7IExhbmdTZXFUcmVlIH0gZnJvbSBcImxhbmcvTGFuZ1NlcVRyZWVOb2RlXCI7XHJcbi8qKlxyXG4gKiBBIGxhbmd1YWdlIGlzIGEgbWFwIGZyb20gYSBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBjaGFyYWN0ZXJzIHRvXHJcbiAqIGNvcnJlc3BvbmRpbmcga2V5LXNlcXVlbmNlcy4gdGhlIGtleS1zZXF1ZW5jZXMgbWF5IGJlIG5vbi11bmlxdWUuXHJcbiAqICh0cnkgc2VhcmNoaW5nIHVwIFwiQ2hpbmVzZSByaWRkbGUgd2hlcmUgZWFjaCBzeWxsYWJsZSBpcyBwcm9ub3VuY2VkXHJcbiAqICdzaGknXCIpLiBBIGNoYXJhY3RlciBtYXkgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcnJlc3BvbmRpbmcgc2VxdWVuY2UsXHJcbiAqIHJlcHJlc2VudGluZyBhbHRlcm5hdGUgXCJzcGVsbGluZ3NcIiAod2F5cyBvZiB0eXBpbmcgaXQpLlxyXG4gKlxyXG4gKiAjIyMgRnJvbSBUeXBlYWJsZSBTZXF1ZW5jZXMgdG8gV3JpdHRlbiBDaGFyYWN0ZXJzXHJcbiAqXHJcbiAqIFRvIHRoZSBnYW1lIGludGVybmFscywgdGhlIHJldmVyc2UgdGhpbmtpbmcgaXMgbW9yZSBpbXBvcnRhbnQ6IEFzXHJcbiAqIGEgbWFwIGZyb20gdHlwZWFibGUga2V5LXNlcXVlbmNlcyB0byBzZXRzIG9mIGxhbmd1YWdlLXVuaXF1ZSB3cml0dGVuXHJcbiAqIGNoYXJhY3RlcnMgKG5vIGNoYXJhY3RlciBpcyBtYXBwZWQgYnkgbXVsdGlwbGUga2V5LXNlcXVlbmNlcykuIFdlXHJcbiAqIGRvIG5vdCByZXF1aXJlIHN1cHBvcnQgZm9yIHJldHJpZXZpbmcgdGhlIHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG9cclxuICogYSB3cml0dGVuIGNoYXJhY3Rlci5cclxuICpcclxuICogIyMjIEltcGxlbWVudGF0aW9uIEd1aWRlXHJcbiAqXHJcbiAqIFNlZSB0aGUgcmVhZG1lIGluIFt0aGUgaW1wbGVtZW50YXRpb25zIGZvbGRlcl0oLi9pbXBsL3JlYWRtZS5tZClcclxuICogZm9yIGEgZ3VpZGUgb24gd3JpdGluZyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMYW5nIGV4dGVuZHMgX0xhbmcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZnJvbnRlbmREZXNjSWQgLVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb3J3YXJkRGljdFxyXG4gICAgICogV2VpZ2h0cyBhcmUgX3JlbGF0aXZlXyB2YWx1ZXMgaGFuZGxlZCBieSB0cmVlIG5vZGVzLCB3aGljaFxyXG4gICAgICogcmVxdWlyZSB0aGUgcHJvdmlkZWQgdmFsdWVzIHRvIGFsbCBiZSBzdHJpY3RseSBwb3NpdGl2ZSB2YWx1ZXMuXHJcbiAgICAgKiBJZS4gVGhleSBkbyBub3QgbmVlZCB0byBzdW0gdXAgdG8gYW55IHNwZWNpZmljIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3ZWlnaHRFeGFnZ2VyYXRpb24gLVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9udGVuZERlc2NJZCwgZm9yd2FyZERpY3QsIHdlaWdodEV4YWdnZXJhdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5mcm9udGVuZERlc2MgPSBMYW5nLkdFVF9GUk9OVEVORF9ERVNDX0JZX0lEKGZyb250ZW5kRGVzY0lkKTtcclxuICAgICAgICB0aGlzLnRyZWVNYXAgPSBMYW5nU2VxVHJlZS5QYXJlbnROb2RlLkNSRUFURV9UUkVFX01BUChmb3J3YXJkRGljdCwgd2VpZ2h0RXhhZ2dlcmF0aW9uKTtcclxuICAgICAgICB0aGlzLmxlYWZOb2RlcyA9IHRoaXMudHJlZU1hcC5nZXRMZWFmTm9kZXMoKTtcclxuICAgICAgICBKc1V0aWxzLnByb3BOb1dyaXRlKHRoaXMsIFtcclxuICAgICAgICAgICAgXCJmcm9udGVuZERlc2NcIiwgXCJ0cmVlTWFwXCIsIFwibGVhZk5vZGVzXCIsXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVhZk5vZGVzLmxlbmd0aCAhPT0gdGhpcy5mcm9udGVuZERlc2MubnVtTGVhdmVzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFpbnRlbmFuY2UgcmVxdWlyZWQ6IHRoZSBmcm9udGVuZCBjb25zdGFudGBcclxuICAgICAgICAgICAgICAgICsgYCBmb3IgdGhlIGxhbmd1YWdlIFxcXCIke3RoaXMuZnJvbnRlbmREZXNjLmlkfVxcXCIgbmVlZHMgdG9gXHJcbiAgICAgICAgICAgICAgICArIGAgYmUgdXBkYXRlZCB0byB0aGUgY29ycmVjdCwgY29tcHV0ZWQgdmFsdWUsIHdoaWNoIGlzYFxyXG4gICAgICAgICAgICAgICAgKyBgIFxcYCR7dGhpcy5sZWFmTm9kZXMubGVuZ3RofVxcYC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbnVtTGVhdmVzKCkgeyByZXR1cm4gdGhpcy5sZWFmTm9kZXMubGVuZ3RoOyB9XHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlTWFwLnJlc2V0KCk7XHJcbiAgICAgICAgLy8gVGhlIGJlbG93IG1ldGhvZCBvZiBzaHVmZmxpbmcgaXMgbm90IHVzZWQgYmVjYXVzZSBpdHMgZWZmZWN0c1xyXG4gICAgICAgIC8vIG9uIHN0YXRlIGFyZSB3ZWFrZXIgLyBsZXNzIGRlc2lyYWJsZSB0aGFuIHRob3NlIGFjaGlldmVkIGJ5XHJcbiAgICAgICAgLy8gdGhlIGN1cnJlbnRseS11c2VkIG1ldGhvZCBmb3VuZCBpbiBDaGlsZE5vZGUucmVzZXQsIHdob3NlXHJcbiAgICAgICAgLy8gZHJhd2JhY2sgaXMgdGhhdCBpdCBpcyBtb3JlIHBlcmZvcm1hbmNlIGNvc3RseS5cclxuICAgICAgICAvLyBTaHVmZmxlIHRoZSBpbml0aWFsIGxlYWYgb3JkZXI6XHJcbiAgICAgICAgLy8gdGhpcy5sZWFmTm9kZXMuc29ydCgoYSxiKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqIEEgcmFuZG9tIGNoYXIgaW4gdGhpcyBsYW5ndWFnZSB3aG9zZSBjb3JyZXNwb25kaW5nIHNlcXVlbmNlIGlzXHJcbiAgICAgKiBub3QgYSBwcmVmaXggb2YgYW55IGBMYW5nLlNlcWAgaW4gYGF2b2lkYCwgYW5kIHZpY2UgdmVyc2EuIEllLlxyXG4gICAgICogVGhleSBtYXkgc2hhcmUgYSBjb21tb24gcHJlZml4IGFzIGxvbmcgYXMgdGhleSBhcmUgYm90aCBsb25nZXJcclxuICAgICAqIHRoYW4gdGhlIHNoYXJlZCBwcmVmaXguXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gc2h1ZmZsZSB0aGUgY2hhci1zZXEgcGFpciBhdCBzb21lIHRpbGVcclxuICAgICAqIEEuIGBhdm9pZGAgc2hvdWxkIGNvbnRhaW4gdGhlIGxhbmctc2VxdWVuY2VzIGZyb20gYWxsIHRpbGVzXHJcbiAgICAgKiByZWFjaGFibGUgYnkgYSBwbGF5ZXIgb2NjdXB5aW5nIGFueSB0aWxlIEIgZnJvbSB3aGljaCB0aGV5IGNhblxyXG4gICAgICogYWxzbyByZWFjaCBBIChleGNlcHQgZm9yIEEgaXRzZWxmKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXZvaWRcclxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBgTGFuZy5TZXFgcyB0byBhdm9pZCBjb25mbGljdHMgd2l0aCB3aGVuIGNob29zaW5nXHJcbiAgICAgKiBhIGBMYW5nLkNoYXJgIHRvIHJldHVybi4gSXMgYWxsb3dlZCB0byBjb250YWluIGVtcHR5IHN0cmluZ3MsXHJcbiAgICAgKiB3aGljaCB3aWxsIGJlIGlnbm9yZWQgYXMgaWYgdGhvc2UgZW50cmllcyBkaWQgbm90IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXF1aXJlc1xyXG4gICAgICogSW4gb3JkZXIgZm9yIHRoaXMgbGFuZ3VhZ2UgdG8gc2F0aXNmeSB0aGVzZSBjb25zdHJhaW50cywgaXQgbXVzdFxyXG4gICAgICogYmUgdHJ1ZSB0aGF0IHRoZSBudW1iZXIgb2YgbGVhZiBub2RlcyBpbiBpdHMgdHJlZS1zdHJ1Y3R1cmUgbXVzdFxyXG4gICAgICogcHJvdmFibHkgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2Ygbm9uLWVtcHR5IGVudHJpZXMgaW5cclxuICAgICAqIGBhdm9pZGAgZm9yIGFsbCBleHBlY3RlZCBjb21iaW5hdGlvbnMgb2YgaW50ZXJuYWwgc3RhdGUgYW5kXHJcbiAgICAgKiBwYXNzZWQtYXJndW1lbnRzIHVuZGVyIHdoaWNoIGl0IGNvdWxkIGJlIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0Tm9uQ29uZmxpY3RpbmdDaGFyKGF2b2lkKSB7XHJcbiAgICAgICAgLy8gV29yZGluZyB0aGUgc3BlYyBjbG9zZXIgdG8gdGhpcyBpbXBsZW1lbnRhdGlvbjogV2UgbXVzdCBmaW5kXHJcbiAgICAgICAgLy8gY2hhcmFjdGVycyBmcm9tIG5vZGVzIHRoYXQgYXJlIG5vdCBkZXNjZW5kYW50cyBvciBhbmNlc3RvcnNcclxuICAgICAgICAvLyBvZiBub2RlcyBmb3Igc2VxdWVuY2VzIHRvIGF2b2lkLiBXZSBjYW4gYmUgc3VyZSB0aGF0IG5vbmUgb2ZcclxuICAgICAgICAvLyB0aGUgYW5jZXN0b3JzIG9yIGRlc2NlbmRhbnRzIG9mIGF2b2lkLW5vZGVzIGFyZSBhdm9pZC1ub2Rlcy5cclxuICAgICAgICAvLyBTdGFydCBieSBzb3J0aW5nIGFjY29yZGluZyB0byB0aGUgZGVzaXJlZCBiYWxhbmNpbmcgc2NoZW1lOlxyXG4gICAgICAgIHRoaXMubGVhZk5vZGVzLnNvcnQoTGFuZ1NlcVRyZWUuUGFyZW50Tm9kZS5MRUFGX0NNUCk7XHJcbiAgICAgICAgbGV0IG5vZGVUb0hpdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBmb3IgKGNvbnN0IGxlYWYgb2YgdGhpcy5sZWFmTm9kZXMpIHtcclxuICAgICAgICAgICAgLy8gVGFrZSB0aGUgbmV4dCBsZWFmIG5vZGUgKGRvbid0IHJlbW92ZSBpdCEpLCBhbmQgaWYgbm9uZSBvZlxyXG4gICAgICAgICAgICAvLyBpdHMgcGFyZW50cyBhcmUgYXZvaWQtbm9kZXMsIHRoZW4sIGZyb20gdGhlIHNldCBvZiBub2Rlc1xyXG4gICAgICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIGxlYWYgbm9kZSBhbmQgYWxsIGl0cyBwYXJlbnRzIChtaW51cyB0aGUgcm9vdCksXHJcbiAgICAgICAgICAgIC8vIGNob29zZSB0aGUgbm9kZSB3aXRoIHRoZSBsZWFzdCBhY3R1YWwvcGVyc29uYWwgaGl0LWNvdW50LlxyXG4gICAgICAgICAgICBjb25zdCB1cHN0cmVhbU5vZGVzID0gbGVhZi5hbmROb25Sb290UGFyZW50cygpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwc3RyZWFtTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZsaWN0U2VxID0gYXZvaWQuZmluZCgoYXZvaWRTZXEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXZvaWRTZXEuc3RhcnRzV2l0aCh1cHN0cmVhbU5vZGVzW2ldLnNlcXVlbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0U2VxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0U2VxID09PSB1cHN0cmVhbU5vZGVzW2ldLnNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbm5vdCB1c2UgYW55dGhpbmcgb24gdGhpcyB1cHN0cmVhbSBwYXRoIGJlY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gYXZvaWQtbm9kZSBpcyBkaXJlY3RseSBpbnNpZGUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwc3RyZWFtTm9kZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgbm9kZSBvbiBhbiB1cHN0cmVhbSBwYXRoIG9mIGFuIGF2b2lkLW5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvZXNuJ3Qgc3RvcCB1cyBmcm9tIHVzaW5nIHdoYXQgd2UndmUgZm91bmQgc28gZmFyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHN0cmVhbU5vZGVzLnNwbGljZShpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVwc3RyZWFtTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIG5vbi1jb25mbGljdGluZyB1cHN0cmVhbSBub2RlLlxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbm9kZSB3aXRoIHRoZSBsb3dlc3QgcGVyc29uYWwgaGl0LWNvdW50OlxyXG4gICAgICAgICAgICAgICAgbm9kZVRvSGl0ID0gdXBzdHJlYW1Ob2Rlc1swXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB1cHN0cmVhbU5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGVyc29uYWxXZWlnaHRlZEhpdENvdW50IDwgbm9kZVRvSGl0LnBlcnNvbmFsV2VpZ2h0ZWRIaXRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9IaXQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlVG9IaXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSBiZWNhdXNlIHRoZXJlIGlzIGEgY2hlY2sgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdG9yIGZvciB0aGlzIGludmFyaWFudC5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhcmlhbnRzIGd1YXJhbnRlZWluZyB0aGF0IGEgTGFuZ1NlcSBjYW5gXHJcbiAgICAgICAgICAgICAgICArIGBhbHdheXMgYmUgc2h1ZmZsZWQtaW4gd2VyZSBub3QgbWV0LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZVRvSGl0LmNob29zZU9uZVBhaXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBzaW1wbGVWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcclxuICAgICAgICAgICAgaWQ6IHRoaXMuZnJvbnRlbmREZXNjLmlkLFxyXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogdGhpcy5mcm9udGVuZERlc2MuZGlzcGxheU5hbWUsXHJcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMudHJlZU1hcC5zaW1wbGVWaWV3KCksXHJcbiAgICAgICAgICAgIG51bUxlYXZlczogdGhpcy5sZWFmTm9kZXMubGVuZ3RoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbihmdW5jdGlvbiAoTGFuZykge1xyXG4gICAgO1xyXG59KShMYW5nIHx8IChMYW5nID0ge30pKTtcclxuT2JqZWN0LmZyZWV6ZShMYW5nKTtcclxuT2JqZWN0LmZyZWV6ZShMYW5nLnByb3RvdHlwZSk7XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/base/lang/Lang.ts\n");

/***/ }),

/***/ "./src/base/lang/LangSeqTreeNode.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LangSeqTree\": () => /* binding */ LangSeqTree\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var defs_TypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/base/defs/TypeDefs.ts\");\n\r\n\r\n/**\r\n *\r\n */\r\nvar LangSeqTree;\r\n(function (LangSeqTree) {\r\n    var _parent, _characters;\r\n    /**\r\n     *\r\n     */\r\n    class ParentNode {\r\n        constructor() {\r\n            this.children = [];\r\n        }\r\n        reset() {\r\n            this.inheritingWeightedHitCount = 0.000;\r\n            // Recursively reset (from leaves first to root last):\r\n            // We must go in such an order so that our random hit\r\n            // seeds will be properly inherited (and not wrongly\r\n            // cleared).\r\n            this.children.forEach((child) => child.reset());\r\n        }\r\n        _finalize() {\r\n            Object.freeze(this.children);\r\n            this.children.forEach((child) => child._finalize());\r\n            // The above cast to ParentNode tells to the TypeScript\r\n            // compiler that the override has protected access to us.\r\n        }\r\n        /**\r\n         *\r\n         * @param seq The typeable sequence corresponding to entries of `chars`.\r\n         * @param chars A collection of unique characters in a written language.\r\n         */\r\n        _addCharMapping(seq, chars) {\r\n            if (!(defs_TypeDefs__WEBPACK_IMPORTED_MODULE_0__.Lang.Seq.REGEXP.test(seq))) { // TODO.build disable during development\r\n                // If this errs, and the offending character is one that can\r\n                // be easily entered on a generic keyboard, don't be afraid\r\n                // to just add it to the regexp.\r\n                throw new RangeError(`Mapping-sequence \\\"${seq}\\\" did not match the`\r\n                    + ` required regular expression \\\"${defs_TypeDefs__WEBPACK_IMPORTED_MODULE_0__.Lang.Seq.REGEXP.source}\\\".`);\r\n            }\r\n            if (chars.length === 0) {\r\n                // Must not make a mapping without written characters.\r\n                throw new RangeError(\"never\");\r\n            }\r\n            let node = this;\r\n            {\r\n                let childNode = this;\r\n                while (childNode) {\r\n                    node = childNode;\r\n                    childNode = childNode.children.find((child) => seq.startsWith(child.sequence));\r\n                }\r\n            }\r\n            if (node.sequence === seq) { // TODO.build disable during development\r\n                // This should never happen.\r\n                throw new Error(`Mappings for all written-characters with a common`\r\n                    + `corresponding typeable-sequence should be registered together,`\r\n                    + `but an existing mapping for the sequence \\\"${seq}\\\" was found.`);\r\n            }\r\n            node.children.push(new ChildNode(node, seq, chars));\r\n        }\r\n        getLeafNodes() {\r\n            const leafNodes = [];\r\n            this._recursiveGetLeafNodes(leafNodes);\r\n            return leafNodes;\r\n        }\r\n        _recursiveGetLeafNodes(leafNodes) {\r\n            if (this.children.length) {\r\n                this.children.forEach((child) => {\r\n                    child._recursiveGetLeafNodes(leafNodes);\r\n                });\r\n            }\r\n            else {\r\n                leafNodes.push(this);\r\n            }\r\n        }\r\n        simpleView() {\r\n            return this.children;\r\n        }\r\n        /**\r\n         * @returns The root node of a new tree map.\r\n         */\r\n        static CREATE_TREE_MAP(forwardDict, weightScaling) {\r\n            const averageWeight = Object.values(forwardDict).reduce((sum, next) => sum += next.weight, 0);\r\n            const adjustedWeight = (function () {\r\n                return (weightScaling === 0) ? (originalWeight) => 1\r\n                    : (weightScaling === 1) ? (originalWeight) => originalWeight\r\n                        : (originalWeight) => Math.pow(originalWeight / averageWeight, weightScaling);\r\n            })();\r\n            // Reverse the map:\r\n            const reverseDict = new Map();\r\n            for (const char in forwardDict) {\r\n                const seq = forwardDict[char].seq;\r\n                const weightedChar = new WeightedLangChar(char, adjustedWeight(forwardDict[char].weight));\r\n                const charArray = reverseDict.get(seq);\r\n                if (charArray) {\r\n                    // The entry was already made:\r\n                    charArray.push(weightedChar);\r\n                }\r\n                else {\r\n                    reverseDict.set(seq, [weightedChar]);\r\n                }\r\n            }\r\n            // Add mappings in ascending order of sequence length:\r\n            // (this is so that no merging of branches needs to be done)\r\n            const rootNode = new ParentNode();\r\n            Array.from(reverseDict)\r\n                //.sort((mappingA, mappingB) => mappingA[0].localeCompare(mappingB[0]))\r\n                .sort((mappingA, mappingB) => mappingA[0].length - mappingB[0].length)\r\n                .forEach((mapping) => {\r\n                rootNode._addCharMapping(...mapping);\r\n            });\r\n            rootNode._finalize();\r\n            return rootNode;\r\n        }\r\n    }\r\n    ParentNode.LEAF_CMP = (a, b) => {\r\n        return a.inheritingWeightedHitCount - b.inheritingWeightedHitCount;\r\n    };\r\n    LangSeqTree.ParentNode = ParentNode;\r\n    Object.freeze(ParentNode);\r\n    Object.freeze(ParentNode.prototype);\r\n    /**\r\n     * No `LangSeqTreeNode`s mapped in the `children` field have an empty\r\n     * `characters` collection (with the exception of the root node). The\r\n     * root node should have a falsy parent, and the `empty string` as its\r\n     * `sequence` field, with a correspondingly empty `characters` collection.\r\n     *\r\n     * All non-root nodes have a `sequence` that is prefixed by their parent's\r\n     * `sequence`, and a non-empty `characters` collection.\r\n     *\r\n     * The enclosing {@link Lang} object has no concept of `LangChar` weights.\r\n     * All it has is the interfaces provided by the hit-count getter methods.\r\n     */\r\n    class ChildNode extends ParentNode {\r\n        constructor(parent, sequence, characters) {\r\n            super();\r\n            _parent.set(this, void 0);\r\n            _characters.set(this, void 0);\r\n            this.sequence = sequence;\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldSet)(this, _characters, characters);\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldSet)(this, _parent, parent);\r\n        }\r\n        _finalize() {\r\n            Object.freeze((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(this, _characters));\r\n            super._finalize();\r\n        }\r\n        reset() {\r\n            super.reset();\r\n            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(this, _characters).forEach((char) => {\r\n                char.reset();\r\n                this.incrementNumHits(char, Math.random() * defs_TypeDefs__WEBPACK_IMPORTED_MODULE_0__.Lang.CHAR_HIT_COUNT_SEED_CEILING);\r\n            });\r\n        }\r\n        /**\r\n         * Incrementing the hit-count makes this node less likely to be\r\n         * used for a shuffle-in. Shuffle-in option searching is easy to\r\n         * taking the viewpoint of leaf-nodes, so this implementation is\r\n         * geared toward indicating hit-count through leaf-nodes, hence\r\n         * the bubble-down of hit-count incrementation.\r\n         *\r\n         * @returns A character / sequence pair from this node that has\r\n         *      been selected the least according to the specified scheme.\r\n         */\r\n        chooseOnePair() {\r\n            const weightedChar = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(this, _characters).slice(0)\r\n                .sort(WeightedLangChar.CMP)\r\n                .shift();\r\n            const pair = {\r\n                char: weightedChar.char,\r\n                seq: this.sequence,\r\n            };\r\n            this.incrementNumHits(weightedChar);\r\n            return pair;\r\n        }\r\n        incrementNumHits(wCharToHit, numTimes = 1) {\r\n            wCharToHit._incrementNumHits();\r\n            this._recursiveIncrementNumHits(wCharToHit.weightInv * numTimes);\r\n        }\r\n        _recursiveIncrementNumHits(weightInv) {\r\n            this.inheritingWeightedHitCount += weightInv;\r\n            this.children.forEach((child) => child._recursiveIncrementNumHits(weightInv));\r\n        }\r\n        get personalWeightedHitCount() {\r\n            return this.inheritingWeightedHitCount\r\n                - (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(this, _parent).inheritingWeightedHitCount;\r\n            // The above cast is only to allow us to access a\r\n            // protected property from the parent in this subclass.\r\n        }\r\n        andNonRootParents() {\r\n            const upstreamNodes = [];\r\n            for (let node = this; node instanceof ChildNode; node = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(node, _parent)) {\r\n                upstreamNodes.push(node);\r\n            }\r\n            return upstreamNodes;\r\n        }\r\n        /**\r\n         * For debugging purposes.\r\n         */\r\n        simpleView() {\r\n            let chars = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__classPrivateFieldGet)(this, _characters).map((char) => char.simpleView());\r\n            return Object.assign(Object.create(null), {\r\n                seq: this.sequence,\r\n                chars: (chars.length === 1) ? chars[0] : chars,\r\n                kids: this.children.map((child) => child.simpleView()),\r\n            });\r\n        }\r\n    }\r\n    _parent = new WeakMap(), _characters = new WeakMap();\r\n    ChildNode.PATH_CMP = (a, b) => {\r\n        return a.personalWeightedHitCount - b.personalWeightedHitCount;\r\n    };\r\n    LangSeqTree.ChildNode = ChildNode;\r\n    Object.freeze(ChildNode);\r\n    Object.freeze(ChildNode.prototype);\r\n})(LangSeqTree || (LangSeqTree = {}));\r\nObject.freeze(LangSeqTree);\r\n/**\r\n * Has no concept of an associated typeable sequence. Used to associate\r\n * a written character to a relative frequency of occurrence in samples\r\n * of writing, and to keep a counter for how many times this character\r\n * has been shuffled-in in the current game session.\r\n *\r\n * Not exported.\r\n */\r\nclass WeightedLangChar {\r\n    constructor(char, weight) {\r\n        if (weight <= 0) { // TODO.build disable during development\r\n            throw new RangeError(`All weights must be positive, but we`\r\n                + ` were passed the value \\\"${weight}\\\" for the character`\r\n                + ` \\\"${char}\\\".`);\r\n        }\r\n        this.char = char;\r\n        this.weightInv = 1.000 / weight;\r\n        // The above choice of a numerator is not behaviourally significant.\r\n        // All that is required is that all single-mappings in a `Lang` use\r\n        // a consistent value.\r\n    }\r\n    reset() {\r\n        this.hitCount = 0;\r\n        this.weightedHitCount = 0.000;\r\n    }\r\n    _incrementNumHits() {\r\n        this.hitCount += 1;\r\n        this.weightedHitCount += this.weightInv;\r\n    }\r\n    simpleView() {\r\n        return Object.assign(Object.create(null), {\r\n            char: this.char,\r\n            hits: this.hitCount,\r\n        });\r\n    }\r\n}\r\n/**\r\n * @param a -\r\n * @param b -\r\n * @returns -\r\n */\r\nWeightedLangChar.CMP = (a, b) => {\r\n    return a.weightedHitCount - b.weightedHitCount;\r\n};\r\n;\r\nObject.freeze(WeightedLangChar);\r\nObject.freeze(WeightedLangChar.prototype);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFzZS9sYW5nL0xhbmdTZXFUcmVlTm9kZS50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3NuYWtleTMvLi9zcmMvYmFzZS9sYW5nL0xhbmdTZXFUcmVlTm9kZS50cz9lNTBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgTGFuZyBhcyBfTGFuZyB9IGZyb20gXCJkZWZzL1R5cGVEZWZzXCI7XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IHZhciBMYW5nU2VxVHJlZTtcclxuKGZ1bmN0aW9uIChMYW5nU2VxVHJlZSkge1xyXG4gICAgdmFyIF9wYXJlbnQsIF9jaGFyYWN0ZXJzO1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBQYXJlbnROb2RlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmhlcml0aW5nV2VpZ2h0ZWRIaXRDb3VudCA9IDAuMDAwO1xyXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSByZXNldCAoZnJvbSBsZWF2ZXMgZmlyc3QgdG8gcm9vdCBsYXN0KTpcclxuICAgICAgICAgICAgLy8gV2UgbXVzdCBnbyBpbiBzdWNoIGFuIG9yZGVyIHNvIHRoYXQgb3VyIHJhbmRvbSBoaXRcclxuICAgICAgICAgICAgLy8gc2VlZHMgd2lsbCBiZSBwcm9wZXJseSBpbmhlcml0ZWQgKGFuZCBub3Qgd3JvbmdseVxyXG4gICAgICAgICAgICAvLyBjbGVhcmVkKS5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gY2hpbGQucmVzZXQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maW5hbGl6ZSgpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gY2hpbGQuX2ZpbmFsaXplKCkpO1xyXG4gICAgICAgICAgICAvLyBUaGUgYWJvdmUgY2FzdCB0byBQYXJlbnROb2RlIHRlbGxzIHRvIHRoZSBUeXBlU2NyaXB0XHJcbiAgICAgICAgICAgIC8vIGNvbXBpbGVyIHRoYXQgdGhlIG92ZXJyaWRlIGhhcyBwcm90ZWN0ZWQgYWNjZXNzIHRvIHVzLlxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBzZXEgVGhlIHR5cGVhYmxlIHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gZW50cmllcyBvZiBgY2hhcnNgLlxyXG4gICAgICAgICAqIEBwYXJhbSBjaGFycyBBIGNvbGxlY3Rpb24gb2YgdW5pcXVlIGNoYXJhY3RlcnMgaW4gYSB3cml0dGVuIGxhbmd1YWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9hZGRDaGFyTWFwcGluZyhzZXEsIGNoYXJzKSB7XHJcbiAgICAgICAgICAgIGlmICghKF9MYW5nLlNlcS5SRUdFWFAudGVzdChzZXEpKSkgeyAvLyBUT0RPLmJ1aWxkIGRpc2FibGUgZHVyaW5nIGRldmVsb3BtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGVycnMsIGFuZCB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlciBpcyBvbmUgdGhhdCBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIGVhc2lseSBlbnRlcmVkIG9uIGEgZ2VuZXJpYyBrZXlib2FyZCwgZG9uJ3QgYmUgYWZyYWlkXHJcbiAgICAgICAgICAgICAgICAvLyB0byBqdXN0IGFkZCBpdCB0byB0aGUgcmVnZXhwLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1hcHBpbmctc2VxdWVuY2UgXFxcIiR7c2VxfVxcXCIgZGlkIG5vdCBtYXRjaCB0aGVgXHJcbiAgICAgICAgICAgICAgICAgICAgKyBgIHJlcXVpcmVkIHJlZ3VsYXIgZXhwcmVzc2lvbiBcXFwiJHtfTGFuZy5TZXEuUkVHRVhQLnNvdXJjZX1cXFwiLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIE11c3Qgbm90IG1ha2UgYSBtYXBwaW5nIHdpdGhvdXQgd3JpdHRlbiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJuZXZlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNoaWxkcmVuLmZpbmQoKGNoaWxkKSA9PiBzZXEuc3RhcnRzV2l0aChjaGlsZC5zZXF1ZW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLnNlcXVlbmNlID09PSBzZXEpIHsgLy8gVE9ETy5idWlsZCBkaXNhYmxlIGR1cmluZyBkZXZlbG9wbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXBwaW5ncyBmb3IgYWxsIHdyaXR0ZW4tY2hhcmFjdGVycyB3aXRoIGEgY29tbW9uYFxyXG4gICAgICAgICAgICAgICAgICAgICsgYGNvcnJlc3BvbmRpbmcgdHlwZWFibGUtc2VxdWVuY2Ugc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdG9nZXRoZXIsYFxyXG4gICAgICAgICAgICAgICAgICAgICsgYGJ1dCBhbiBleGlzdGluZyBtYXBwaW5nIGZvciB0aGUgc2VxdWVuY2UgXFxcIiR7c2VxfVxcXCIgd2FzIGZvdW5kLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ2hpbGROb2RlKG5vZGUsIHNlcSwgY2hhcnMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0TGVhZk5vZGVzKCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWFmTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlR2V0TGVhZk5vZGVzKGxlYWZOb2Rlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWFmTm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZWN1cnNpdmVHZXRMZWFmTm9kZXMobGVhZk5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLl9yZWN1cnNpdmVHZXRMZWFmTm9kZXMobGVhZk5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVhZk5vZGVzLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2ltcGxlVmlldygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSByb290IG5vZGUgb2YgYSBuZXcgdHJlZSBtYXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIENSRUFURV9UUkVFX01BUChmb3J3YXJkRGljdCwgd2VpZ2h0U2NhbGluZykge1xyXG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlV2VpZ2h0ID0gT2JqZWN0LnZhbHVlcyhmb3J3YXJkRGljdCkucmVkdWNlKChzdW0sIG5leHQpID0+IHN1bSArPSBuZXh0LndlaWdodCwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkV2VpZ2h0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAod2VpZ2h0U2NhbGluZyA9PT0gMCkgPyAob3JpZ2luYWxXZWlnaHQpID0+IDFcclxuICAgICAgICAgICAgICAgICAgICA6ICh3ZWlnaHRTY2FsaW5nID09PSAxKSA/IChvcmlnaW5hbFdlaWdodCkgPT4gb3JpZ2luYWxXZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAob3JpZ2luYWxXZWlnaHQpID0+IE1hdGgucG93KG9yaWdpbmFsV2VpZ2h0IC8gYXZlcmFnZVdlaWdodCwgd2VpZ2h0U2NhbGluZyk7XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIG1hcDpcclxuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZURpY3QgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhciBpbiBmb3J3YXJkRGljdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VxID0gZm9yd2FyZERpY3RbY2hhcl0uc2VxO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ZWRDaGFyID0gbmV3IFdlaWdodGVkTGFuZ0NoYXIoY2hhciwgYWRqdXN0ZWRXZWlnaHQoZm9yd2FyZERpY3RbY2hhcl0ud2VpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyQXJyYXkgPSByZXZlcnNlRGljdC5nZXQoc2VxKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW50cnkgd2FzIGFscmVhZHkgbWFkZTpcclxuICAgICAgICAgICAgICAgICAgICBjaGFyQXJyYXkucHVzaCh3ZWlnaHRlZENoYXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZURpY3Quc2V0KHNlcSwgW3dlaWdodGVkQ2hhcl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkZCBtYXBwaW5ncyBpbiBhc2NlbmRpbmcgb3JkZXIgb2Ygc2VxdWVuY2UgbGVuZ3RoOlxyXG4gICAgICAgICAgICAvLyAodGhpcyBpcyBzbyB0aGF0IG5vIG1lcmdpbmcgb2YgYnJhbmNoZXMgbmVlZHMgdG8gYmUgZG9uZSlcclxuICAgICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBuZXcgUGFyZW50Tm9kZSgpO1xyXG4gICAgICAgICAgICBBcnJheS5mcm9tKHJldmVyc2VEaWN0KVxyXG4gICAgICAgICAgICAgICAgLy8uc29ydCgobWFwcGluZ0EsIG1hcHBpbmdCKSA9PiBtYXBwaW5nQVswXS5sb2NhbGVDb21wYXJlKG1hcHBpbmdCWzBdKSlcclxuICAgICAgICAgICAgICAgIC5zb3J0KChtYXBwaW5nQSwgbWFwcGluZ0IpID0+IG1hcHBpbmdBWzBdLmxlbmd0aCAtIG1hcHBpbmdCWzBdLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChtYXBwaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByb290Tm9kZS5fYWRkQ2hhck1hcHBpbmcoLi4ubWFwcGluZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByb290Tm9kZS5fZmluYWxpemUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFBhcmVudE5vZGUuTEVBRl9DTVAgPSAoYSwgYikgPT4ge1xyXG4gICAgICAgIHJldHVybiBhLmluaGVyaXRpbmdXZWlnaHRlZEhpdENvdW50IC0gYi5pbmhlcml0aW5nV2VpZ2h0ZWRIaXRDb3VudDtcclxuICAgIH07XHJcbiAgICBMYW5nU2VxVHJlZS5QYXJlbnROb2RlID0gUGFyZW50Tm9kZTtcclxuICAgIE9iamVjdC5mcmVlemUoUGFyZW50Tm9kZSk7XHJcbiAgICBPYmplY3QuZnJlZXplKFBhcmVudE5vZGUucHJvdG90eXBlKTtcclxuICAgIC8qKlxyXG4gICAgICogTm8gYExhbmdTZXFUcmVlTm9kZWBzIG1hcHBlZCBpbiB0aGUgYGNoaWxkcmVuYCBmaWVsZCBoYXZlIGFuIGVtcHR5XHJcbiAgICAgKiBgY2hhcmFjdGVyc2AgY29sbGVjdGlvbiAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSByb290IG5vZGUpLiBUaGVcclxuICAgICAqIHJvb3Qgbm9kZSBzaG91bGQgaGF2ZSBhIGZhbHN5IHBhcmVudCwgYW5kIHRoZSBgZW1wdHkgc3RyaW5nYCBhcyBpdHNcclxuICAgICAqIGBzZXF1ZW5jZWAgZmllbGQsIHdpdGggYSBjb3JyZXNwb25kaW5nbHkgZW1wdHkgYGNoYXJhY3RlcnNgIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQWxsIG5vbi1yb290IG5vZGVzIGhhdmUgYSBgc2VxdWVuY2VgIHRoYXQgaXMgcHJlZml4ZWQgYnkgdGhlaXIgcGFyZW50J3NcclxuICAgICAqIGBzZXF1ZW5jZWAsIGFuZCBhIG5vbi1lbXB0eSBgY2hhcmFjdGVyc2AgY29sbGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZW5jbG9zaW5nIHtAbGluayBMYW5nfSBvYmplY3QgaGFzIG5vIGNvbmNlcHQgb2YgYExhbmdDaGFyYCB3ZWlnaHRzLlxyXG4gICAgICogQWxsIGl0IGhhcyBpcyB0aGUgaW50ZXJmYWNlcyBwcm92aWRlZCBieSB0aGUgaGl0LWNvdW50IGdldHRlciBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBDaGlsZE5vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHNlcXVlbmNlLCBjaGFyYWN0ZXJzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIF9wYXJlbnQuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICAgICAgICAgIF9jaGFyYWN0ZXJzLnNldCh0aGlzLCB2b2lkIDApO1xyXG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlID0gc2VxdWVuY2U7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX2NoYXJhY3RlcnMsIGNoYXJhY3RlcnMpO1xyXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9wYXJlbnQsIHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maW5hbGl6ZSgpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jaGFyYWN0ZXJzKSk7XHJcbiAgICAgICAgICAgIHN1cGVyLl9maW5hbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldCgpIHtcclxuICAgICAgICAgICAgc3VwZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY2hhcmFjdGVycykuZm9yRWFjaCgoY2hhcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hhci5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnROdW1IaXRzKGNoYXIsIE1hdGgucmFuZG9tKCkgKiBfTGFuZy5DSEFSX0hJVF9DT1VOVF9TRUVEX0NFSUxJTkcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5jcmVtZW50aW5nIHRoZSBoaXQtY291bnQgbWFrZXMgdGhpcyBub2RlIGxlc3MgbGlrZWx5IHRvIGJlXHJcbiAgICAgICAgICogdXNlZCBmb3IgYSBzaHVmZmxlLWluLiBTaHVmZmxlLWluIG9wdGlvbiBzZWFyY2hpbmcgaXMgZWFzeSB0b1xyXG4gICAgICAgICAqIHRha2luZyB0aGUgdmlld3BvaW50IG9mIGxlYWYtbm9kZXMsIHNvIHRoaXMgaW1wbGVtZW50YXRpb24gaXNcclxuICAgICAgICAgKiBnZWFyZWQgdG93YXJkIGluZGljYXRpbmcgaGl0LWNvdW50IHRocm91Z2ggbGVhZi1ub2RlcywgaGVuY2VcclxuICAgICAgICAgKiB0aGUgYnViYmxlLWRvd24gb2YgaGl0LWNvdW50IGluY3JlbWVudGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgQSBjaGFyYWN0ZXIgLyBzZXF1ZW5jZSBwYWlyIGZyb20gdGhpcyBub2RlIHRoYXQgaGFzXHJcbiAgICAgICAgICogICAgICBiZWVuIHNlbGVjdGVkIHRoZSBsZWFzdCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBzY2hlbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hvb3NlT25lUGFpcigpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ZWRDaGFyID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY2hhcmFjdGVycykuc2xpY2UoMClcclxuICAgICAgICAgICAgICAgIC5zb3J0KFdlaWdodGVkTGFuZ0NoYXIuQ01QKVxyXG4gICAgICAgICAgICAgICAgLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyOiB3ZWlnaHRlZENoYXIuY2hhcixcclxuICAgICAgICAgICAgICAgIHNlcTogdGhpcy5zZXF1ZW5jZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnROdW1IaXRzKHdlaWdodGVkQ2hhcik7XHJcbiAgICAgICAgICAgIHJldHVybiBwYWlyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmNyZW1lbnROdW1IaXRzKHdDaGFyVG9IaXQsIG51bVRpbWVzID0gMSkge1xyXG4gICAgICAgICAgICB3Q2hhclRvSGl0Ll9pbmNyZW1lbnROdW1IaXRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZUluY3JlbWVudE51bUhpdHMod0NoYXJUb0hpdC53ZWlnaHRJbnYgKiBudW1UaW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZWN1cnNpdmVJbmNyZW1lbnROdW1IaXRzKHdlaWdodEludikge1xyXG4gICAgICAgICAgICB0aGlzLmluaGVyaXRpbmdXZWlnaHRlZEhpdENvdW50ICs9IHdlaWdodEludjtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gY2hpbGQuX3JlY3Vyc2l2ZUluY3JlbWVudE51bUhpdHMod2VpZ2h0SW52KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBwZXJzb25hbFdlaWdodGVkSGl0Q291bnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaGVyaXRpbmdXZWlnaHRlZEhpdENvdW50XHJcbiAgICAgICAgICAgICAgICAtIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3BhcmVudCkuaW5oZXJpdGluZ1dlaWdodGVkSGl0Q291bnQ7XHJcbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBjYXN0IGlzIG9ubHkgdG8gYWxsb3cgdXMgdG8gYWNjZXNzIGFcclxuICAgICAgICAgICAgLy8gcHJvdGVjdGVkIHByb3BlcnR5IGZyb20gdGhlIHBhcmVudCBpbiB0aGlzIHN1YmNsYXNzLlxyXG4gICAgICAgIH1cclxuICAgICAgICBhbmROb25Sb290UGFyZW50cygpIHtcclxuICAgICAgICAgICAgY29uc3QgdXBzdHJlYW1Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczsgbm9kZSBpbnN0YW5jZW9mIENoaWxkTm9kZTsgbm9kZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQobm9kZSwgX3BhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHVwc3RyZWFtTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXBzdHJlYW1Ob2RlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaW1wbGVWaWV3KCkge1xyXG4gICAgICAgICAgICBsZXQgY2hhcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jaGFyYWN0ZXJzKS5tYXAoKGNoYXIpID0+IGNoYXIuc2ltcGxlVmlldygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xyXG4gICAgICAgICAgICAgICAgc2VxOiB0aGlzLnNlcXVlbmNlLFxyXG4gICAgICAgICAgICAgICAgY2hhcnM6IChjaGFycy5sZW5ndGggPT09IDEpID8gY2hhcnNbMF0gOiBjaGFycyxcclxuICAgICAgICAgICAgICAgIGtpZHM6IHRoaXMuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuc2ltcGxlVmlldygpKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3BhcmVudCA9IG5ldyBXZWFrTWFwKCksIF9jaGFyYWN0ZXJzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIENoaWxkTm9kZS5QQVRIX0NNUCA9IChhLCBiKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGEucGVyc29uYWxXZWlnaHRlZEhpdENvdW50IC0gYi5wZXJzb25hbFdlaWdodGVkSGl0Q291bnQ7XHJcbiAgICB9O1xyXG4gICAgTGFuZ1NlcVRyZWUuQ2hpbGROb2RlID0gQ2hpbGROb2RlO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShDaGlsZE5vZGUpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShDaGlsZE5vZGUucHJvdG90eXBlKTtcclxufSkoTGFuZ1NlcVRyZWUgfHwgKExhbmdTZXFUcmVlID0ge30pKTtcclxuT2JqZWN0LmZyZWV6ZShMYW5nU2VxVHJlZSk7XHJcbi8qKlxyXG4gKiBIYXMgbm8gY29uY2VwdCBvZiBhbiBhc3NvY2lhdGVkIHR5cGVhYmxlIHNlcXVlbmNlLiBVc2VkIHRvIGFzc29jaWF0ZVxyXG4gKiBhIHdyaXR0ZW4gY2hhcmFjdGVyIHRvIGEgcmVsYXRpdmUgZnJlcXVlbmN5IG9mIG9jY3VycmVuY2UgaW4gc2FtcGxlc1xyXG4gKiBvZiB3cml0aW5nLCBhbmQgdG8ga2VlcCBhIGNvdW50ZXIgZm9yIGhvdyBtYW55IHRpbWVzIHRoaXMgY2hhcmFjdGVyXHJcbiAqIGhhcyBiZWVuIHNodWZmbGVkLWluIGluIHRoZSBjdXJyZW50IGdhbWUgc2Vzc2lvbi5cclxuICpcclxuICogTm90IGV4cG9ydGVkLlxyXG4gKi9cclxuY2xhc3MgV2VpZ2h0ZWRMYW5nQ2hhciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFyLCB3ZWlnaHQpIHtcclxuICAgICAgICBpZiAod2VpZ2h0IDw9IDApIHsgLy8gVE9ETy5idWlsZCBkaXNhYmxlIGR1cmluZyBkZXZlbG9wbWVudFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQWxsIHdlaWdodHMgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IHdlYFxyXG4gICAgICAgICAgICAgICAgKyBgIHdlcmUgcGFzc2VkIHRoZSB2YWx1ZSBcXFwiJHt3ZWlnaHR9XFxcIiBmb3IgdGhlIGNoYXJhY3RlcmBcclxuICAgICAgICAgICAgICAgICsgYCBcXFwiJHtjaGFyfVxcXCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhciA9IGNoYXI7XHJcbiAgICAgICAgdGhpcy53ZWlnaHRJbnYgPSAxLjAwMCAvIHdlaWdodDtcclxuICAgICAgICAvLyBUaGUgYWJvdmUgY2hvaWNlIG9mIGEgbnVtZXJhdG9yIGlzIG5vdCBiZWhhdmlvdXJhbGx5IHNpZ25pZmljYW50LlxyXG4gICAgICAgIC8vIEFsbCB0aGF0IGlzIHJlcXVpcmVkIGlzIHRoYXQgYWxsIHNpbmdsZS1tYXBwaW5ncyBpbiBhIGBMYW5nYCB1c2VcclxuICAgICAgICAvLyBhIGNvbnNpc3RlbnQgdmFsdWUuXHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmhpdENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLndlaWdodGVkSGl0Q291bnQgPSAwLjAwMDtcclxuICAgIH1cclxuICAgIF9pbmNyZW1lbnROdW1IaXRzKCkge1xyXG4gICAgICAgIHRoaXMuaGl0Q291bnQgKz0gMTtcclxuICAgICAgICB0aGlzLndlaWdodGVkSGl0Q291bnQgKz0gdGhpcy53ZWlnaHRJbnY7XHJcbiAgICB9XHJcbiAgICBzaW1wbGVWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcclxuICAgICAgICAgICAgY2hhcjogdGhpcy5jaGFyLFxyXG4gICAgICAgICAgICBoaXRzOiB0aGlzLmhpdENvdW50LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gYSAtXHJcbiAqIEBwYXJhbSBiIC1cclxuICogQHJldHVybnMgLVxyXG4gKi9cclxuV2VpZ2h0ZWRMYW5nQ2hhci5DTVAgPSAoYSwgYikgPT4ge1xyXG4gICAgcmV0dXJuIGEud2VpZ2h0ZWRIaXRDb3VudCAtIGIud2VpZ2h0ZWRIaXRDb3VudDtcclxufTtcclxuO1xyXG5PYmplY3QuZnJlZXplKFdlaWdodGVkTGFuZ0NoYXIpO1xyXG5PYmplY3QuZnJlZXplKFdlaWdodGVkTGFuZ0NoYXIucHJvdG90eXBlKTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/base/lang/LangSeqTreeNode.ts\n");

/***/ }),

/***/ "./src/client/game/OfflineGame.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OfflineGame\": () => /* binding */ OfflineGame\n/* harmony export */ });\n/* harmony import */ var _BrowserGame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/client/game/BrowserGame.ts\");\n/* harmony import */ var game_gameparts_GamepartManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./src/base/game/gameparts/GamepartManager.ts\");\n\r\n\r\n/**\r\n *\r\n */\r\nclass OfflineGame extends game_gameparts_GamepartManager__WEBPACK_IMPORTED_MODULE_1__.GamepartManager {\r\n    /**\r\n     * @param gameDesc -\r\n     */\r\n    constructor(onGameBecomeOver, gameDesc) {\r\n        super(_BrowserGame__WEBPACK_IMPORTED_MODULE_0__.Game.Type.OFFLINE, {\r\n            onGameBecomeOver,\r\n            tileClass: _BrowserGame__WEBPACK_IMPORTED_MODULE_0__.VisibleTile,\r\n            playerStatusCtor: _BrowserGame__WEBPACK_IMPORTED_MODULE_0__.VisiblePlayerStatus,\r\n        }, gameDesc);\r\n        this._ctorBrowserGame();\r\n    }\r\n    /**\r\n     * @override\r\n     */\r\n    setTimeout(callback, millis, ...args) {\r\n        return setTimeout(callback, millis, args);\r\n    }\r\n    /**\r\n     * @override\r\n     */\r\n    cancelTimeout(handle) {\r\n        clearTimeout(handle);\r\n    }\r\n}\r\n;\r\n_BrowserGame__WEBPACK_IMPORTED_MODULE_0__.JsUtils.applyMixins(OfflineGame, [_BrowserGame__WEBPACK_IMPORTED_MODULE_0__.BrowserGameMixin]);\r\nObject.freeze(OfflineGame);\r\nObject.freeze(OfflineGame.prototype);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2xpZW50L2dhbWUvT2ZmbGluZUdhbWUudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbmFrZXkzLy4vc3JjL2NsaWVudC9nYW1lL09mZmxpbmVHYW1lLnRzPzkzM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSnNVdGlscywgR2FtZSwgVmlzaWJsZVRpbGUsIEJyb3dzZXJHYW1lTWl4aW4sIFxyXG4vLyBQbGF5ZXIsIE9wZXJhdG9yUGxheWVyLFxyXG5WaXNpYmxlUGxheWVyU3RhdHVzLCB9IGZyb20gXCIuL0Jyb3dzZXJHYW1lXCI7XHJcbmltcG9ydCB7IEdhbWVwYXJ0TWFuYWdlciB9IGZyb20gXCJnYW1lL2dhbWVwYXJ0cy9HYW1lcGFydE1hbmFnZXJcIjtcclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT2ZmbGluZUdhbWUgZXh0ZW5kcyBHYW1lcGFydE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZ2FtZURlc2MgLVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvbkdhbWVCZWNvbWVPdmVyLCBnYW1lRGVzYykge1xyXG4gICAgICAgIHN1cGVyKEdhbWUuVHlwZS5PRkZMSU5FLCB7XHJcbiAgICAgICAgICAgIG9uR2FtZUJlY29tZU92ZXIsXHJcbiAgICAgICAgICAgIHRpbGVDbGFzczogVmlzaWJsZVRpbGUsXHJcbiAgICAgICAgICAgIHBsYXllclN0YXR1c0N0b3I6IFZpc2libGVQbGF5ZXJTdGF0dXMsXHJcbiAgICAgICAgfSwgZ2FtZURlc2MpO1xyXG4gICAgICAgIHRoaXMuX2N0b3JCcm93c2VyR2FtZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgbWlsbGlzLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIG1pbGxpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBjYW5jZWxUaW1lb3V0KGhhbmRsZSkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcbjtcclxuSnNVdGlscy5hcHBseU1peGlucyhPZmZsaW5lR2FtZSwgW0Jyb3dzZXJHYW1lTWl4aW5dKTtcclxuT2JqZWN0LmZyZWV6ZShPZmZsaW5lR2FtZSk7XHJcbk9iamVjdC5mcmVlemUoT2ZmbGluZUdhbWUucHJvdG90eXBlKTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/client/game/OfflineGame.ts\n");

/***/ }),

/***/ "./src/base/lang/impl lazy recursive ^\\.\\/.*\\.ts$":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./Emote.ts": [
		"./src/base/lang/impl/Emote.ts",
		"lang/Emote-ts"
	],
	"./English.ts": [
		"./src/base/lang/impl/English.ts",
		"lang/English-ts"
	],
	"./Japanese.ts": [
		"./src/base/lang/impl/Japanese.ts",
		"lang/Japanese-ts"
	],
	"./Korean.ts": [
		"./src/base/lang/impl/Korean.ts",
		"lang/Korean-ts"
	],
	"./Morse.ts": [
		"./src/base/lang/impl/Morse.ts",
		"lang/Morse-ts"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => Object.keys(map);
webpackAsyncContext.id = "./src/base/lang/impl lazy recursive ^\\.\\/.*\\.ts$";
module.exports = webpackAsyncContext;

/***/ })

}]);